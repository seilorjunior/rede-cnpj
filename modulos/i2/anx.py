#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed May 14 10:46:00 2014 by generateDS.py version 2.12d.
#
# Command line options:
#   ('-o', 'anx.py')
#
# Command line arguments:
#   /home/pcbje/.wine/dosdevices/c:/Program Files (x86)/Common Files/i2 Shared/XML/Schema/Analyst's Notebook 7.xsd
#
# Command line:
#   generateDS.py -o "anx.py" /home/pcbje/.wine/dosdevices/c:/Program Files (x86)/Common Files/i2 Shared/XML/Schema/Analyst's Notebook 7.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.12d
#
#original source code:
#https://github.com/pcbje/pyanx

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ApplicationVersion(GeneratedsSuper):
    """The version of Analyst's Notebook that was used to save the
    chart.The major version number element of the ANB version.The
    minor version number element of the ANB version.The point
    element of the ANB version.The build number element of the ANB
    version."""
    subclass = None
    superclass = None
    def __init__(self, Major=None, Build=None, Minor=None, Point=None):
        self.original_tagname_ = None
        self.Major = _cast(int, Major)
        self.Build = _cast(int, Build)
        self.Minor = _cast(int, Minor)
        self.Point = _cast(int, Point)
    def factory(*args_, **kwargs_):
        if ApplicationVersion.subclass:
            return ApplicationVersion.subclass(*args_, **kwargs_)
        else:
            return ApplicationVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Major(self): return self.Major
    def set_Major(self, Major): self.Major = Major
    def get_Build(self): return self.Build
    def set_Build(self, Build): self.Build = Build
    def get_Minor(self): return self.Minor
    def set_Minor(self, Minor): self.Minor = Minor
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApplicationVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApplicationVersion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApplicationVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApplicationVersion'):
        if self.Major is not None and 'Major' not in already_processed:
            already_processed.add('Major')
            outfile.write(' Major="%s"' % self.gds_format_integer(self.Major, input_name='Major'))
        if self.Build is not None and 'Build' not in already_processed:
            already_processed.add('Build')
            outfile.write(' Build="%s"' % self.gds_format_integer(self.Build, input_name='Build'))
        if self.Minor is not None and 'Minor' not in already_processed:
            already_processed.add('Minor')
            outfile.write(' Minor="%s"' % self.gds_format_integer(self.Minor, input_name='Minor'))
        if self.Point is not None and 'Point' not in already_processed:
            already_processed.add('Point')
            outfile.write(' Point="%s"' % self.gds_format_integer(self.Point, input_name='Point'))
    def exportChildren(self, outfile, level, namespace_='', name_='ApplicationVersion', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ApplicationVersion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Major is not None and 'Major' not in already_processed:
            already_processed.add('Major')
            showIndent(outfile, level)
            outfile.write('Major=%d,\n' % (self.Major,))
        if self.Build is not None and 'Build' not in already_processed:
            already_processed.add('Build')
            showIndent(outfile, level)
            outfile.write('Build=%d,\n' % (self.Build,))
        if self.Minor is not None and 'Minor' not in already_processed:
            already_processed.add('Minor')
            showIndent(outfile, level)
            outfile.write('Minor=%d,\n' % (self.Minor,))
        if self.Point is not None and 'Point' not in already_processed:
            already_processed.add('Point')
            showIndent(outfile, level)
            outfile.write('Point=%d,\n' % (self.Point,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Major', node)
        if value is not None and 'Major' not in already_processed:
            already_processed.add('Major')
            try:
                self.Major = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Build', node)
        if value is not None and 'Build' not in already_processed:
            already_processed.add('Build')
            try:
                self.Build = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Minor', node)
        if value is not None and 'Minor' not in already_processed:
            already_processed.add('Minor')
            try:
                self.Minor = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Point', node)
        if value is not None and 'Point' not in already_processed:
            already_processed.add('Point')
            try:
                self.Point = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ApplicationVersion


class Attribute(GeneratedsSuper):
    """Contains the attribute value and the specified attribute class for a
    chart item.Attribute class name. Instances of attribute classes
    can be added to chart items and permit named values to be
    associated with specific chart items.Attribute class IDREF.
    Instances of attribute classes can be added to chart items and
    permit named values to be associated with specific chart
    items.Attribute value for the specified attribute class on this
    chart item. Writing a non-existent attribute creates it. Reading
    a non-existent attribute raises a run-time error."""
    subclass = None
    superclass = None
    def __init__(self, AttributeClassReference=None, Value=None, AttributeClass=None):
        self.original_tagname_ = None
        self.AttributeClassReference = _cast(None, AttributeClassReference)
        self.Value = _cast(None, Value)
        self.AttributeClass = _cast(None, AttributeClass)
    def factory(*args_, **kwargs_):
        if Attribute.subclass:
            return Attribute.subclass(*args_, **kwargs_)
        else:
            return Attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClassReference(self): return self.AttributeClassReference
    def set_AttributeClassReference(self, AttributeClassReference): self.AttributeClassReference = AttributeClassReference
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_AttributeClass(self): return self.AttributeClass
    def set_AttributeClass(self, AttributeClass): self.AttributeClass = AttributeClass
    def validate_AttributeValue(self, value):
        # Validate type AttributeValue, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Attribute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Attribute', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attribute'):
        if self.AttributeClassReference is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            outfile.write(' AttributeClassReference=%s' % (self.gds_format_string(quote_attrib(self.AttributeClassReference).encode(ExternalEncoding), input_name='AttributeClassReference'), ))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(' Value=%s' % (quote_attrib(self.Value), ))
        if self.AttributeClass is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            outfile.write(' AttributeClass=%s' % (self.gds_format_string(quote_attrib(self.AttributeClass).encode(ExternalEncoding), input_name='AttributeClass'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Attribute', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Attribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AttributeClassReference is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            showIndent(outfile, level)
            outfile.write('AttributeClassReference="%s",\n' % (self.AttributeClassReference,))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % (self.Value,))
        if self.AttributeClass is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            showIndent(outfile, level)
            outfile.write('AttributeClass="%s",\n' % (self.AttributeClass,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AttributeClassReference', node)
        if value is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            self.AttributeClassReference = value
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value
            self.validate_AttributeValue(self.Value)    # validate type AttributeValue
        value = find_attr_value_('AttributeClass', node)
        if value is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            self.AttributeClass = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Attribute


class AttributeClass(GeneratedsSuper):
    """Attribute class object. Instances of attribute classes can be added
    to chart items and permit named values to be associated with
    specific chart items.Number of decimal places for numeric types
    of attribute classes.Name of the displayed attribute symbol,
    which can be an icon name for a standard icon from the
    application or a full path to a file to display a custom
    icon.Attribute class ID (see IdReferenceLinking).If True, the
    attribute class is a user attribute class.Behavior when
    attributes instances of the class are merged.Name of the
    attribute class.Behavior when attribute instances of the class
    are pasted.Prefix string for the attribute class, which is
    displayed on attribute instances on chart items.The property
    semantic type assigned to this attribute class. Raises an error
    if the property semantic type has already been assigned to
    another attribute class.If True, display the date portion of a
    date & time attribute value on attribute instances and entries.
    Valid for date & time attribute classes only.If True, show the
    flag value on attribute instances and entries only if the value
    is True. Valid for flag attribute instances and entries only.If
    True, display the attribute class prefix on attribute instances
    and entries.If True, display the seconds portion of a date &
    time attribute value on attribute instances and entries. Valid
    for date & time attribute classes only.If True, display the
    attribute class suffix on attribute instances and entries.If
    True, display the attribute class symbol on attribute instances
    and entries.If True, display the hours and minutes portions of a
    date & time attribute value on attribute instances and entries.
    Valid for date & time attribute classes only.If True, display
    the attribute value on attribute instances and entries.Suffix
    string for the attribute class, which is displayed on attribute
    instances on chart items.Type of this attribute class. Possible
    types are Boolean flag, text, numeric or date & time.If True, an
    end user can add this attribute class to a chart item.If True,
    an end user can delete this attribute class from a chart item.If
    True, instances of this attribute class are shown on the
    chart.If True, display the attribute class name on attribute
    instances and entries."""
    subclass = None
    superclass = None
    def __init__(self, PasteBehaviour=None, ShowTime=True, ShowSuffix=False, IsUser=True, Type=None, ShowSymbol=True, ShowSeconds=False, SemanticTypeGuid=None, IconFile='General', ShowValue=True, Name=None, UserCanAdd=True, ShowIfSet=False, ShowClassName=None, Suffix=None, Visible=True, Prefix=None, UserCanRemove=True, ShowPrefix=False, DecimalPlaces=2, MergeBehaviour=None, Id=None, ShowDate=True, Font=None):
        self.original_tagname_ = None
        self.PasteBehaviour = _cast(None, PasteBehaviour)
        self.ShowTime = _cast(bool, ShowTime)
        self.ShowSuffix = _cast(bool, ShowSuffix)
        self.IsUser = _cast(bool, IsUser)
        self.Type = _cast(None, Type)
        self.ShowSymbol = _cast(bool, ShowSymbol)
        self.ShowSeconds = _cast(bool, ShowSeconds)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.IconFile = _cast(None, IconFile)
        self.ShowValue = _cast(bool, ShowValue)
        self.Name = _cast(None, Name)
        self.UserCanAdd = _cast(bool, UserCanAdd)
        self.ShowIfSet = _cast(bool, ShowIfSet)
        self.ShowClassName = _cast(bool, ShowClassName)
        self.Suffix = _cast(None, Suffix)
        self.Visible = _cast(bool, Visible)
        self.Prefix = _cast(None, Prefix)
        self.UserCanRemove = _cast(bool, UserCanRemove)
        self.ShowPrefix = _cast(bool, ShowPrefix)
        self.DecimalPlaces = _cast(int, DecimalPlaces)
        self.MergeBehaviour = _cast(None, MergeBehaviour)
        self.Id = _cast(None, Id)
        self.ShowDate = _cast(bool, ShowDate)
        if Font is None:
            self.Font = []
        else:
            self.Font = Font
    def factory(*args_, **kwargs_):
        if AttributeClass.subclass:
            return AttributeClass.subclass(*args_, **kwargs_)
        else:
            return AttributeClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def add_Font(self, value): self.Font.append(value)
    def insert_Font(self, index, value): self.Font[index] = value
    def get_PasteBehaviour(self): return self.PasteBehaviour
    def set_PasteBehaviour(self, PasteBehaviour): self.PasteBehaviour = PasteBehaviour
    def get_ShowTime(self): return self.ShowTime
    def set_ShowTime(self, ShowTime): self.ShowTime = ShowTime
    def get_ShowSuffix(self): return self.ShowSuffix
    def set_ShowSuffix(self, ShowSuffix): self.ShowSuffix = ShowSuffix
    def get_IsUser(self): return self.IsUser
    def set_IsUser(self, IsUser): self.IsUser = IsUser
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ShowSymbol(self): return self.ShowSymbol
    def set_ShowSymbol(self, ShowSymbol): self.ShowSymbol = ShowSymbol
    def get_ShowSeconds(self): return self.ShowSeconds
    def set_ShowSeconds(self, ShowSeconds): self.ShowSeconds = ShowSeconds
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_IconFile(self): return self.IconFile
    def set_IconFile(self, IconFile): self.IconFile = IconFile
    def get_ShowValue(self): return self.ShowValue
    def set_ShowValue(self, ShowValue): self.ShowValue = ShowValue
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_UserCanAdd(self): return self.UserCanAdd
    def set_UserCanAdd(self, UserCanAdd): self.UserCanAdd = UserCanAdd
    def get_ShowIfSet(self): return self.ShowIfSet
    def set_ShowIfSet(self, ShowIfSet): self.ShowIfSet = ShowIfSet
    def get_ShowClassName(self): return self.ShowClassName
    def set_ShowClassName(self, ShowClassName): self.ShowClassName = ShowClassName
    def get_Suffix(self): return self.Suffix
    def set_Suffix(self, Suffix): self.Suffix = Suffix
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_Prefix(self): return self.Prefix
    def set_Prefix(self, Prefix): self.Prefix = Prefix
    def get_UserCanRemove(self): return self.UserCanRemove
    def set_UserCanRemove(self, UserCanRemove): self.UserCanRemove = UserCanRemove
    def get_ShowPrefix(self): return self.ShowPrefix
    def set_ShowPrefix(self, ShowPrefix): self.ShowPrefix = ShowPrefix
    def get_DecimalPlaces(self): return self.DecimalPlaces
    def set_DecimalPlaces(self, DecimalPlaces): self.DecimalPlaces = DecimalPlaces
    def get_MergeBehaviour(self): return self.MergeBehaviour
    def set_MergeBehaviour(self, MergeBehaviour): self.MergeBehaviour = MergeBehaviour
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_ShowDate(self): return self.ShowDate
    def set_ShowDate(self, ShowDate): self.ShowDate = ShowDate
    def validate_AttributeBehaviourEnum(self, value):
        # Validate type AttributeBehaviourEnum, a restriction on xsd:string.
        pass
    def validate_AttributeTypeEnum(self, value):
        # Validate type AttributeTypeEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.Font
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeClass', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeClass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeClass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeClass'):
        if self.PasteBehaviour is not None and 'PasteBehaviour' not in already_processed:
            already_processed.add('PasteBehaviour')
            outfile.write(' PasteBehaviour=%s' % (quote_attrib(self.PasteBehaviour), ))
        if self.ShowTime is not None and 'ShowTime' not in already_processed:
            already_processed.add('ShowTime')
            outfile.write(' ShowTime="%s"' % self.gds_format_boolean(self.ShowTime, input_name='ShowTime'))
        if self.ShowSuffix is not None and 'ShowSuffix' not in already_processed:
            already_processed.add('ShowSuffix')
            outfile.write(' ShowSuffix="%s"' % self.gds_format_boolean(self.ShowSuffix, input_name='ShowSuffix'))
        if self.IsUser is not None and 'IsUser' not in already_processed:
            already_processed.add('IsUser')
            outfile.write(' IsUser="%s"' % self.gds_format_boolean(self.IsUser, input_name='IsUser'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ShowSymbol is not None and 'ShowSymbol' not in already_processed:
            already_processed.add('ShowSymbol')
            outfile.write(' ShowSymbol="%s"' % self.gds_format_boolean(self.ShowSymbol, input_name='ShowSymbol'))
        if self.ShowSeconds is not None and 'ShowSeconds' not in already_processed:
            already_processed.add('ShowSeconds')
            outfile.write(' ShowSeconds="%s"' % self.gds_format_boolean(self.ShowSeconds, input_name='ShowSeconds'))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.IconFile is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            outfile.write(' IconFile=%s' % (self.gds_format_string(quote_attrib(self.IconFile).encode(ExternalEncoding), input_name='IconFile'), ))
        if self.ShowValue is not None and 'ShowValue' not in already_processed:
            already_processed.add('ShowValue')
            outfile.write(' ShowValue="%s"' % self.gds_format_boolean(self.ShowValue, input_name='ShowValue'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.UserCanAdd is not None and 'UserCanAdd' not in already_processed:
            already_processed.add('UserCanAdd')
            outfile.write(' UserCanAdd="%s"' % self.gds_format_boolean(self.UserCanAdd, input_name='UserCanAdd'))
        if self.ShowIfSet is not None and 'ShowIfSet' not in already_processed:
            already_processed.add('ShowIfSet')
            outfile.write(' ShowIfSet="%s"' % self.gds_format_boolean(self.ShowIfSet, input_name='ShowIfSet'))
        if self.ShowClassName is not None and 'ShowClassName' not in already_processed:
            already_processed.add('ShowClassName')
            outfile.write(' ShowClassName="%s"' % self.gds_format_boolean(self.ShowClassName, input_name='ShowClassName'))
        if self.Suffix is not None and 'Suffix' not in already_processed:
            already_processed.add('Suffix')
            outfile.write(' Suffix=%s' % (self.gds_format_string(quote_attrib(self.Suffix).encode(ExternalEncoding), input_name='Suffix'), ))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.Prefix is not None and 'Prefix' not in already_processed:
            already_processed.add('Prefix')
            outfile.write(' Prefix=%s' % (self.gds_format_string(quote_attrib(self.Prefix).encode(ExternalEncoding), input_name='Prefix'), ))
        if self.UserCanRemove is not None and 'UserCanRemove' not in already_processed:
            already_processed.add('UserCanRemove')
            outfile.write(' UserCanRemove="%s"' % self.gds_format_boolean(self.UserCanRemove, input_name='UserCanRemove'))
        if self.ShowPrefix is not None and 'ShowPrefix' not in already_processed:
            already_processed.add('ShowPrefix')
            outfile.write(' ShowPrefix="%s"' % self.gds_format_boolean(self.ShowPrefix, input_name='ShowPrefix'))
        if self.DecimalPlaces is not None and 'DecimalPlaces' not in already_processed:
            already_processed.add('DecimalPlaces')
            outfile.write(' DecimalPlaces="%s"' % self.gds_format_integer(self.DecimalPlaces, input_name='DecimalPlaces'))
        if self.MergeBehaviour is not None and 'MergeBehaviour' not in already_processed:
            already_processed.add('MergeBehaviour')
            outfile.write(' MergeBehaviour=%s' % (quote_attrib(self.MergeBehaviour), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.ShowDate is not None and 'ShowDate' not in already_processed:
            already_processed.add('ShowDate')
            outfile.write(' ShowDate="%s"' % self.gds_format_boolean(self.ShowDate, input_name='ShowDate'))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeClass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Font_ in self.Font:
            Font_.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeClass'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PasteBehaviour is not None and 'PasteBehaviour' not in already_processed:
            already_processed.add('PasteBehaviour')
            showIndent(outfile, level)
            outfile.write('PasteBehaviour="%s",\n' % (self.PasteBehaviour,))
        if self.ShowTime is not None and 'ShowTime' not in already_processed:
            already_processed.add('ShowTime')
            showIndent(outfile, level)
            outfile.write('ShowTime=%s,\n' % (self.ShowTime,))
        if self.ShowSuffix is not None and 'ShowSuffix' not in already_processed:
            already_processed.add('ShowSuffix')
            showIndent(outfile, level)
            outfile.write('ShowSuffix=%s,\n' % (self.ShowSuffix,))
        if self.IsUser is not None and 'IsUser' not in already_processed:
            already_processed.add('IsUser')
            showIndent(outfile, level)
            outfile.write('IsUser=%s,\n' % (self.IsUser,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ShowSymbol is not None and 'ShowSymbol' not in already_processed:
            already_processed.add('ShowSymbol')
            showIndent(outfile, level)
            outfile.write('ShowSymbol=%s,\n' % (self.ShowSymbol,))
        if self.ShowSeconds is not None and 'ShowSeconds' not in already_processed:
            already_processed.add('ShowSeconds')
            showIndent(outfile, level)
            outfile.write('ShowSeconds=%s,\n' % (self.ShowSeconds,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.IconFile is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            showIndent(outfile, level)
            outfile.write('IconFile="%s",\n' % (self.IconFile,))
        if self.ShowValue is not None and 'ShowValue' not in already_processed:
            already_processed.add('ShowValue')
            showIndent(outfile, level)
            outfile.write('ShowValue=%s,\n' % (self.ShowValue,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.UserCanAdd is not None and 'UserCanAdd' not in already_processed:
            already_processed.add('UserCanAdd')
            showIndent(outfile, level)
            outfile.write('UserCanAdd=%s,\n' % (self.UserCanAdd,))
        if self.ShowIfSet is not None and 'ShowIfSet' not in already_processed:
            already_processed.add('ShowIfSet')
            showIndent(outfile, level)
            outfile.write('ShowIfSet=%s,\n' % (self.ShowIfSet,))
        if self.ShowClassName is not None and 'ShowClassName' not in already_processed:
            already_processed.add('ShowClassName')
            showIndent(outfile, level)
            outfile.write('ShowClassName=%s,\n' % (self.ShowClassName,))
        if self.Suffix is not None and 'Suffix' not in already_processed:
            already_processed.add('Suffix')
            showIndent(outfile, level)
            outfile.write('Suffix="%s",\n' % (self.Suffix,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.Prefix is not None and 'Prefix' not in already_processed:
            already_processed.add('Prefix')
            showIndent(outfile, level)
            outfile.write('Prefix="%s",\n' % (self.Prefix,))
        if self.UserCanRemove is not None and 'UserCanRemove' not in already_processed:
            already_processed.add('UserCanRemove')
            showIndent(outfile, level)
            outfile.write('UserCanRemove=%s,\n' % (self.UserCanRemove,))
        if self.ShowPrefix is not None and 'ShowPrefix' not in already_processed:
            already_processed.add('ShowPrefix')
            showIndent(outfile, level)
            outfile.write('ShowPrefix=%s,\n' % (self.ShowPrefix,))
        if self.DecimalPlaces is not None and 'DecimalPlaces' not in already_processed:
            already_processed.add('DecimalPlaces')
            showIndent(outfile, level)
            outfile.write('DecimalPlaces=%d,\n' % (self.DecimalPlaces,))
        if self.MergeBehaviour is not None and 'MergeBehaviour' not in already_processed:
            already_processed.add('MergeBehaviour')
            showIndent(outfile, level)
            outfile.write('MergeBehaviour="%s",\n' % (self.MergeBehaviour,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.ShowDate is not None and 'ShowDate' not in already_processed:
            already_processed.add('ShowDate')
            showIndent(outfile, level)
            outfile.write('ShowDate=%s,\n' % (self.ShowDate,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Font=[\n')
        level += 1
        for Font_ in self.Font:
            showIndent(outfile, level)
            outfile.write('model_.Font(\n')
            Font_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PasteBehaviour', node)
        if value is not None and 'PasteBehaviour' not in already_processed:
            already_processed.add('PasteBehaviour')
            self.PasteBehaviour = value
            self.validate_AttributeBehaviourEnum(self.PasteBehaviour)    # validate type AttributeBehaviourEnum
        value = find_attr_value_('ShowTime', node)
        if value is not None and 'ShowTime' not in already_processed:
            already_processed.add('ShowTime')
            if value in ('true', '1'):
                self.ShowTime = True
            elif value in ('false', '0'):
                self.ShowTime = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowSuffix', node)
        if value is not None and 'ShowSuffix' not in already_processed:
            already_processed.add('ShowSuffix')
            if value in ('true', '1'):
                self.ShowSuffix = True
            elif value in ('false', '0'):
                self.ShowSuffix = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('IsUser', node)
        if value is not None and 'IsUser' not in already_processed:
            already_processed.add('IsUser')
            if value in ('true', '1'):
                self.IsUser = True
            elif value in ('false', '0'):
                self.IsUser = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_AttributeTypeEnum(self.Type)    # validate type AttributeTypeEnum
        value = find_attr_value_('ShowSymbol', node)
        if value is not None and 'ShowSymbol' not in already_processed:
            already_processed.add('ShowSymbol')
            if value in ('true', '1'):
                self.ShowSymbol = True
            elif value in ('false', '0'):
                self.ShowSymbol = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowSeconds', node)
        if value is not None and 'ShowSeconds' not in already_processed:
            already_processed.add('ShowSeconds')
            if value in ('true', '1'):
                self.ShowSeconds = True
            elif value in ('false', '0'):
                self.ShowSeconds = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('IconFile', node)
        if value is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            self.IconFile = value
        value = find_attr_value_('ShowValue', node)
        if value is not None and 'ShowValue' not in already_processed:
            already_processed.add('ShowValue')
            if value in ('true', '1'):
                self.ShowValue = True
            elif value in ('false', '0'):
                self.ShowValue = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('UserCanAdd', node)
        if value is not None and 'UserCanAdd' not in already_processed:
            already_processed.add('UserCanAdd')
            if value in ('true', '1'):
                self.UserCanAdd = True
            elif value in ('false', '0'):
                self.UserCanAdd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowIfSet', node)
        if value is not None and 'ShowIfSet' not in already_processed:
            already_processed.add('ShowIfSet')
            if value in ('true', '1'):
                self.ShowIfSet = True
            elif value in ('false', '0'):
                self.ShowIfSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowClassName', node)
        if value is not None and 'ShowClassName' not in already_processed:
            already_processed.add('ShowClassName')
            if value in ('true', '1'):
                self.ShowClassName = True
            elif value in ('false', '0'):
                self.ShowClassName = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Suffix', node)
        if value is not None and 'Suffix' not in already_processed:
            already_processed.add('Suffix')
            self.Suffix = value
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Prefix', node)
        if value is not None and 'Prefix' not in already_processed:
            already_processed.add('Prefix')
            self.Prefix = value
        value = find_attr_value_('UserCanRemove', node)
        if value is not None and 'UserCanRemove' not in already_processed:
            already_processed.add('UserCanRemove')
            if value in ('true', '1'):
                self.UserCanRemove = True
            elif value in ('false', '0'):
                self.UserCanRemove = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowPrefix', node)
        if value is not None and 'ShowPrefix' not in already_processed:
            already_processed.add('ShowPrefix')
            if value in ('true', '1'):
                self.ShowPrefix = True
            elif value in ('false', '0'):
                self.ShowPrefix = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DecimalPlaces', node)
        if value is not None and 'DecimalPlaces' not in already_processed:
            already_processed.add('DecimalPlaces')
            try:
                self.DecimalPlaces = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MergeBehaviour', node)
        if value is not None and 'MergeBehaviour' not in already_processed:
            already_processed.add('MergeBehaviour')
            self.MergeBehaviour = value
            self.validate_AttributeBehaviourEnum(self.MergeBehaviour)    # validate type AttributeBehaviourEnum
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('ShowDate', node)
        if value is not None and 'ShowDate' not in already_processed:
            already_processed.add('ShowDate')
            if value in ('true', '1'):
                self.ShowDate = True
            elif value in ('false', '0'):
                self.ShowDate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font.append(obj_)
            obj_.original_tagname_ = 'Font'
# end class AttributeClass


class AttributeClassCollection(GeneratedsSuper):
    """Collection of auto, system and user attribute classes on the chart."""
    subclass = None
    superclass = None
    def __init__(self, AttributeClass=None):
        self.original_tagname_ = None
        if AttributeClass is None:
            self.AttributeClass = []
        else:
            self.AttributeClass = AttributeClass
    def factory(*args_, **kwargs_):
        if AttributeClassCollection.subclass:
            return AttributeClassCollection.subclass(*args_, **kwargs_)
        else:
            return AttributeClassCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClass(self): return self.AttributeClass
    def set_AttributeClass(self, AttributeClass): self.AttributeClass = AttributeClass
    def add_AttributeClass(self, value): self.AttributeClass.append(value)
    def insert_AttributeClass(self, index, value): self.AttributeClass[index] = value
    def hasContent_(self):
        if (
            self.AttributeClass
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeClassCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeClassCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeClassCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeClassCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeClassCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AttributeClass_ in self.AttributeClass:
            AttributeClass_.export(outfile, level, namespace_, name_='AttributeClass', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeClassCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AttributeClass=[\n')
        level += 1
        for AttributeClass_ in self.AttributeClass:
            showIndent(outfile, level)
            outfile.write('model_.AttributeClass(\n')
            AttributeClass_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttributeClass':
            obj_ = AttributeClass.factory()
            obj_.build(child_)
            self.AttributeClass.append(obj_)
            obj_.original_tagname_ = 'AttributeClass'
# end class AttributeClassCollection


class AttributeClassEntry(GeneratedsSuper):
    """Attribute class or attribute entry attached to a palette. An
    attribute class has no value. An attribute entry has a value
    associated with a defined attribute class, and is attached to a
    palette.Attribute class name of attribute entry attached to a
    palette. An attribute class has no value. An attribute entry has
    a value associated with a defined attribute class, and is
    attached to a palette.Attribute class IDREF of attribute entry
    attached to a palette. An attribute class has no value. An
    attribute entry has a value associated with a defined attribute
    class, and is attached to a palette.Value for this attribute
    class entry."""
    subclass = None
    superclass = None
    def __init__(self, AttributeClassReference=None, Value=None, AttributeClass=None):
        self.original_tagname_ = None
        self.AttributeClassReference = _cast(None, AttributeClassReference)
        self.Value = _cast(None, Value)
        self.AttributeClass = _cast(None, AttributeClass)
    def factory(*args_, **kwargs_):
        if AttributeClassEntry.subclass:
            return AttributeClassEntry.subclass(*args_, **kwargs_)
        else:
            return AttributeClassEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClassReference(self): return self.AttributeClassReference
    def set_AttributeClassReference(self, AttributeClassReference): self.AttributeClassReference = AttributeClassReference
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_AttributeClass(self): return self.AttributeClass
    def set_AttributeClass(self, AttributeClass): self.AttributeClass = AttributeClass
    def validate_AttributeValue(self, value):
        # Validate type AttributeValue, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeClassEntry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeClassEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeClassEntry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeClassEntry'):
        if self.AttributeClassReference is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            outfile.write(' AttributeClassReference=%s' % (self.gds_format_string(quote_attrib(self.AttributeClassReference).encode(ExternalEncoding), input_name='AttributeClassReference'), ))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(' Value=%s' % (quote_attrib(self.Value), ))
        if self.AttributeClass is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            outfile.write(' AttributeClass=%s' % (self.gds_format_string(quote_attrib(self.AttributeClass).encode(ExternalEncoding), input_name='AttributeClass'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeClassEntry', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AttributeClassEntry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AttributeClassReference is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            showIndent(outfile, level)
            outfile.write('AttributeClassReference="%s",\n' % (self.AttributeClassReference,))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % (self.Value,))
        if self.AttributeClass is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            showIndent(outfile, level)
            outfile.write('AttributeClass="%s",\n' % (self.AttributeClass,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AttributeClassReference', node)
        if value is not None and 'AttributeClassReference' not in already_processed:
            already_processed.add('AttributeClassReference')
            self.AttributeClassReference = value
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value
            self.validate_AttributeValue(self.Value)    # validate type AttributeValue
        value = find_attr_value_('AttributeClass', node)
        if value is not None and 'AttributeClass' not in already_processed:
            already_processed.add('AttributeClass')
            self.AttributeClass = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeClassEntry


class AttributeClassEntryCollection(GeneratedsSuper):
    """Collection of attribute classes on this palette."""
    subclass = None
    superclass = None
    def __init__(self, AttributeClassEntry=None):
        self.original_tagname_ = None
        if AttributeClassEntry is None:
            self.AttributeClassEntry = []
        else:
            self.AttributeClassEntry = AttributeClassEntry
    def factory(*args_, **kwargs_):
        if AttributeClassEntryCollection.subclass:
            return AttributeClassEntryCollection.subclass(*args_, **kwargs_)
        else:
            return AttributeClassEntryCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClassEntry(self): return self.AttributeClassEntry
    def set_AttributeClassEntry(self, AttributeClassEntry): self.AttributeClassEntry = AttributeClassEntry
    def add_AttributeClassEntry(self, value): self.AttributeClassEntry.append(value)
    def insert_AttributeClassEntry(self, index, value): self.AttributeClassEntry[index] = value
    def hasContent_(self):
        if (
            self.AttributeClassEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeClassEntryCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeClassEntryCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeClassEntryCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeClassEntryCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeClassEntryCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AttributeClassEntry_ in self.AttributeClassEntry:
            AttributeClassEntry_.export(outfile, level, namespace_, name_='AttributeClassEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeClassEntryCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AttributeClassEntry=[\n')
        level += 1
        for AttributeClassEntry_ in self.AttributeClassEntry:
            showIndent(outfile, level)
            outfile.write('model_.AttributeClassEntry(\n')
            AttributeClassEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttributeClassEntry':
            obj_ = AttributeClassEntry.factory()
            obj_.build(child_)
            self.AttributeClassEntry.append(obj_)
            obj_.original_tagname_ = 'AttributeClassEntry'
# end class AttributeClassEntryCollection


class AttributeCollection(GeneratedsSuper):
    """Collection of attribute instances on a chart item."""
    subclass = None
    superclass = None
    def __init__(self, Attribute=None):
        self.original_tagname_ = None
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if AttributeCollection.subclass:
            return AttributeCollection.subclass(*args_, **kwargs_)
        else:
            return AttributeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute(self, index, value): self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.Attribute(\n')
            Attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class AttributeCollection


class AttributeEntryCollection(GeneratedsSuper):
    """Collection of attribute entries on this palette."""
    subclass = None
    superclass = None
    def __init__(self, AttributeClassEntry=None):
        self.original_tagname_ = None
        if AttributeClassEntry is None:
            self.AttributeClassEntry = []
        else:
            self.AttributeClassEntry = AttributeClassEntry
    def factory(*args_, **kwargs_):
        if AttributeEntryCollection.subclass:
            return AttributeEntryCollection.subclass(*args_, **kwargs_)
        else:
            return AttributeEntryCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClassEntry(self): return self.AttributeClassEntry
    def set_AttributeClassEntry(self, AttributeClassEntry): self.AttributeClassEntry = AttributeClassEntry
    def add_AttributeClassEntry(self, value): self.AttributeClassEntry.append(value)
    def insert_AttributeClassEntry(self, index, value): self.AttributeClassEntry[index] = value
    def hasContent_(self):
        if (
            self.AttributeClassEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeEntryCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeEntryCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeEntryCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeEntryCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeEntryCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AttributeClassEntry_ in self.AttributeClassEntry:
            AttributeClassEntry_.export(outfile, level, namespace_, name_='AttributeClassEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeEntryCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AttributeClassEntry=[\n')
        level += 1
        for AttributeClassEntry_ in self.AttributeClassEntry:
            showIndent(outfile, level)
            outfile.write('model_.AttributeClassEntry(\n')
            AttributeClassEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttributeClassEntry':
            obj_ = AttributeClassEntry.factory()
            obj_.build(child_)
            self.AttributeClassEntry.append(obj_)
            obj_.original_tagname_ = 'AttributeClassEntry'
# end class AttributeEntryCollection


class Box(GeneratedsSuper):
    """A box chart item object. Part of the chart item inheritance
    hierarchy.Depth of the box, which allows the box to be treated
    as a 3 dimensional item. Expressed in world coordinates.Height
    of the item in world coordinates.X position of the label,
    relative to item position, in world coordinates.Y position of
    the label, relative to item position, in world coordinates.Width
    of the item in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, Width=100, Depth=0, TextY=1, TextX=2, Height=100, BoxStyle=None):
        self.original_tagname_ = None
        self.Width = _cast(int, Width)
        self.Depth = _cast(int, Depth)
        self.TextY = _cast(int, TextY)
        self.TextX = _cast(int, TextX)
        self.Height = _cast(int, Height)
        self.BoxStyle = BoxStyle
    def factory(*args_, **kwargs_):
        if Box.subclass:
            return Box.subclass(*args_, **kwargs_)
        else:
            return Box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BoxStyle(self): return self.BoxStyle
    def set_BoxStyle(self, BoxStyle): self.BoxStyle = BoxStyle
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def get_TextY(self): return self.TextY
    def set_TextY(self, TextY): self.TextY = TextY
    def get_TextX(self): return self.TextX
    def set_TextX(self, TextX): self.TextX = TextX
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def hasContent_(self):
        if (
            self.BoxStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Box', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Box')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Box', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Box'):
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            outfile.write(' Width="%s"' % self.gds_format_integer(self.Width, input_name='Width'))
        if self.Depth is not None and 'Depth' not in already_processed:
            already_processed.add('Depth')
            outfile.write(' Depth="%s"' % self.gds_format_integer(self.Depth, input_name='Depth'))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            outfile.write(' TextY="%s"' % self.gds_format_integer(self.TextY, input_name='TextY'))
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            outfile.write(' TextX="%s"' % self.gds_format_integer(self.TextX, input_name='TextX'))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            outfile.write(' Height="%s"' % self.gds_format_integer(self.Height, input_name='Height'))
    def exportChildren(self, outfile, level, namespace_='', name_='Box', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BoxStyle is not None:
            self.BoxStyle.export(outfile, level, namespace_, name_='BoxStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Box'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            showIndent(outfile, level)
            outfile.write('Width=%d,\n' % (self.Width,))
        if self.Depth is not None and 'Depth' not in already_processed:
            already_processed.add('Depth')
            showIndent(outfile, level)
            outfile.write('Depth=%d,\n' % (self.Depth,))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            showIndent(outfile, level)
            outfile.write('TextY=%d,\n' % (self.TextY,))
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            showIndent(outfile, level)
            outfile.write('TextX=%d,\n' % (self.TextX,))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            showIndent(outfile, level)
            outfile.write('Height=%d,\n' % (self.Height,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BoxStyle is not None:
            showIndent(outfile, level)
            outfile.write('BoxStyle=model_.BoxStyle(\n')
            self.BoxStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Depth', node)
        if value is not None and 'Depth' not in already_processed:
            already_processed.add('Depth')
            try:
                self.Depth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TextY', node)
        if value is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            try:
                self.TextY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TextX', node)
        if value is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            try:
                self.TextX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BoxStyle':
            obj_ = BoxStyle.factory()
            obj_.build(child_)
            self.BoxStyle = obj_
            obj_.original_tagname_ = 'BoxStyle'
# end class Box


class BoxStyle(GeneratedsSuper):
    """Style of the box chart item. Part of the LNCIStyle inheritance
    hierarchy.Color used to fill the chart item when Filled is
    True.Type IDREF of entity used by this style. An entity type is
    a category of entity.If True, the chart item is filled. Control
    the fill color using the BackColour property.Signifies whether
    the item is a solid colour, transparent or contains a gradient-
    fill.Width of the line used to draw the chart item.Color of the
    line used to draw the chart item.Strength associated with the
    entity, which controls the item border appearance.Strength IDREF
    associated with the entity, which controls the item border
    appearance.Type of entity used by this style. An entity type is
    a category of entity."""
    subclass = None
    superclass = None
    def __init__(self, Strength=None, StrengthReference=None, EntityTypeReference=None, FillStyle=None, LineColour=None, BackColour=None, LineWidth=None, Type=None, Filled=None):
        self.original_tagname_ = None
        self.Strength = _cast(None, Strength)
        self.StrengthReference = _cast(None, StrengthReference)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.FillStyle = _cast(None, FillStyle)
        self.LineColour = _cast(int, LineColour)
        self.BackColour = _cast(int, BackColour)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
        self.Filled = _cast(bool, Filled)
    def factory(*args_, **kwargs_):
        if BoxStyle.subclass:
            return BoxStyle.subclass(*args_, **kwargs_)
        else:
            return BoxStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_FillStyle(self): return self.FillStyle
    def set_FillStyle(self, FillStyle): self.FillStyle = FillStyle
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Filled(self): return self.Filled
    def set_Filled(self, Filled): self.Filled = Filled
    def validate_FillStyleEnum(self, value):
        # Validate type FillStyleEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoxStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoxStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoxStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoxStyle'):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            outfile.write(' FillStyle=%s' % (quote_attrib(self.FillStyle), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            outfile.write(' Filled="%s"' % self.gds_format_boolean(self.Filled, input_name='Filled'))
    def exportChildren(self, outfile, level, namespace_='', name_='BoxStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BoxStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            showIndent(outfile, level)
            outfile.write('FillStyle="%s",\n' % (self.FillStyle,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            showIndent(outfile, level)
            outfile.write('Filled=%s,\n' % (self.Filled,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('FillStyle', node)
        if value is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            self.FillStyle = value
            self.validate_FillStyleEnum(self.FillStyle)    # validate type FillStyleEnum
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Filled', node)
        if value is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            if value in ('true', '1'):
                self.Filled = True
            elif value in ('false', '0'):
                self.Filled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoxStyle


class Card(GeneratedsSuper):
    """Card object, which can be a card on any entity or link. Every entity
    and link can have multiple card objects associated with it.If
    True, a calendar date is associated with the card. Use DateTime
    to specify the date.Actual Date value associated with the card,
    where the value is represented in UTC. The DateSet and/or
    TimeSet property must be set to True before the value is applied
    to the card.A string description of the date and time, for
    example ‘About 3pm’.Index into the card's grade one in the
    chart's grading system.IDREF for the card's grade one in the
    chart's grading system.Index into the card's grade three in the
    chart's grading system.IDREF for the card's grade three in the
    chart's grading system.Index into the card's grade two in the
    chart's grading system.IDREF for the card's grade two in the
    chart's grading system.Offset from UTC of the chart item's local
    date and time.Source reference for the card, which indicates the
    source of material in card text, e.g. Document Number.Source
    type for the card, e.g. Witness, Informant etc.Summary text on
    the card.Main text of the card.If True, a time is associated
    with the card. Use DateTime to specify the time value."""
    subclass = None
    superclass = None
    def __init__(self, LocalDateTimeOffset=None, TimeSet=False, DateSet=False, GradeOneIndex=0, GradeTwoReference=None, Text=None, GradeTwoIndex=0, GradeThreeReference=None, DateTime=None, DateTimeDescription=None, SourceReference=None, SourceType=None, GradeThreeIndex=0, Summary=None, GradeOneReference=None, TimeZone=None):
        self.original_tagname_ = None
        self.LocalDateTimeOffset = _cast(int, LocalDateTimeOffset)
        self.TimeSet = _cast(bool, TimeSet)
        self.DateSet = _cast(bool, DateSet)
        self.GradeOneIndex = _cast(int, GradeOneIndex)
        self.GradeTwoReference = _cast(None, GradeTwoReference)
        self.Text = _cast(None, Text)
        self.GradeTwoIndex = _cast(int, GradeTwoIndex)
        self.GradeThreeReference = _cast(None, GradeThreeReference)
        if isinstance(DateTime, str):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
        self.DateTimeDescription = _cast(None, DateTimeDescription)
        self.SourceReference = _cast(None, SourceReference)
        self.SourceType = _cast(None, SourceType)
        self.GradeThreeIndex = _cast(int, GradeThreeIndex)
        self.Summary = _cast(None, Summary)
        self.GradeOneReference = _cast(None, GradeOneReference)
        self.TimeZone = TimeZone
    def factory(*args_, **kwargs_):
        if Card.subclass:
            return Card.subclass(*args_, **kwargs_)
        else:
            return Card(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeZone(self): return self.TimeZone
    def set_TimeZone(self, TimeZone): self.TimeZone = TimeZone
    def get_LocalDateTimeOffset(self): return self.LocalDateTimeOffset
    def set_LocalDateTimeOffset(self, LocalDateTimeOffset): self.LocalDateTimeOffset = LocalDateTimeOffset
    def get_TimeSet(self): return self.TimeSet
    def set_TimeSet(self, TimeSet): self.TimeSet = TimeSet
    def get_DateSet(self): return self.DateSet
    def set_DateSet(self, DateSet): self.DateSet = DateSet
    def get_GradeOneIndex(self): return self.GradeOneIndex
    def set_GradeOneIndex(self, GradeOneIndex): self.GradeOneIndex = GradeOneIndex
    def get_GradeTwoReference(self): return self.GradeTwoReference
    def set_GradeTwoReference(self, GradeTwoReference): self.GradeTwoReference = GradeTwoReference
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_GradeTwoIndex(self): return self.GradeTwoIndex
    def set_GradeTwoIndex(self, GradeTwoIndex): self.GradeTwoIndex = GradeTwoIndex
    def get_GradeThreeReference(self): return self.GradeThreeReference
    def set_GradeThreeReference(self, GradeThreeReference): self.GradeThreeReference = GradeThreeReference
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_DateTimeDescription(self): return self.DateTimeDescription
    def set_DateTimeDescription(self, DateTimeDescription): self.DateTimeDescription = DateTimeDescription
    def get_SourceReference(self): return self.SourceReference
    def set_SourceReference(self, SourceReference): self.SourceReference = SourceReference
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_GradeThreeIndex(self): return self.GradeThreeIndex
    def set_GradeThreeIndex(self, GradeThreeIndex): self.GradeThreeIndex = GradeThreeIndex
    def get_Summary(self): return self.Summary
    def set_Summary(self, Summary): self.Summary = Summary
    def get_GradeOneReference(self): return self.GradeOneReference
    def set_GradeOneReference(self, GradeOneReference): self.GradeOneReference = GradeOneReference
    def hasContent_(self):
        if (
            self.TimeZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Card', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Card')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Card', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Card'):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            outfile.write(' LocalDateTimeOffset="%s"' % self.gds_format_integer(self.LocalDateTimeOffset, input_name='LocalDateTimeOffset'))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            outfile.write(' TimeSet="%s"' % self.gds_format_boolean(self.TimeSet, input_name='TimeSet'))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            outfile.write(' DateSet="%s"' % self.gds_format_boolean(self.DateSet, input_name='DateSet'))
        if self.GradeOneIndex is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            outfile.write(' GradeOneIndex="%s"' % self.gds_format_integer(self.GradeOneIndex, input_name='GradeOneIndex'))
        if self.GradeTwoReference is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            outfile.write(' GradeTwoReference=%s' % (self.gds_format_string(quote_attrib(self.GradeTwoReference).encode(ExternalEncoding), input_name='GradeTwoReference'), ))
        if self.Text is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            outfile.write(' Text=%s' % (self.gds_format_string(quote_attrib(self.Text).encode(ExternalEncoding), input_name='Text'), ))
        if self.GradeTwoIndex is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            outfile.write(' GradeTwoIndex="%s"' % self.gds_format_integer(self.GradeTwoIndex, input_name='GradeTwoIndex'))
        if self.GradeThreeReference is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            outfile.write(' GradeThreeReference=%s' % (self.gds_format_string(quote_attrib(self.GradeThreeReference).encode(ExternalEncoding), input_name='GradeThreeReference'), ))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            outfile.write(' DateTime="%s"' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.DateTimeDescription is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            outfile.write(' DateTimeDescription=%s' % (self.gds_format_string(quote_attrib(self.DateTimeDescription).encode(ExternalEncoding), input_name='DateTimeDescription'), ))
        if self.SourceReference is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            outfile.write(' SourceReference=%s' % (self.gds_format_string(quote_attrib(self.SourceReference).encode(ExternalEncoding), input_name='SourceReference'), ))
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            outfile.write(' SourceType=%s' % (self.gds_format_string(quote_attrib(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), ))
        if self.GradeThreeIndex is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            outfile.write(' GradeThreeIndex="%s"' % self.gds_format_integer(self.GradeThreeIndex, input_name='GradeThreeIndex'))
        if self.Summary is not None and 'Summary' not in already_processed:
            already_processed.add('Summary')
            outfile.write(' Summary=%s' % (self.gds_format_string(quote_attrib(self.Summary).encode(ExternalEncoding), input_name='Summary'), ))
        if self.GradeOneReference is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            outfile.write(' GradeOneReference=%s' % (self.gds_format_string(quote_attrib(self.GradeOneReference).encode(ExternalEncoding), input_name='GradeOneReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Card', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeZone is not None:
            self.TimeZone.export(outfile, level, namespace_, name_='TimeZone', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Card'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            showIndent(outfile, level)
            outfile.write('LocalDateTimeOffset=%d,\n' % (self.LocalDateTimeOffset,))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            showIndent(outfile, level)
            outfile.write('TimeSet=%s,\n' % (self.TimeSet,))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            showIndent(outfile, level)
            outfile.write('DateSet=%s,\n' % (self.DateSet,))
        if self.GradeOneIndex is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            showIndent(outfile, level)
            outfile.write('GradeOneIndex=%d,\n' % (self.GradeOneIndex,))
        if self.GradeTwoReference is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            showIndent(outfile, level)
            outfile.write('GradeTwoReference="%s",\n' % (self.GradeTwoReference,))
        if self.Text is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            showIndent(outfile, level)
            outfile.write('Text="%s",\n' % (self.Text,))
        if self.GradeTwoIndex is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            showIndent(outfile, level)
            outfile.write('GradeTwoIndex=%d,\n' % (self.GradeTwoIndex,))
        if self.GradeThreeReference is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            showIndent(outfile, level)
            outfile.write('GradeThreeReference="%s",\n' % (self.GradeThreeReference,))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            showIndent(outfile, level)
            outfile.write('DateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.DateTimeDescription is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            showIndent(outfile, level)
            outfile.write('DateTimeDescription="%s",\n' % (self.DateTimeDescription,))
        if self.SourceReference is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            showIndent(outfile, level)
            outfile.write('SourceReference="%s",\n' % (self.SourceReference,))
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            showIndent(outfile, level)
            outfile.write('SourceType="%s",\n' % (self.SourceType,))
        if self.GradeThreeIndex is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            showIndent(outfile, level)
            outfile.write('GradeThreeIndex=%d,\n' % (self.GradeThreeIndex,))
        if self.Summary is not None and 'Summary' not in already_processed:
            already_processed.add('Summary')
            showIndent(outfile, level)
            outfile.write('Summary="%s",\n' % (self.Summary,))
        if self.GradeOneReference is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            showIndent(outfile, level)
            outfile.write('GradeOneReference="%s",\n' % (self.GradeOneReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeZone is not None:
            showIndent(outfile, level)
            outfile.write('TimeZone=model_.TimeZone(\n')
            self.TimeZone.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LocalDateTimeOffset', node)
        if value is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            try:
                self.LocalDateTimeOffset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TimeSet', node)
        if value is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            if value in ('true', '1'):
                self.TimeSet = True
            elif value in ('false', '0'):
                self.TimeSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateSet', node)
        if value is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            if value in ('true', '1'):
                self.DateSet = True
            elif value in ('false', '0'):
                self.DateSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('GradeOneIndex', node)
        if value is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            try:
                self.GradeOneIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GradeTwoReference', node)
        if value is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            self.GradeTwoReference = value
        value = find_attr_value_('Text', node)
        if value is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            self.Text = value
        value = find_attr_value_('GradeTwoIndex', node)
        if value is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            try:
                self.GradeTwoIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GradeThreeReference', node)
        if value is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            self.GradeThreeReference = value
        value = find_attr_value_('DateTime', node)
        if value is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            try:
                self.DateTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DateTime): %s' % exp)
        value = find_attr_value_('DateTimeDescription', node)
        if value is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            self.DateTimeDescription = value
        value = find_attr_value_('SourceReference', node)
        if value is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            self.SourceReference = value
        value = find_attr_value_('SourceType', node)
        if value is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            self.SourceType = value
        value = find_attr_value_('GradeThreeIndex', node)
        if value is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            try:
                self.GradeThreeIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Summary', node)
        if value is not None and 'Summary' not in already_processed:
            already_processed.add('Summary')
            self.Summary = value
        value = find_attr_value_('GradeOneReference', node)
        if value is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            self.GradeOneReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeZone':
            obj_ = TimeZone.factory()
            obj_.build(child_)
            self.TimeZone = obj_
            obj_.original_tagname_ = 'TimeZone'
# end class Card


class CardCollection(GeneratedsSuper):
    """Collection of cards on an entity or link."""
    subclass = None
    superclass = None
    def __init__(self, Card=None):
        self.original_tagname_ = None
        if Card is None:
            self.Card = []
        else:
            self.Card = Card
    def factory(*args_, **kwargs_):
        if CardCollection.subclass:
            return CardCollection.subclass(*args_, **kwargs_)
        else:
            return CardCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Card(self): return self.Card
    def set_Card(self, Card): self.Card = Card
    def add_Card(self, value): self.Card.append(value)
    def insert_Card(self, index, value): self.Card[index] = value
    def hasContent_(self):
        if (
            self.Card
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CardCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CardCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CardCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CardCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CardCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Card_ in self.Card:
            Card_.export(outfile, level, namespace_, name_='Card', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CardCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Card=[\n')
        level += 1
        for Card_ in self.Card:
            showIndent(outfile, level)
            outfile.write('model_.Card(\n')
            Card_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Card':
            obj_ = Card.factory()
            obj_.build(child_)
            self.Card.append(obj_)
            obj_.original_tagname_ = 'Card'
# end class CardCollection


class CustomImageCollection(GeneratedsSuper):
    """Collection of custom images saved in property bags."""
    subclass = None
    superclass = None
    def __init__(self, CustomImage=None):
        self.original_tagname_ = None
        if CustomImage is None:
            self.CustomImage = []
        else:
            self.CustomImage = CustomImage
    def factory(*args_, **kwargs_):
        if CustomImageCollection.subclass:
            return CustomImageCollection.subclass(*args_, **kwargs_)
        else:
            return CustomImageCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomImage(self): return self.CustomImage
    def set_CustomImage(self, CustomImage): self.CustomImage = CustomImage
    def add_CustomImage(self, value): self.CustomImage.append(value)
    def insert_CustomImage(self, index, value): self.CustomImage[index] = value
    def hasContent_(self):
        if (
            self.CustomImage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomImageCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomImageCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomImageCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomImageCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomImageCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomImage_ in self.CustomImage:
            CustomImage_.export(outfile, level, namespace_, name_='CustomImage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomImageCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustomImage=[\n')
        level += 1
        for CustomImage_ in self.CustomImage:
            showIndent(outfile, level)
            outfile.write('model_.CustomImage(\n')
            CustomImage_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomImage':
            obj_ = CustomImage.factory()
            obj_.build(child_)
            self.CustomImage.append(obj_)
            obj_.original_tagname_ = 'CustomImage'
# end class CustomImageCollection


class CustomImage(GeneratedsSuper):
    """Custom imageId of the custom imageData length of the custom
    imageGUID identifying the base64 data in this element.Data of
    the custom image"""
    subclass = None
    superclass = None
    def __init__(self, Data=None, Id=None, DataLength=None, DataGuid=None):
        self.original_tagname_ = None
        self.Data = _cast(None, Data)
        self.Id = _cast(None, Id)
        self.DataLength = _cast(int, DataLength)
        self.DataGuid = _cast(None, DataGuid)
    def factory(*args_, **kwargs_):
        if CustomImage.subclass:
            return CustomImage.subclass(*args_, **kwargs_)
        else:
            return CustomImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_DataLength(self): return self.DataLength
    def set_DataLength(self, DataLength): self.DataLength = DataLength
    def get_DataGuid(self): return self.DataGuid
    def set_DataGuid(self, DataGuid): self.DataGuid = DataGuid
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomImage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomImage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomImage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomImage'):
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            outfile.write(' Data=%s' % (quote_attrib(self.Data), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            outfile.write(' DataLength="%s"' % self.gds_format_integer(self.DataLength, input_name='DataLength'))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            outfile.write(' DataGuid=%s' % (self.gds_format_string(quote_attrib(self.DataGuid).encode(ExternalEncoding), input_name='DataGuid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomImage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CustomImage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % (self.Data,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            showIndent(outfile, level)
            outfile.write('DataLength=%d,\n' % (self.DataLength,))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            showIndent(outfile, level)
            outfile.write('DataGuid="%s",\n' % (self.DataGuid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Data', node)
        if value is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            self.Data = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('DataLength', node)
        if value is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            try:
                self.DataLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('DataGuid', node)
        if value is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            self.DataGuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CustomImage


class PropertyBagCollection(GeneratedsSuper):
    """Collection of property bags"""
    subclass = None
    superclass = None
    def __init__(self, PropertyBag=None):
        self.original_tagname_ = None
        if PropertyBag is None:
            self.PropertyBag = []
        else:
            self.PropertyBag = PropertyBag
    def factory(*args_, **kwargs_):
        if PropertyBagCollection.subclass:
            return PropertyBagCollection.subclass(*args_, **kwargs_)
        else:
            return PropertyBagCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyBag(self): return self.PropertyBag
    def set_PropertyBag(self, PropertyBag): self.PropertyBag = PropertyBag
    def add_PropertyBag(self, value): self.PropertyBag.append(value)
    def insert_PropertyBag(self, index, value): self.PropertyBag[index] = value
    def hasContent_(self):
        if (
            self.PropertyBag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyBagCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyBagCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyBagCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyBagCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyBagCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PropertyBag_ in self.PropertyBag:
            PropertyBag_.export(outfile, level, namespace_, name_='PropertyBag', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyBagCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PropertyBag=[\n')
        level += 1
        for PropertyBag_ in self.PropertyBag:
            showIndent(outfile, level)
            outfile.write('model_.PropertyBag(\n')
            PropertyBag_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyBag':
            obj_ = PropertyBag.factory()
            obj_.build(child_)
            self.PropertyBag.append(obj_)
            obj_.original_tagname_ = 'PropertyBag'
# end class PropertyBagCollection


class PropertyBag(GeneratedsSuper):
    """Property bagGeneric PropertyBag GUID"""
    subclass = None
    superclass = None
    def __init__(self, GuidID=None, PropertyBagProperty=None):
        self.original_tagname_ = None
        self.GuidID = _cast(None, GuidID)
        if PropertyBagProperty is None:
            self.PropertyBagProperty = []
        else:
            self.PropertyBagProperty = PropertyBagProperty
    def factory(*args_, **kwargs_):
        if PropertyBag.subclass:
            return PropertyBag.subclass(*args_, **kwargs_)
        else:
            return PropertyBag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyBagProperty(self): return self.PropertyBagProperty
    def set_PropertyBagProperty(self, PropertyBagProperty): self.PropertyBagProperty = PropertyBagProperty
    def add_PropertyBagProperty(self, value): self.PropertyBagProperty.append(value)
    def insert_PropertyBagProperty(self, index, value): self.PropertyBagProperty[index] = value
    def get_GuidID(self): return self.GuidID
    def set_GuidID(self, GuidID): self.GuidID = GuidID
    def hasContent_(self):
        if (
            self.PropertyBagProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyBag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyBag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyBag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyBag'):
        if self.GuidID is not None and 'GuidID' not in already_processed:
            already_processed.add('GuidID')
            outfile.write(' GuidID=%s' % (self.gds_format_string(quote_attrib(self.GuidID).encode(ExternalEncoding), input_name='GuidID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyBag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PropertyBagProperty_ in self.PropertyBagProperty:
            PropertyBagProperty_.export(outfile, level, namespace_, name_='PropertyBagProperty', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyBag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GuidID is not None and 'GuidID' not in already_processed:
            already_processed.add('GuidID')
            showIndent(outfile, level)
            outfile.write('GuidID="%s",\n' % (self.GuidID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PropertyBagProperty=[\n')
        level += 1
        for PropertyBagProperty_ in self.PropertyBagProperty:
            showIndent(outfile, level)
            outfile.write('model_.PropertyBagProperty(\n')
            PropertyBagProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('GuidID', node)
        if value is not None and 'GuidID' not in already_processed:
            already_processed.add('GuidID')
            self.GuidID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyBagProperty':
            obj_ = PropertyBagProperty.factory()
            obj_.build(child_)
            self.PropertyBagProperty.append(obj_)
            obj_.original_tagname_ = 'PropertyBagProperty'
# end class PropertyBag


class PropertyBagProperty(GeneratedsSuper):
    """Binary data for generic propertybagsPropertyBag property
    namePropertyBag DataTypeTrue, if the value is an object that
    implements the IDispatch interface.The uncompressed length, in
    bytes, of the property data, if it is not a simple type.GUID
    identifying the base64 data in this element.The Property data.
    If the property is not a simple type, the data is in base 64
    encoded string"""
    subclass = None
    superclass = None
    def __init__(self, DataType=None, PropertyName=None, DataGuid=None, DataLength=None, Data=None, ValueIsIDispatch=None):
        self.original_tagname_ = None
        self.DataType = _cast(None, DataType)
        self.PropertyName = _cast(None, PropertyName)
        self.DataGuid = _cast(None, DataGuid)
        self.DataLength = _cast(int, DataLength)
        self.Data = _cast(None, Data)
        self.ValueIsIDispatch = _cast(bool, ValueIsIDispatch)
    def factory(*args_, **kwargs_):
        if PropertyBagProperty.subclass:
            return PropertyBagProperty.subclass(*args_, **kwargs_)
        else:
            return PropertyBagProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def get_PropertyName(self): return self.PropertyName
    def set_PropertyName(self, PropertyName): self.PropertyName = PropertyName
    def get_DataGuid(self): return self.DataGuid
    def set_DataGuid(self, DataGuid): self.DataGuid = DataGuid
    def get_DataLength(self): return self.DataLength
    def set_DataLength(self, DataLength): self.DataLength = DataLength
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_ValueIsIDispatch(self): return self.ValueIsIDispatch
    def set_ValueIsIDispatch(self, ValueIsIDispatch): self.ValueIsIDispatch = ValueIsIDispatch
    def validate_PropertyBagDataType(self, value):
        # Validate type PropertyBagDataType, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyBagProperty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyBagProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyBagProperty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyBagProperty'):
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            outfile.write(' DataType=%s' % (quote_attrib(self.DataType), ))
        if self.PropertyName is not None and 'PropertyName' not in already_processed:
            already_processed.add('PropertyName')
            outfile.write(' PropertyName=%s' % (self.gds_format_string(quote_attrib(self.PropertyName).encode(ExternalEncoding), input_name='PropertyName'), ))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            outfile.write(' DataGuid=%s' % (self.gds_format_string(quote_attrib(self.DataGuid).encode(ExternalEncoding), input_name='DataGuid'), ))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            outfile.write(' DataLength="%s"' % self.gds_format_integer(self.DataLength, input_name='DataLength'))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            outfile.write(' Data=%s' % (self.gds_format_string(quote_attrib(self.Data).encode(ExternalEncoding), input_name='Data'), ))
        if self.ValueIsIDispatch is not None and 'ValueIsIDispatch' not in already_processed:
            already_processed.add('ValueIsIDispatch')
            outfile.write(' ValueIsIDispatch="%s"' % self.gds_format_boolean(self.ValueIsIDispatch, input_name='ValueIsIDispatch'))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyBagProperty', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PropertyBagProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            showIndent(outfile, level)
            outfile.write('DataType="%s",\n' % (self.DataType,))
        if self.PropertyName is not None and 'PropertyName' not in already_processed:
            already_processed.add('PropertyName')
            showIndent(outfile, level)
            outfile.write('PropertyName="%s",\n' % (self.PropertyName,))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            showIndent(outfile, level)
            outfile.write('DataGuid="%s",\n' % (self.DataGuid,))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            showIndent(outfile, level)
            outfile.write('DataLength=%d,\n' % (self.DataLength,))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            showIndent(outfile, level)
            outfile.write('Data="%s",\n' % (self.Data,))
        if self.ValueIsIDispatch is not None and 'ValueIsIDispatch' not in already_processed:
            already_processed.add('ValueIsIDispatch')
            showIndent(outfile, level)
            outfile.write('ValueIsIDispatch=%s,\n' % (self.ValueIsIDispatch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataType', node)
        if value is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            self.DataType = value
            self.validate_PropertyBagDataType(self.DataType)    # validate type PropertyBagDataType
        value = find_attr_value_('PropertyName', node)
        if value is not None and 'PropertyName' not in already_processed:
            already_processed.add('PropertyName')
            self.PropertyName = value
        value = find_attr_value_('DataGuid', node)
        if value is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            self.DataGuid = value
        value = find_attr_value_('DataLength', node)
        if value is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            try:
                self.DataLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Data', node)
        if value is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            self.Data = value
        value = find_attr_value_('ValueIsIDispatch', node)
        if value is not None and 'ValueIsIDispatch' not in already_processed:
            already_processed.add('ValueIsIDispatch')
            if value in ('true', '1'):
                self.ValueIsIDispatch = True
            elif value in ('false', '0'):
                self.ValueIsIDispatch = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyBagProperty


class Chart(GeneratedsSuper):
    """The chart object, which contains the chart data.The version number
    of the schema.The supported version of MSXML for XML parsing,
    validation and transformation.Background color of the chart.If
    True, links are created with blank labels when the
    LNViewport.CurrentMode is in link mode.Default date used when
    creating a date & time attribute class type.Date and time at X =
    0 when there are no controlling items on this chart. Expressed
    in UTC.Default space between newly created links, expressed in
    Inches.Tick rate for the time bar, expressed in units of
    (Days/Inch), where an Inch is 80 world coordinate points. This
    setting is ignored between controlling items on the chart.Grid
    spacing in the vertical direction, expressed in Inches.If True,
    the end user can see the grid on all views, provided that
    LNChart.SnapToGrid and LNGraphicViewport.GridShown are set to
    True.Grid spacing in the horizontal direction, expressed in
    Inches.If True, the time zone text is hidden for items that are
    in the same time zone as the chart.If True, ID and IDREF
    attributes must be valid. For example, each AttributeClass
    element must have valid contents for its Id attribute.True if a
    colour has been picked, false for TransparentRule for handling
    labels on chart items during merge and paste operations.If True,
    numeric content in link labels is added when merging and pasting
    links.If True, the XML is considered to obey the normal chart
    rules. For example, entity identities must be unique. If False,
    the XML Importer will attempt to merge duplicate chart items.If
    True, hidden chart items are shown, which has the same effect as
    the Reveal Hidden menu command.Determines how chart items marked
    as "not shown" actually appear on this chart: hidden, grayed
    out, or fully visible.If True, show page boundaries on the
    chart, which indicate how the chart will appear when printed.If
    True, items that are dragged or added to the chart by the end
    user automatically snap to the grid. Items moved or added to the
    chart through the API must be manually aligned with the grid,
    and are not affected by this setting.If True, the time bar is
    displayed in this viewport.Determines whether this chart uses
    legacy or new (high-quality) icons for displaying chart itemsIf
    True, links will snap to increments of the DefaultLinkSpacing
    when Shift + Alt dragging.If True, the chart uses the local time
    zone interpreted from the computer's regional settings. If
    False, use the TimeZone property to set the time zone for the
    chart.If True, WiringHeight also applies to the separation
    between the theme line and the theme line icon.X distance over
    which a theme line diverts from the theme line's current height
    to the event frame's wiring height. Expressed in Inches.X
    distance from an event frame where the theme line height reaches
    the event frame's wiring height. Expressed in Inches.Y distance
    from the center of an event frame pin to where the theme line
    intersects the event frame. Setting ignored if link area of
    event frame is visible. Expressed in Inches.Vertical separation
    between the theme lines when there is more than one theme line
    going through a single event frame. Separation is maintained if
    a theme line width is modified. Setting ignored if link area of
    event frame is visible. Expressed in Inches.Prompt with cover
    sheet when opening the chart."""
    subclass = None
    superclass = None
    def __init__(self, GridHeightSize=0.295275590551181, UseDefaultLinkSpacingWhenDragging=False, GridVisibleOnAllViews=True, ShowAllFlag=False, ShowPages=False, BackColour=16777215, DefaultLinkSpacing=0.295275590551181, WiringDistanceNear=0.078740157480315, UseWiringHeightForThemeIcon=True, DefaultTickRate=1, DefaultDateTimeForNewChart=None, WiringHeight=0.196850393700787, HiddenItemsVisibility='ItemsVisibilityHidden', GridWidthSize=0.295275590551181, HideMatchingTimeZoneFormat=False, DefaultDate=None, TimeBarVisible=False, WiringSpacing=0.196850393700787, BlankLinkLabels=False, UseLocalTimeZone=True, TypeIconDrawingMode='HighQuality', WiringDistanceFar=0.393700787401575, IdReferenceLinking=True, IsBackColourFilled=True, SnapToGrid=False, LabelSumNumericLinks=False, LabelRule='LabelRuleMerge', Rigorous=True, MsxmlVersion='4.20.9818.0', SchemaVersion='7.0.0.1', CoverSheetShowOnOpen=None, ApplicationVersion=None, LibraryCatalogue=None, PropertyBagCollection=None, CustomImageCollection=None, GradeOne=None, GradeTwo=None, GradeThree=None, SourceHints=None, StrengthCollection=None, AttributeClassCollection=None, EntityTypeCollection=None, LinkTypeCollection=None, Font=None, DatabaseProxyCollection=None, DateTimeFormatCollection=None, CurrentStyleCollection=None, TimeZone=None, TimeBar=None, PrintSettings=None, Summary=None, ChartItemCollection=None, ConnectionCollection=None, JunctionCollection=None, GroupCollection=None, PaletteCollection=None, PaletteBarCollection=None, LegendDefinition=None, SnapshotCollection=None):
        self.original_tagname_ = None
        self.GridHeightSize = _cast(float, GridHeightSize)
        self.UseDefaultLinkSpacingWhenDragging = _cast(bool, UseDefaultLinkSpacingWhenDragging)
        self.GridVisibleOnAllViews = _cast(bool, GridVisibleOnAllViews)
        self.ShowAllFlag = _cast(bool, ShowAllFlag)
        self.ShowPages = _cast(bool, ShowPages)
        self.BackColour = _cast(int, BackColour)
        self.DefaultLinkSpacing = _cast(float, DefaultLinkSpacing)
        self.WiringDistanceNear = _cast(float, WiringDistanceNear)
        self.UseWiringHeightForThemeIcon = _cast(bool, UseWiringHeightForThemeIcon)
        self.DefaultTickRate = _cast(float, DefaultTickRate)
        if isinstance(DefaultDateTimeForNewChart, str):
            initvalue_ = datetime_.datetime.strptime(DefaultDateTimeForNewChart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DefaultDateTimeForNewChart
        self.DefaultDateTimeForNewChart = initvalue_
        self.WiringHeight = _cast(float, WiringHeight)
        self.HiddenItemsVisibility = _cast(None, HiddenItemsVisibility)
        self.GridWidthSize = _cast(float, GridWidthSize)
        self.HideMatchingTimeZoneFormat = _cast(bool, HideMatchingTimeZoneFormat)
        if isinstance(DefaultDate, str):
            initvalue_ = datetime_.datetime.strptime(DefaultDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DefaultDate
        self.DefaultDate = initvalue_
        self.TimeBarVisible = _cast(bool, TimeBarVisible)
        self.WiringSpacing = _cast(float, WiringSpacing)
        self.BlankLinkLabels = _cast(bool, BlankLinkLabels)
        self.UseLocalTimeZone = _cast(bool, UseLocalTimeZone)
        self.TypeIconDrawingMode = _cast(None, TypeIconDrawingMode)
        self.WiringDistanceFar = _cast(float, WiringDistanceFar)
        self.IdReferenceLinking = _cast(bool, IdReferenceLinking)
        self.IsBackColourFilled = _cast(bool, IsBackColourFilled)
        self.SnapToGrid = _cast(bool, SnapToGrid)
        self.LabelSumNumericLinks = _cast(bool, LabelSumNumericLinks)
        self.LabelRule = _cast(None, LabelRule)
        self.Rigorous = _cast(bool, Rigorous)
        self.MsxmlVersion = _cast(None, MsxmlVersion)
        self.SchemaVersion = _cast(None, SchemaVersion)
        self.CoverSheetShowOnOpen = _cast(bool, CoverSheetShowOnOpen)
        if ApplicationVersion is None:
            self.ApplicationVersion = []
        else:
            self.ApplicationVersion = ApplicationVersion
        if LibraryCatalogue is None:
            self.LibraryCatalogue = []
        else:
            self.LibraryCatalogue = LibraryCatalogue
        if PropertyBagCollection is None:
            self.PropertyBagCollection = []
        else:
            self.PropertyBagCollection = PropertyBagCollection
        if CustomImageCollection is None:
            self.CustomImageCollection = []
        else:
            self.CustomImageCollection = CustomImageCollection
        if GradeOne is None:
            self.GradeOne = []
        else:
            self.GradeOne = GradeOne
        if GradeTwo is None:
            self.GradeTwo = []
        else:
            self.GradeTwo = GradeTwo
        if GradeThree is None:
            self.GradeThree = []
        else:
            self.GradeThree = GradeThree
        if SourceHints is None:
            self.SourceHints = []
        else:
            self.SourceHints = SourceHints
        if StrengthCollection is None:
            self.StrengthCollection = []
        else:
            self.StrengthCollection = StrengthCollection
        if AttributeClassCollection is None:
            self.AttributeClassCollection = []
        else:
            self.AttributeClassCollection = AttributeClassCollection
        if EntityTypeCollection is None:
            self.EntityTypeCollection = []
        else:
            self.EntityTypeCollection = EntityTypeCollection
        if LinkTypeCollection is None:
            self.LinkTypeCollection = []
        else:
            self.LinkTypeCollection = LinkTypeCollection
        if Font is None:
            self.Font = []
        else:
            self.Font = Font
        if DatabaseProxyCollection is None:
            self.DatabaseProxyCollection = []
        else:
            self.DatabaseProxyCollection = DatabaseProxyCollection
        if DateTimeFormatCollection is None:
            self.DateTimeFormatCollection = []
        else:
            self.DateTimeFormatCollection = DateTimeFormatCollection
        if CurrentStyleCollection is None:
            self.CurrentStyleCollection = []
        else:
            self.CurrentStyleCollection = CurrentStyleCollection
        if TimeZone is None:
            self.TimeZone = []
        else:
            self.TimeZone = TimeZone
        if TimeBar is None:
            self.TimeBar = []
        else:
            self.TimeBar = TimeBar
        if PrintSettings is None:
            self.PrintSettings = []
        else:
            self.PrintSettings = PrintSettings
        if Summary is None:
            self.Summary = []
        else:
            self.Summary = Summary
        if ChartItemCollection is None:
            self.ChartItemCollection = []
        else:
            self.ChartItemCollection = ChartItemCollection
        if ConnectionCollection is None:
            self.ConnectionCollection = []
        else:
            self.ConnectionCollection = ConnectionCollection
        if JunctionCollection is None:
            self.JunctionCollection = []
        else:
            self.JunctionCollection = JunctionCollection
        if GroupCollection is None:
            self.GroupCollection = []
        else:
            self.GroupCollection = GroupCollection
        if PaletteCollection is None:
            self.PaletteCollection = []
        else:
            self.PaletteCollection = PaletteCollection
        if PaletteBarCollection is None:
            self.PaletteBarCollection = []
        else:
            self.PaletteBarCollection = PaletteBarCollection
        if LegendDefinition is None:
            self.LegendDefinition = []
        else:
            self.LegendDefinition = LegendDefinition
        if SnapshotCollection is None:
            self.SnapshotCollection = []
        else:
            self.SnapshotCollection = SnapshotCollection
    def factory(*args_, **kwargs_):
        if Chart.subclass:
            return Chart.subclass(*args_, **kwargs_)
        else:
            return Chart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ApplicationVersion(self): return self.ApplicationVersion
    def set_ApplicationVersion(self, ApplicationVersion): self.ApplicationVersion = ApplicationVersion
    def add_ApplicationVersion(self, value): self.ApplicationVersion.append(value)
    def insert_ApplicationVersion(self, index, value): self.ApplicationVersion[index] = value
    def get_LibraryCatalogue(self): return self.LibraryCatalogue
    def set_LibraryCatalogue(self, LibraryCatalogue): self.LibraryCatalogue = LibraryCatalogue
    def add_LibraryCatalogue(self, value): self.LibraryCatalogue.append(value)
    def insert_LibraryCatalogue(self, index, value): self.LibraryCatalogue[index] = value
    def get_PropertyBagCollection(self): return self.PropertyBagCollection
    def set_PropertyBagCollection(self, PropertyBagCollection): self.PropertyBagCollection = PropertyBagCollection
    def add_PropertyBagCollection(self, value): self.PropertyBagCollection.append(value)
    def insert_PropertyBagCollection(self, index, value): self.PropertyBagCollection[index] = value
    def get_CustomImageCollection(self): return self.CustomImageCollection
    def set_CustomImageCollection(self, CustomImageCollection): self.CustomImageCollection = CustomImageCollection
    def add_CustomImageCollection(self, value): self.CustomImageCollection.append(value)
    def insert_CustomImageCollection(self, index, value): self.CustomImageCollection[index] = value
    def get_GradeOne(self): return self.GradeOne
    def set_GradeOne(self, GradeOne): self.GradeOne = GradeOne
    def add_GradeOne(self, value): self.GradeOne.append(value)
    def insert_GradeOne(self, index, value): self.GradeOne[index] = value
    def get_GradeTwo(self): return self.GradeTwo
    def set_GradeTwo(self, GradeTwo): self.GradeTwo = GradeTwo
    def add_GradeTwo(self, value): self.GradeTwo.append(value)
    def insert_GradeTwo(self, index, value): self.GradeTwo[index] = value
    def get_GradeThree(self): return self.GradeThree
    def set_GradeThree(self, GradeThree): self.GradeThree = GradeThree
    def add_GradeThree(self, value): self.GradeThree.append(value)
    def insert_GradeThree(self, index, value): self.GradeThree[index] = value
    def get_SourceHints(self): return self.SourceHints
    def set_SourceHints(self, SourceHints): self.SourceHints = SourceHints
    def add_SourceHints(self, value): self.SourceHints.append(value)
    def insert_SourceHints(self, index, value): self.SourceHints[index] = value
    def get_StrengthCollection(self): return self.StrengthCollection
    def set_StrengthCollection(self, StrengthCollection): self.StrengthCollection = StrengthCollection
    def add_StrengthCollection(self, value): self.StrengthCollection.append(value)
    def insert_StrengthCollection(self, index, value): self.StrengthCollection[index] = value
    def get_AttributeClassCollection(self): return self.AttributeClassCollection
    def set_AttributeClassCollection(self, AttributeClassCollection): self.AttributeClassCollection = AttributeClassCollection
    def add_AttributeClassCollection(self, value): self.AttributeClassCollection.append(value)
    def insert_AttributeClassCollection(self, index, value): self.AttributeClassCollection[index] = value
    def get_EntityTypeCollection(self): return self.EntityTypeCollection
    def set_EntityTypeCollection(self, EntityTypeCollection): self.EntityTypeCollection = EntityTypeCollection
    def add_EntityTypeCollection(self, value): self.EntityTypeCollection.append(value)
    def insert_EntityTypeCollection(self, index, value): self.EntityTypeCollection[index] = value
    def get_LinkTypeCollection(self): return self.LinkTypeCollection
    def set_LinkTypeCollection(self, LinkTypeCollection): self.LinkTypeCollection = LinkTypeCollection
    def add_LinkTypeCollection(self, value): self.LinkTypeCollection.append(value)
    def insert_LinkTypeCollection(self, index, value): self.LinkTypeCollection[index] = value
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def add_Font(self, value): self.Font.append(value)
    def insert_Font(self, index, value): self.Font[index] = value
    def get_DatabaseProxyCollection(self): return self.DatabaseProxyCollection
    def set_DatabaseProxyCollection(self, DatabaseProxyCollection): self.DatabaseProxyCollection = DatabaseProxyCollection
    def add_DatabaseProxyCollection(self, value): self.DatabaseProxyCollection.append(value)
    def insert_DatabaseProxyCollection(self, index, value): self.DatabaseProxyCollection[index] = value
    def get_DateTimeFormatCollection(self): return self.DateTimeFormatCollection
    def set_DateTimeFormatCollection(self, DateTimeFormatCollection): self.DateTimeFormatCollection = DateTimeFormatCollection
    def add_DateTimeFormatCollection(self, value): self.DateTimeFormatCollection.append(value)
    def insert_DateTimeFormatCollection(self, index, value): self.DateTimeFormatCollection[index] = value
    def get_CurrentStyleCollection(self): return self.CurrentStyleCollection
    def set_CurrentStyleCollection(self, CurrentStyleCollection): self.CurrentStyleCollection = CurrentStyleCollection
    def add_CurrentStyleCollection(self, value): self.CurrentStyleCollection.append(value)
    def insert_CurrentStyleCollection(self, index, value): self.CurrentStyleCollection[index] = value
    def get_TimeZone(self): return self.TimeZone
    def set_TimeZone(self, TimeZone): self.TimeZone = TimeZone
    def add_TimeZone(self, value): self.TimeZone.append(value)
    def insert_TimeZone(self, index, value): self.TimeZone[index] = value
    def get_TimeBar(self): return self.TimeBar
    def set_TimeBar(self, TimeBar): self.TimeBar = TimeBar
    def add_TimeBar(self, value): self.TimeBar.append(value)
    def insert_TimeBar(self, index, value): self.TimeBar[index] = value
    def get_PrintSettings(self): return self.PrintSettings
    def set_PrintSettings(self, PrintSettings): self.PrintSettings = PrintSettings
    def add_PrintSettings(self, value): self.PrintSettings.append(value)
    def insert_PrintSettings(self, index, value): self.PrintSettings[index] = value
    def get_Summary(self): return self.Summary
    def set_Summary(self, Summary): self.Summary = Summary
    def add_Summary(self, value): self.Summary.append(value)
    def insert_Summary(self, index, value): self.Summary[index] = value
    def get_ChartItemCollection(self): return self.ChartItemCollection
    def set_ChartItemCollection(self, ChartItemCollection): self.ChartItemCollection = ChartItemCollection
    def add_ChartItemCollection(self, value): self.ChartItemCollection.append(value)
    def insert_ChartItemCollection(self, index, value): self.ChartItemCollection[index] = value
    def get_ConnectionCollection(self): return self.ConnectionCollection
    def set_ConnectionCollection(self, ConnectionCollection): self.ConnectionCollection = ConnectionCollection
    def add_ConnectionCollection(self, value): self.ConnectionCollection.append(value)
    def insert_ConnectionCollection(self, index, value): self.ConnectionCollection[index] = value
    def get_JunctionCollection(self): return self.JunctionCollection
    def set_JunctionCollection(self, JunctionCollection): self.JunctionCollection = JunctionCollection
    def add_JunctionCollection(self, value): self.JunctionCollection.append(value)
    def insert_JunctionCollection(self, index, value): self.JunctionCollection[index] = value
    def get_GroupCollection(self): return self.GroupCollection
    def set_GroupCollection(self, GroupCollection): self.GroupCollection = GroupCollection
    def add_GroupCollection(self, value): self.GroupCollection.append(value)
    def insert_GroupCollection(self, index, value): self.GroupCollection[index] = value
    def get_PaletteCollection(self): return self.PaletteCollection
    def set_PaletteCollection(self, PaletteCollection): self.PaletteCollection = PaletteCollection
    def add_PaletteCollection(self, value): self.PaletteCollection.append(value)
    def insert_PaletteCollection(self, index, value): self.PaletteCollection[index] = value
    def get_PaletteBarCollection(self): return self.PaletteBarCollection
    def set_PaletteBarCollection(self, PaletteBarCollection): self.PaletteBarCollection = PaletteBarCollection
    def add_PaletteBarCollection(self, value): self.PaletteBarCollection.append(value)
    def insert_PaletteBarCollection(self, index, value): self.PaletteBarCollection[index] = value
    def get_LegendDefinition(self): return self.LegendDefinition
    def set_LegendDefinition(self, LegendDefinition): self.LegendDefinition = LegendDefinition
    def add_LegendDefinition(self, value): self.LegendDefinition.append(value)
    def insert_LegendDefinition(self, index, value): self.LegendDefinition[index] = value
    def get_SnapshotCollection(self): return self.SnapshotCollection
    def set_SnapshotCollection(self, SnapshotCollection): self.SnapshotCollection = SnapshotCollection
    def add_SnapshotCollection(self, value): self.SnapshotCollection.append(value)
    def insert_SnapshotCollection(self, index, value): self.SnapshotCollection[index] = value
    def get_GridHeightSize(self): return self.GridHeightSize
    def set_GridHeightSize(self, GridHeightSize): self.GridHeightSize = GridHeightSize
    def get_UseDefaultLinkSpacingWhenDragging(self): return self.UseDefaultLinkSpacingWhenDragging
    def set_UseDefaultLinkSpacingWhenDragging(self, UseDefaultLinkSpacingWhenDragging): self.UseDefaultLinkSpacingWhenDragging = UseDefaultLinkSpacingWhenDragging
    def get_GridVisibleOnAllViews(self): return self.GridVisibleOnAllViews
    def set_GridVisibleOnAllViews(self, GridVisibleOnAllViews): self.GridVisibleOnAllViews = GridVisibleOnAllViews
    def get_ShowAllFlag(self): return self.ShowAllFlag
    def set_ShowAllFlag(self, ShowAllFlag): self.ShowAllFlag = ShowAllFlag
    def get_ShowPages(self): return self.ShowPages
    def set_ShowPages(self, ShowPages): self.ShowPages = ShowPages
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_DefaultLinkSpacing(self): return self.DefaultLinkSpacing
    def set_DefaultLinkSpacing(self, DefaultLinkSpacing): self.DefaultLinkSpacing = DefaultLinkSpacing
    def get_WiringDistanceNear(self): return self.WiringDistanceNear
    def set_WiringDistanceNear(self, WiringDistanceNear): self.WiringDistanceNear = WiringDistanceNear
    def get_UseWiringHeightForThemeIcon(self): return self.UseWiringHeightForThemeIcon
    def set_UseWiringHeightForThemeIcon(self, UseWiringHeightForThemeIcon): self.UseWiringHeightForThemeIcon = UseWiringHeightForThemeIcon
    def get_DefaultTickRate(self): return self.DefaultTickRate
    def set_DefaultTickRate(self, DefaultTickRate): self.DefaultTickRate = DefaultTickRate
    def get_DefaultDateTimeForNewChart(self): return self.DefaultDateTimeForNewChart
    def set_DefaultDateTimeForNewChart(self, DefaultDateTimeForNewChart): self.DefaultDateTimeForNewChart = DefaultDateTimeForNewChart
    def get_WiringHeight(self): return self.WiringHeight
    def set_WiringHeight(self, WiringHeight): self.WiringHeight = WiringHeight
    def get_HiddenItemsVisibility(self): return self.HiddenItemsVisibility
    def set_HiddenItemsVisibility(self, HiddenItemsVisibility): self.HiddenItemsVisibility = HiddenItemsVisibility
    def get_GridWidthSize(self): return self.GridWidthSize
    def set_GridWidthSize(self, GridWidthSize): self.GridWidthSize = GridWidthSize
    def get_HideMatchingTimeZoneFormat(self): return self.HideMatchingTimeZoneFormat
    def set_HideMatchingTimeZoneFormat(self, HideMatchingTimeZoneFormat): self.HideMatchingTimeZoneFormat = HideMatchingTimeZoneFormat
    def get_DefaultDate(self): return self.DefaultDate
    def set_DefaultDate(self, DefaultDate): self.DefaultDate = DefaultDate
    def get_TimeBarVisible(self): return self.TimeBarVisible
    def set_TimeBarVisible(self, TimeBarVisible): self.TimeBarVisible = TimeBarVisible
    def get_WiringSpacing(self): return self.WiringSpacing
    def set_WiringSpacing(self, WiringSpacing): self.WiringSpacing = WiringSpacing
    def get_BlankLinkLabels(self): return self.BlankLinkLabels
    def set_BlankLinkLabels(self, BlankLinkLabels): self.BlankLinkLabels = BlankLinkLabels
    def get_UseLocalTimeZone(self): return self.UseLocalTimeZone
    def set_UseLocalTimeZone(self, UseLocalTimeZone): self.UseLocalTimeZone = UseLocalTimeZone
    def get_TypeIconDrawingMode(self): return self.TypeIconDrawingMode
    def set_TypeIconDrawingMode(self, TypeIconDrawingMode): self.TypeIconDrawingMode = TypeIconDrawingMode
    def get_WiringDistanceFar(self): return self.WiringDistanceFar
    def set_WiringDistanceFar(self, WiringDistanceFar): self.WiringDistanceFar = WiringDistanceFar
    def get_IdReferenceLinking(self): return self.IdReferenceLinking
    def set_IdReferenceLinking(self, IdReferenceLinking): self.IdReferenceLinking = IdReferenceLinking
    def get_IsBackColourFilled(self): return self.IsBackColourFilled
    def set_IsBackColourFilled(self, IsBackColourFilled): self.IsBackColourFilled = IsBackColourFilled
    def get_SnapToGrid(self): return self.SnapToGrid
    def set_SnapToGrid(self, SnapToGrid): self.SnapToGrid = SnapToGrid
    def get_LabelSumNumericLinks(self): return self.LabelSumNumericLinks
    def set_LabelSumNumericLinks(self, LabelSumNumericLinks): self.LabelSumNumericLinks = LabelSumNumericLinks
    def get_LabelRule(self): return self.LabelRule
    def set_LabelRule(self, LabelRule): self.LabelRule = LabelRule
    def get_Rigorous(self): return self.Rigorous
    def set_Rigorous(self, Rigorous): self.Rigorous = Rigorous
    def get_MsxmlVersion(self): return self.MsxmlVersion
    def set_MsxmlVersion(self, MsxmlVersion): self.MsxmlVersion = MsxmlVersion
    def get_SchemaVersion(self): return self.SchemaVersion
    def set_SchemaVersion(self, SchemaVersion): self.SchemaVersion = SchemaVersion
    def get_CoverSheetShowOnOpen(self): return self.CoverSheetShowOnOpen
    def set_CoverSheetShowOnOpen(self, CoverSheetShowOnOpen): self.CoverSheetShowOnOpen = CoverSheetShowOnOpen
    def validate_HiddenItemsVisibilityEnum(self, value):
        # Validate type HiddenItemsVisibilityEnum, a restriction on xsd:string.
        pass
    def validate_TypeIconDrawingModeEnum(self, value):
        # Validate type TypeIconDrawingModeEnum, a restriction on xsd:string.
        pass
    def validate_LabelMergeAndPasteRuleEnum(self, value):
        # Validate type LabelMergeAndPasteRuleEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.ApplicationVersion or
            self.LibraryCatalogue or
            self.PropertyBagCollection or
            self.CustomImageCollection or
            self.GradeOne or
            self.GradeTwo or
            self.GradeThree or
            self.SourceHints or
            self.StrengthCollection or
            self.AttributeClassCollection or
            self.EntityTypeCollection or
            self.LinkTypeCollection or
            self.Font or
            self.DatabaseProxyCollection or
            self.DateTimeFormatCollection or
            self.CurrentStyleCollection or
            self.TimeZone or
            self.TimeBar or
            self.PrintSettings or
            self.Summary or
            self.ChartItemCollection or
            self.ConnectionCollection or
            self.JunctionCollection or
            self.GroupCollection or
            self.PaletteCollection or
            self.PaletteBarCollection or
            self.LegendDefinition or
            self.SnapshotCollection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Chart', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Chart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Chart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Chart'):
        if self.GridHeightSize is not None and 'GridHeightSize' not in already_processed:
            already_processed.add('GridHeightSize')
            outfile.write(' GridHeightSize="%s"' % self.gds_format_double(self.GridHeightSize, input_name='GridHeightSize'))
        if self.UseDefaultLinkSpacingWhenDragging is not None and 'UseDefaultLinkSpacingWhenDragging' not in already_processed:
            already_processed.add('UseDefaultLinkSpacingWhenDragging')
            outfile.write(' UseDefaultLinkSpacingWhenDragging="%s"' % self.gds_format_boolean(self.UseDefaultLinkSpacingWhenDragging, input_name='UseDefaultLinkSpacingWhenDragging'))
        if self.GridVisibleOnAllViews is not None and 'GridVisibleOnAllViews' not in already_processed:
            already_processed.add('GridVisibleOnAllViews')
            outfile.write(' GridVisibleOnAllViews="%s"' % self.gds_format_boolean(self.GridVisibleOnAllViews, input_name='GridVisibleOnAllViews'))
        if self.ShowAllFlag is not None and 'ShowAllFlag' not in already_processed:
            already_processed.add('ShowAllFlag')
            outfile.write(' ShowAllFlag="%s"' % self.gds_format_boolean(self.ShowAllFlag, input_name='ShowAllFlag'))
        if self.ShowPages is not None and 'ShowPages' not in already_processed:
            already_processed.add('ShowPages')
            outfile.write(' ShowPages="%s"' % self.gds_format_boolean(self.ShowPages, input_name='ShowPages'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.DefaultLinkSpacing is not None and 'DefaultLinkSpacing' not in already_processed:
            already_processed.add('DefaultLinkSpacing')
            outfile.write(' DefaultLinkSpacing="%s"' % self.gds_format_double(self.DefaultLinkSpacing, input_name='DefaultLinkSpacing'))
        if self.WiringDistanceNear is not None and 'WiringDistanceNear' not in already_processed:
            already_processed.add('WiringDistanceNear')
            outfile.write(' WiringDistanceNear="%s"' % self.gds_format_double(self.WiringDistanceNear, input_name='WiringDistanceNear'))
        if self.UseWiringHeightForThemeIcon is not None and 'UseWiringHeightForThemeIcon' not in already_processed:
            already_processed.add('UseWiringHeightForThemeIcon')
            outfile.write(' UseWiringHeightForThemeIcon="%s"' % self.gds_format_boolean(self.UseWiringHeightForThemeIcon, input_name='UseWiringHeightForThemeIcon'))
        if self.DefaultTickRate is not None and 'DefaultTickRate' not in already_processed:
            already_processed.add('DefaultTickRate')
            outfile.write(' DefaultTickRate="%s"' % self.gds_format_double(self.DefaultTickRate, input_name='DefaultTickRate'))
        if self.DefaultDateTimeForNewChart is not None and 'DefaultDateTimeForNewChart' not in already_processed:
            already_processed.add('DefaultDateTimeForNewChart')
            outfile.write(' DefaultDateTimeForNewChart="%s"' % self.gds_format_datetime(self.DefaultDateTimeForNewChart, input_name='DefaultDateTimeForNewChart'))
        if self.WiringHeight is not None and 'WiringHeight' not in already_processed:
            already_processed.add('WiringHeight')
            outfile.write(' WiringHeight="%s"' % self.gds_format_double(self.WiringHeight, input_name='WiringHeight'))
        if self.HiddenItemsVisibility is not None and 'HiddenItemsVisibility' not in already_processed:
            already_processed.add('HiddenItemsVisibility')
            outfile.write(' HiddenItemsVisibility=%s' % (quote_attrib(self.HiddenItemsVisibility), ))
        if self.GridWidthSize is not None and 'GridWidthSize' not in already_processed:
            already_processed.add('GridWidthSize')
            outfile.write(' GridWidthSize="%s"' % self.gds_format_double(self.GridWidthSize, input_name='GridWidthSize'))
        if self.HideMatchingTimeZoneFormat is not None and 'HideMatchingTimeZoneFormat' not in already_processed:
            already_processed.add('HideMatchingTimeZoneFormat')
            outfile.write(' HideMatchingTimeZoneFormat="%s"' % self.gds_format_boolean(self.HideMatchingTimeZoneFormat, input_name='HideMatchingTimeZoneFormat'))
        if self.DefaultDate is not None and 'DefaultDate' not in already_processed:
            already_processed.add('DefaultDate')
            outfile.write(' DefaultDate="%s"' % self.gds_format_datetime(self.DefaultDate, input_name='DefaultDate'))
        if self.TimeBarVisible is not None and 'TimeBarVisible' not in already_processed:
            already_processed.add('TimeBarVisible')
            outfile.write(' TimeBarVisible="%s"' % self.gds_format_boolean(self.TimeBarVisible, input_name='TimeBarVisible'))
        if self.WiringSpacing is not None and 'WiringSpacing' not in already_processed:
            already_processed.add('WiringSpacing')
            outfile.write(' WiringSpacing="%s"' % self.gds_format_double(self.WiringSpacing, input_name='WiringSpacing'))
        if self.BlankLinkLabels is not None and 'BlankLinkLabels' not in already_processed:
            already_processed.add('BlankLinkLabels')
            outfile.write(' BlankLinkLabels="%s"' % self.gds_format_boolean(self.BlankLinkLabels, input_name='BlankLinkLabels'))
        if self.UseLocalTimeZone is not None and 'UseLocalTimeZone' not in already_processed:
            already_processed.add('UseLocalTimeZone')
            outfile.write(' UseLocalTimeZone="%s"' % self.gds_format_boolean(self.UseLocalTimeZone, input_name='UseLocalTimeZone'))
        if self.TypeIconDrawingMode is not None and 'TypeIconDrawingMode' not in already_processed:
            already_processed.add('TypeIconDrawingMode')
            outfile.write(' TypeIconDrawingMode=%s' % (quote_attrib(self.TypeIconDrawingMode), ))
        if self.WiringDistanceFar is not None and 'WiringDistanceFar' not in already_processed:
            already_processed.add('WiringDistanceFar')
            outfile.write(' WiringDistanceFar="%s"' % self.gds_format_double(self.WiringDistanceFar, input_name='WiringDistanceFar'))
        if self.IdReferenceLinking is not None and 'IdReferenceLinking' not in already_processed:
            already_processed.add('IdReferenceLinking')
            outfile.write(' IdReferenceLinking="%s"' % self.gds_format_boolean(self.IdReferenceLinking, input_name='IdReferenceLinking'))
        if self.IsBackColourFilled is not None and 'IsBackColourFilled' not in already_processed:
            already_processed.add('IsBackColourFilled')
            outfile.write(' IsBackColourFilled="%s"' % self.gds_format_boolean(self.IsBackColourFilled, input_name='IsBackColourFilled'))
        if self.SnapToGrid is not None and 'SnapToGrid' not in already_processed:
            already_processed.add('SnapToGrid')
            outfile.write(' SnapToGrid="%s"' % self.gds_format_boolean(self.SnapToGrid, input_name='SnapToGrid'))
        if self.LabelSumNumericLinks is not None and 'LabelSumNumericLinks' not in already_processed:
            already_processed.add('LabelSumNumericLinks')
            outfile.write(' LabelSumNumericLinks="%s"' % self.gds_format_boolean(self.LabelSumNumericLinks, input_name='LabelSumNumericLinks'))
        if self.LabelRule is not None and 'LabelRule' not in already_processed:
            already_processed.add('LabelRule')
            outfile.write(' LabelRule=%s' % (quote_attrib(self.LabelRule), ))
        if self.Rigorous is not None and 'Rigorous' not in already_processed:
            already_processed.add('Rigorous')
            outfile.write(' Rigorous="%s"' % self.gds_format_boolean(self.Rigorous, input_name='Rigorous'))
        if self.MsxmlVersion is not None and 'MsxmlVersion' not in already_processed:
            already_processed.add('MsxmlVersion')
            outfile.write(' MsxmlVersion=%s' % (self.gds_format_string(quote_attrib(self.MsxmlVersion).encode(ExternalEncoding), input_name='MsxmlVersion'), ))
        if self.SchemaVersion is not None and 'SchemaVersion' not in already_processed:
            already_processed.add('SchemaVersion')
            outfile.write(' SchemaVersion=%s' % (self.gds_format_string(quote_attrib(self.SchemaVersion).encode(ExternalEncoding), input_name='SchemaVersion'), ))
        if self.CoverSheetShowOnOpen is not None and 'CoverSheetShowOnOpen' not in already_processed:
            already_processed.add('CoverSheetShowOnOpen')
            outfile.write(' CoverSheetShowOnOpen="%s"' % self.gds_format_boolean(self.CoverSheetShowOnOpen, input_name='CoverSheetShowOnOpen'))
    def exportChildren(self, outfile, level, namespace_='', name_='Chart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ApplicationVersion_ in self.ApplicationVersion:
            ApplicationVersion_.export(outfile, level, namespace_, name_='ApplicationVersion', pretty_print=pretty_print)
        for LibraryCatalogue_ in self.LibraryCatalogue:
            LibraryCatalogue_.export(outfile, level, namespace_='lcx:', name_='LibraryCatalogue', pretty_print=pretty_print)
        for PropertyBagCollection_ in self.PropertyBagCollection:
            PropertyBagCollection_.export(outfile, level, namespace_, name_='PropertyBagCollection', pretty_print=pretty_print)
        for CustomImageCollection_ in self.CustomImageCollection:
            CustomImageCollection_.export(outfile, level, namespace_, name_='CustomImageCollection', pretty_print=pretty_print)
        for GradeOne_ in self.GradeOne:
            GradeOne_.export(outfile, level, namespace_, name_='GradeOne', pretty_print=pretty_print)
        for GradeTwo_ in self.GradeTwo:
            GradeTwo_.export(outfile, level, namespace_, name_='GradeTwo', pretty_print=pretty_print)
        for GradeThree_ in self.GradeThree:
            GradeThree_.export(outfile, level, namespace_, name_='GradeThree', pretty_print=pretty_print)
        for SourceHints_ in self.SourceHints:
            SourceHints_.export(outfile, level, namespace_, name_='SourceHints', pretty_print=pretty_print)
        for StrengthCollection_ in self.StrengthCollection:
            StrengthCollection_.export(outfile, level, namespace_, name_='StrengthCollection', pretty_print=pretty_print)
        for AttributeClassCollection_ in self.AttributeClassCollection:
            AttributeClassCollection_.export(outfile, level, namespace_, name_='AttributeClassCollection', pretty_print=pretty_print)
        for EntityTypeCollection_ in self.EntityTypeCollection:
            EntityTypeCollection_.export(outfile, level, namespace_, name_='EntityTypeCollection', pretty_print=pretty_print)
        for LinkTypeCollection_ in self.LinkTypeCollection:
            LinkTypeCollection_.export(outfile, level, namespace_, name_='LinkTypeCollection', pretty_print=pretty_print)
        for Font_ in self.Font:
            Font_.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
        for DatabaseProxyCollection_ in self.DatabaseProxyCollection:
            DatabaseProxyCollection_.export(outfile, level, namespace_, name_='DatabaseProxyCollection', pretty_print=pretty_print)
        for DateTimeFormatCollection_ in self.DateTimeFormatCollection:
            DateTimeFormatCollection_.export(outfile, level, namespace_, name_='DateTimeFormatCollection', pretty_print=pretty_print)
        for CurrentStyleCollection_ in self.CurrentStyleCollection:
            CurrentStyleCollection_.export(outfile, level, namespace_, name_='CurrentStyleCollection', pretty_print=pretty_print)
        for TimeZone_ in self.TimeZone:
            TimeZone_.export(outfile, level, namespace_, name_='TimeZone', pretty_print=pretty_print)
        for TimeBar_ in self.TimeBar:
            TimeBar_.export(outfile, level, namespace_, name_='TimeBar', pretty_print=pretty_print)
        for PrintSettings_ in self.PrintSettings:
            PrintSettings_.export(outfile, level, namespace_, name_='PrintSettings', pretty_print=pretty_print)
        for Summary_ in self.Summary:
            Summary_.export(outfile, level, namespace_, name_='Summary', pretty_print=pretty_print)
        for ChartItemCollection_ in self.ChartItemCollection:
            ChartItemCollection_.export(outfile, level, namespace_, name_='ChartItemCollection', pretty_print=pretty_print)
        for ConnectionCollection_ in self.ConnectionCollection:
            ConnectionCollection_.export(outfile, level, namespace_, name_='ConnectionCollection', pretty_print=pretty_print)
        for JunctionCollection_ in self.JunctionCollection:
            JunctionCollection_.export(outfile, level, namespace_, name_='JunctionCollection', pretty_print=pretty_print)
        for GroupCollection_ in self.GroupCollection:
            GroupCollection_.export(outfile, level, namespace_, name_='GroupCollection', pretty_print=pretty_print)
        for PaletteCollection_ in self.PaletteCollection:
            PaletteCollection_.export(outfile, level, namespace_, name_='PaletteCollection', pretty_print=pretty_print)
        for PaletteBarCollection_ in self.PaletteBarCollection:
            PaletteBarCollection_.export(outfile, level, namespace_, name_='PaletteBarCollection', pretty_print=pretty_print)
        for LegendDefinition_ in self.LegendDefinition:
            LegendDefinition_.export(outfile, level, namespace_, name_='LegendDefinition', pretty_print=pretty_print)
        for SnapshotCollection_ in self.SnapshotCollection:
            SnapshotCollection_.export(outfile, level, namespace_, name_='SnapshotCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Chart'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GridHeightSize is not None and 'GridHeightSize' not in already_processed:
            already_processed.add('GridHeightSize')
            showIndent(outfile, level)
            outfile.write('GridHeightSize=%e,\n' % (self.GridHeightSize,))
        if self.UseDefaultLinkSpacingWhenDragging is not None and 'UseDefaultLinkSpacingWhenDragging' not in already_processed:
            already_processed.add('UseDefaultLinkSpacingWhenDragging')
            showIndent(outfile, level)
            outfile.write('UseDefaultLinkSpacingWhenDragging=%s,\n' % (self.UseDefaultLinkSpacingWhenDragging,))
        if self.GridVisibleOnAllViews is not None and 'GridVisibleOnAllViews' not in already_processed:
            already_processed.add('GridVisibleOnAllViews')
            showIndent(outfile, level)
            outfile.write('GridVisibleOnAllViews=%s,\n' % (self.GridVisibleOnAllViews,))
        if self.ShowAllFlag is not None and 'ShowAllFlag' not in already_processed:
            already_processed.add('ShowAllFlag')
            showIndent(outfile, level)
            outfile.write('ShowAllFlag=%s,\n' % (self.ShowAllFlag,))
        if self.ShowPages is not None and 'ShowPages' not in already_processed:
            already_processed.add('ShowPages')
            showIndent(outfile, level)
            outfile.write('ShowPages=%s,\n' % (self.ShowPages,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.DefaultLinkSpacing is not None and 'DefaultLinkSpacing' not in already_processed:
            already_processed.add('DefaultLinkSpacing')
            showIndent(outfile, level)
            outfile.write('DefaultLinkSpacing=%e,\n' % (self.DefaultLinkSpacing,))
        if self.WiringDistanceNear is not None and 'WiringDistanceNear' not in already_processed:
            already_processed.add('WiringDistanceNear')
            showIndent(outfile, level)
            outfile.write('WiringDistanceNear=%e,\n' % (self.WiringDistanceNear,))
        if self.UseWiringHeightForThemeIcon is not None and 'UseWiringHeightForThemeIcon' not in already_processed:
            already_processed.add('UseWiringHeightForThemeIcon')
            showIndent(outfile, level)
            outfile.write('UseWiringHeightForThemeIcon=%s,\n' % (self.UseWiringHeightForThemeIcon,))
        if self.DefaultTickRate is not None and 'DefaultTickRate' not in already_processed:
            already_processed.add('DefaultTickRate')
            showIndent(outfile, level)
            outfile.write('DefaultTickRate=%e,\n' % (self.DefaultTickRate,))
        if self.DefaultDateTimeForNewChart is not None and 'DefaultDateTimeForNewChart' not in already_processed:
            already_processed.add('DefaultDateTimeForNewChart')
            showIndent(outfile, level)
            outfile.write('DefaultDateTimeForNewChart=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DefaultDateTimeForNewChart, input_name='DefaultDateTimeForNewChart'))
        if self.WiringHeight is not None and 'WiringHeight' not in already_processed:
            already_processed.add('WiringHeight')
            showIndent(outfile, level)
            outfile.write('WiringHeight=%e,\n' % (self.WiringHeight,))
        if self.HiddenItemsVisibility is not None and 'HiddenItemsVisibility' not in already_processed:
            already_processed.add('HiddenItemsVisibility')
            showIndent(outfile, level)
            outfile.write('HiddenItemsVisibility="%s",\n' % (self.HiddenItemsVisibility,))
        if self.GridWidthSize is not None and 'GridWidthSize' not in already_processed:
            already_processed.add('GridWidthSize')
            showIndent(outfile, level)
            outfile.write('GridWidthSize=%e,\n' % (self.GridWidthSize,))
        if self.HideMatchingTimeZoneFormat is not None and 'HideMatchingTimeZoneFormat' not in already_processed:
            already_processed.add('HideMatchingTimeZoneFormat')
            showIndent(outfile, level)
            outfile.write('HideMatchingTimeZoneFormat=%s,\n' % (self.HideMatchingTimeZoneFormat,))
        if self.DefaultDate is not None and 'DefaultDate' not in already_processed:
            already_processed.add('DefaultDate')
            showIndent(outfile, level)
            outfile.write('DefaultDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DefaultDate, input_name='DefaultDate'))
        if self.TimeBarVisible is not None and 'TimeBarVisible' not in already_processed:
            already_processed.add('TimeBarVisible')
            showIndent(outfile, level)
            outfile.write('TimeBarVisible=%s,\n' % (self.TimeBarVisible,))
        if self.WiringSpacing is not None and 'WiringSpacing' not in already_processed:
            already_processed.add('WiringSpacing')
            showIndent(outfile, level)
            outfile.write('WiringSpacing=%e,\n' % (self.WiringSpacing,))
        if self.BlankLinkLabels is not None and 'BlankLinkLabels' not in already_processed:
            already_processed.add('BlankLinkLabels')
            showIndent(outfile, level)
            outfile.write('BlankLinkLabels=%s,\n' % (self.BlankLinkLabels,))
        if self.UseLocalTimeZone is not None and 'UseLocalTimeZone' not in already_processed:
            already_processed.add('UseLocalTimeZone')
            showIndent(outfile, level)
            outfile.write('UseLocalTimeZone=%s,\n' % (self.UseLocalTimeZone,))
        if self.TypeIconDrawingMode is not None and 'TypeIconDrawingMode' not in already_processed:
            already_processed.add('TypeIconDrawingMode')
            showIndent(outfile, level)
            outfile.write('TypeIconDrawingMode="%s",\n' % (self.TypeIconDrawingMode,))
        if self.WiringDistanceFar is not None and 'WiringDistanceFar' not in already_processed:
            already_processed.add('WiringDistanceFar')
            showIndent(outfile, level)
            outfile.write('WiringDistanceFar=%e,\n' % (self.WiringDistanceFar,))
        if self.IdReferenceLinking is not None and 'IdReferenceLinking' not in already_processed:
            already_processed.add('IdReferenceLinking')
            showIndent(outfile, level)
            outfile.write('IdReferenceLinking=%s,\n' % (self.IdReferenceLinking,))
        if self.IsBackColourFilled is not None and 'IsBackColourFilled' not in already_processed:
            already_processed.add('IsBackColourFilled')
            showIndent(outfile, level)
            outfile.write('IsBackColourFilled=%s,\n' % (self.IsBackColourFilled,))
        if self.SnapToGrid is not None and 'SnapToGrid' not in already_processed:
            already_processed.add('SnapToGrid')
            showIndent(outfile, level)
            outfile.write('SnapToGrid=%s,\n' % (self.SnapToGrid,))
        if self.LabelSumNumericLinks is not None and 'LabelSumNumericLinks' not in already_processed:
            already_processed.add('LabelSumNumericLinks')
            showIndent(outfile, level)
            outfile.write('LabelSumNumericLinks=%s,\n' % (self.LabelSumNumericLinks,))
        if self.LabelRule is not None and 'LabelRule' not in already_processed:
            already_processed.add('LabelRule')
            showIndent(outfile, level)
            outfile.write('LabelRule="%s",\n' % (self.LabelRule,))
        if self.Rigorous is not None and 'Rigorous' not in already_processed:
            already_processed.add('Rigorous')
            showIndent(outfile, level)
            outfile.write('Rigorous=%s,\n' % (self.Rigorous,))
        if self.MsxmlVersion is not None and 'MsxmlVersion' not in already_processed:
            already_processed.add('MsxmlVersion')
            showIndent(outfile, level)
            outfile.write('MsxmlVersion="%s",\n' % (self.MsxmlVersion,))
        if self.SchemaVersion is not None and 'SchemaVersion' not in already_processed:
            already_processed.add('SchemaVersion')
            showIndent(outfile, level)
            outfile.write('SchemaVersion="%s",\n' % (self.SchemaVersion,))
        if self.CoverSheetShowOnOpen is not None and 'CoverSheetShowOnOpen' not in already_processed:
            already_processed.add('CoverSheetShowOnOpen')
            showIndent(outfile, level)
            outfile.write('CoverSheetShowOnOpen=%s,\n' % (self.CoverSheetShowOnOpen,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ApplicationVersion=[\n')
        level += 1
        for ApplicationVersion_ in self.ApplicationVersion:
            showIndent(outfile, level)
            outfile.write('model_.ApplicationVersion(\n')
            ApplicationVersion_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LibraryCatalogue=[\n')
        level += 1
        for LibraryCatalogue_ in self.LibraryCatalogue:
            showIndent(outfile, level)
            outfile.write('model_.LibraryCatalogue(\n')
            LibraryCatalogue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PropertyBagCollection=[\n')
        level += 1
        for PropertyBagCollection_ in self.PropertyBagCollection:
            showIndent(outfile, level)
            outfile.write('model_.PropertyBagCollection(\n')
            PropertyBagCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomImageCollection=[\n')
        level += 1
        for CustomImageCollection_ in self.CustomImageCollection:
            showIndent(outfile, level)
            outfile.write('model_.CustomImageCollection(\n')
            CustomImageCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradeOne=[\n')
        level += 1
        for GradeOne_ in self.GradeOne:
            showIndent(outfile, level)
            outfile.write('model_.GradeOne(\n')
            GradeOne_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradeTwo=[\n')
        level += 1
        for GradeTwo_ in self.GradeTwo:
            showIndent(outfile, level)
            outfile.write('model_.GradeTwo(\n')
            GradeTwo_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradeThree=[\n')
        level += 1
        for GradeThree_ in self.GradeThree:
            showIndent(outfile, level)
            outfile.write('model_.GradeThree(\n')
            GradeThree_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SourceHints=[\n')
        level += 1
        for SourceHints_ in self.SourceHints:
            showIndent(outfile, level)
            outfile.write('model_.SourceHints(\n')
            SourceHints_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StrengthCollection=[\n')
        level += 1
        for StrengthCollection_ in self.StrengthCollection:
            showIndent(outfile, level)
            outfile.write('model_.StrengthCollection(\n')
            StrengthCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeClassCollection=[\n')
        level += 1
        for AttributeClassCollection_ in self.AttributeClassCollection:
            showIndent(outfile, level)
            outfile.write('model_.AttributeClassCollection(\n')
            AttributeClassCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EntityTypeCollection=[\n')
        level += 1
        for EntityTypeCollection_ in self.EntityTypeCollection:
            showIndent(outfile, level)
            outfile.write('model_.EntityTypeCollection(\n')
            EntityTypeCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinkTypeCollection=[\n')
        level += 1
        for LinkTypeCollection_ in self.LinkTypeCollection:
            showIndent(outfile, level)
            outfile.write('model_.LinkTypeCollection(\n')
            LinkTypeCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Font=[\n')
        level += 1
        for Font_ in self.Font:
            showIndent(outfile, level)
            outfile.write('model_.Font(\n')
            Font_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DatabaseProxyCollection=[\n')
        level += 1
        for DatabaseProxyCollection_ in self.DatabaseProxyCollection:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseProxyCollection(\n')
            DatabaseProxyCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DateTimeFormatCollection=[\n')
        level += 1
        for DateTimeFormatCollection_ in self.DateTimeFormatCollection:
            showIndent(outfile, level)
            outfile.write('model_.DateTimeFormatCollection(\n')
            DateTimeFormatCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CurrentStyleCollection=[\n')
        level += 1
        for CurrentStyleCollection_ in self.CurrentStyleCollection:
            showIndent(outfile, level)
            outfile.write('model_.CurrentStyleCollection(\n')
            CurrentStyleCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeZone=[\n')
        level += 1
        for TimeZone_ in self.TimeZone:
            showIndent(outfile, level)
            outfile.write('model_.TimeZone(\n')
            TimeZone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeBar=[\n')
        level += 1
        for TimeBar_ in self.TimeBar:
            showIndent(outfile, level)
            outfile.write('model_.TimeBar(\n')
            TimeBar_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PrintSettings=[\n')
        level += 1
        for PrintSettings_ in self.PrintSettings:
            showIndent(outfile, level)
            outfile.write('model_.PrintSettings(\n')
            PrintSettings_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Summary=[\n')
        level += 1
        for Summary_ in self.Summary:
            showIndent(outfile, level)
            outfile.write('model_.Summary(\n')
            Summary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartItemCollection=[\n')
        level += 1
        for ChartItemCollection_ in self.ChartItemCollection:
            showIndent(outfile, level)
            outfile.write('model_.ChartItemCollection(\n')
            ChartItemCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConnectionCollection=[\n')
        level += 1
        for ConnectionCollection_ in self.ConnectionCollection:
            showIndent(outfile, level)
            outfile.write('model_.ConnectionCollection(\n')
            ConnectionCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('JunctionCollection=[\n')
        level += 1
        for JunctionCollection_ in self.JunctionCollection:
            showIndent(outfile, level)
            outfile.write('model_.JunctionCollection(\n')
            JunctionCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GroupCollection=[\n')
        level += 1
        for GroupCollection_ in self.GroupCollection:
            showIndent(outfile, level)
            outfile.write('model_.GroupCollection(\n')
            GroupCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaletteCollection=[\n')
        level += 1
        for PaletteCollection_ in self.PaletteCollection:
            showIndent(outfile, level)
            outfile.write('model_.PaletteCollection(\n')
            PaletteCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaletteBarCollection=[\n')
        level += 1
        for PaletteBarCollection_ in self.PaletteBarCollection:
            showIndent(outfile, level)
            outfile.write('model_.PaletteBarCollection(\n')
            PaletteBarCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LegendDefinition=[\n')
        level += 1
        for LegendDefinition_ in self.LegendDefinition:
            showIndent(outfile, level)
            outfile.write('model_.LegendDefinition(\n')
            LegendDefinition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnapshotCollection=[\n')
        level += 1
        for SnapshotCollection_ in self.SnapshotCollection:
            showIndent(outfile, level)
            outfile.write('model_.SnapshotCollection(\n')
            SnapshotCollection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('GridHeightSize', node)
        if value is not None and 'GridHeightSize' not in already_processed:
            already_processed.add('GridHeightSize')
            try:
                self.GridHeightSize = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (GridHeightSize): %s' % exp)
        value = find_attr_value_('UseDefaultLinkSpacingWhenDragging', node)
        if value is not None and 'UseDefaultLinkSpacingWhenDragging' not in already_processed:
            already_processed.add('UseDefaultLinkSpacingWhenDragging')
            if value in ('true', '1'):
                self.UseDefaultLinkSpacingWhenDragging = True
            elif value in ('false', '0'):
                self.UseDefaultLinkSpacingWhenDragging = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('GridVisibleOnAllViews', node)
        if value is not None and 'GridVisibleOnAllViews' not in already_processed:
            already_processed.add('GridVisibleOnAllViews')
            if value in ('true', '1'):
                self.GridVisibleOnAllViews = True
            elif value in ('false', '0'):
                self.GridVisibleOnAllViews = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowAllFlag', node)
        if value is not None and 'ShowAllFlag' not in already_processed:
            already_processed.add('ShowAllFlag')
            if value in ('true', '1'):
                self.ShowAllFlag = True
            elif value in ('false', '0'):
                self.ShowAllFlag = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowPages', node)
        if value is not None and 'ShowPages' not in already_processed:
            already_processed.add('ShowPages')
            if value in ('true', '1'):
                self.ShowPages = True
            elif value in ('false', '0'):
                self.ShowPages = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('DefaultLinkSpacing', node)
        if value is not None and 'DefaultLinkSpacing' not in already_processed:
            already_processed.add('DefaultLinkSpacing')
            try:
                self.DefaultLinkSpacing = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (DefaultLinkSpacing): %s' % exp)
        value = find_attr_value_('WiringDistanceNear', node)
        if value is not None and 'WiringDistanceNear' not in already_processed:
            already_processed.add('WiringDistanceNear')
            try:
                self.WiringDistanceNear = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WiringDistanceNear): %s' % exp)
        value = find_attr_value_('UseWiringHeightForThemeIcon', node)
        if value is not None and 'UseWiringHeightForThemeIcon' not in already_processed:
            already_processed.add('UseWiringHeightForThemeIcon')
            if value in ('true', '1'):
                self.UseWiringHeightForThemeIcon = True
            elif value in ('false', '0'):
                self.UseWiringHeightForThemeIcon = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DefaultTickRate', node)
        if value is not None and 'DefaultTickRate' not in already_processed:
            already_processed.add('DefaultTickRate')
            try:
                self.DefaultTickRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (DefaultTickRate): %s' % exp)
        value = find_attr_value_('DefaultDateTimeForNewChart', node)
        if value is not None and 'DefaultDateTimeForNewChart' not in already_processed:
            already_processed.add('DefaultDateTimeForNewChart')
            try:
                self.DefaultDateTimeForNewChart = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DefaultDateTimeForNewChart): %s' % exp)
        value = find_attr_value_('WiringHeight', node)
        if value is not None and 'WiringHeight' not in already_processed:
            already_processed.add('WiringHeight')
            try:
                self.WiringHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WiringHeight): %s' % exp)
        value = find_attr_value_('HiddenItemsVisibility', node)
        if value is not None and 'HiddenItemsVisibility' not in already_processed:
            already_processed.add('HiddenItemsVisibility')
            self.HiddenItemsVisibility = value
            self.validate_HiddenItemsVisibilityEnum(self.HiddenItemsVisibility)    # validate type HiddenItemsVisibilityEnum
        value = find_attr_value_('GridWidthSize', node)
        if value is not None and 'GridWidthSize' not in already_processed:
            already_processed.add('GridWidthSize')
            try:
                self.GridWidthSize = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (GridWidthSize): %s' % exp)
        value = find_attr_value_('HideMatchingTimeZoneFormat', node)
        if value is not None and 'HideMatchingTimeZoneFormat' not in already_processed:
            already_processed.add('HideMatchingTimeZoneFormat')
            if value in ('true', '1'):
                self.HideMatchingTimeZoneFormat = True
            elif value in ('false', '0'):
                self.HideMatchingTimeZoneFormat = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DefaultDate', node)
        if value is not None and 'DefaultDate' not in already_processed:
            already_processed.add('DefaultDate')
            try:
                self.DefaultDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DefaultDate): %s' % exp)
        value = find_attr_value_('TimeBarVisible', node)
        if value is not None and 'TimeBarVisible' not in already_processed:
            already_processed.add('TimeBarVisible')
            if value in ('true', '1'):
                self.TimeBarVisible = True
            elif value in ('false', '0'):
                self.TimeBarVisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('WiringSpacing', node)
        if value is not None and 'WiringSpacing' not in already_processed:
            already_processed.add('WiringSpacing')
            try:
                self.WiringSpacing = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WiringSpacing): %s' % exp)
        value = find_attr_value_('BlankLinkLabels', node)
        if value is not None and 'BlankLinkLabels' not in already_processed:
            already_processed.add('BlankLinkLabels')
            if value in ('true', '1'):
                self.BlankLinkLabels = True
            elif value in ('false', '0'):
                self.BlankLinkLabels = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('UseLocalTimeZone', node)
        if value is not None and 'UseLocalTimeZone' not in already_processed:
            already_processed.add('UseLocalTimeZone')
            if value in ('true', '1'):
                self.UseLocalTimeZone = True
            elif value in ('false', '0'):
                self.UseLocalTimeZone = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('TypeIconDrawingMode', node)
        if value is not None and 'TypeIconDrawingMode' not in already_processed:
            already_processed.add('TypeIconDrawingMode')
            self.TypeIconDrawingMode = value
            self.validate_TypeIconDrawingModeEnum(self.TypeIconDrawingMode)    # validate type TypeIconDrawingModeEnum
        value = find_attr_value_('WiringDistanceFar', node)
        if value is not None and 'WiringDistanceFar' not in already_processed:
            already_processed.add('WiringDistanceFar')
            try:
                self.WiringDistanceFar = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WiringDistanceFar): %s' % exp)
        value = find_attr_value_('IdReferenceLinking', node)
        if value is not None and 'IdReferenceLinking' not in already_processed:
            already_processed.add('IdReferenceLinking')
            if value in ('true', '1'):
                self.IdReferenceLinking = True
            elif value in ('false', '0'):
                self.IdReferenceLinking = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('IsBackColourFilled', node)
        if value is not None and 'IsBackColourFilled' not in already_processed:
            already_processed.add('IsBackColourFilled')
            if value in ('true', '1'):
                self.IsBackColourFilled = True
            elif value in ('false', '0'):
                self.IsBackColourFilled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SnapToGrid', node)
        if value is not None and 'SnapToGrid' not in already_processed:
            already_processed.add('SnapToGrid')
            if value in ('true', '1'):
                self.SnapToGrid = True
            elif value in ('false', '0'):
                self.SnapToGrid = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LabelSumNumericLinks', node)
        if value is not None and 'LabelSumNumericLinks' not in already_processed:
            already_processed.add('LabelSumNumericLinks')
            if value in ('true', '1'):
                self.LabelSumNumericLinks = True
            elif value in ('false', '0'):
                self.LabelSumNumericLinks = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LabelRule', node)
        if value is not None and 'LabelRule' not in already_processed:
            already_processed.add('LabelRule')
            self.LabelRule = value
            self.validate_LabelMergeAndPasteRuleEnum(self.LabelRule)    # validate type LabelMergeAndPasteRuleEnum
        value = find_attr_value_('Rigorous', node)
        if value is not None and 'Rigorous' not in already_processed:
            already_processed.add('Rigorous')
            if value in ('true', '1'):
                self.Rigorous = True
            elif value in ('false', '0'):
                self.Rigorous = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MsxmlVersion', node)
        if value is not None and 'MsxmlVersion' not in already_processed:
            already_processed.add('MsxmlVersion')
            self.MsxmlVersion = value
        value = find_attr_value_('SchemaVersion', node)
        if value is not None and 'SchemaVersion' not in already_processed:
            already_processed.add('SchemaVersion')
            self.SchemaVersion = value
        value = find_attr_value_('CoverSheetShowOnOpen', node)
        if value is not None and 'CoverSheetShowOnOpen' not in already_processed:
            already_processed.add('CoverSheetShowOnOpen')
            if value in ('true', '1'):
                self.CoverSheetShowOnOpen = True
            elif value in ('false', '0'):
                self.CoverSheetShowOnOpen = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ApplicationVersion':
            obj_ = ApplicationVersion.factory()
            obj_.build(child_)
            self.ApplicationVersion.append(obj_)
            obj_.original_tagname_ = 'ApplicationVersion'
        elif nodeName_ == 'LibraryCatalogue':
            obj_ = LibraryCatalogueType.factory()
            obj_.build(child_)
            self.LibraryCatalogue.append(obj_)
            obj_.original_tagname_ = 'LibraryCatalogue'
        elif nodeName_ == 'PropertyBagCollection':
            obj_ = PropertyBagCollection.factory()
            obj_.build(child_)
            self.PropertyBagCollection.append(obj_)
            obj_.original_tagname_ = 'PropertyBagCollection'
        elif nodeName_ == 'CustomImageCollection':
            obj_ = CustomImageCollection.factory()
            obj_.build(child_)
            self.CustomImageCollection.append(obj_)
            obj_.original_tagname_ = 'CustomImageCollection'
        elif nodeName_ == 'GradeOne':
            obj_ = GradeOne.factory()
            obj_.build(child_)
            self.GradeOne.append(obj_)
            obj_.original_tagname_ = 'GradeOne'
        elif nodeName_ == 'GradeTwo':
            obj_ = GradeTwo.factory()
            obj_.build(child_)
            self.GradeTwo.append(obj_)
            obj_.original_tagname_ = 'GradeTwo'
        elif nodeName_ == 'GradeThree':
            obj_ = GradeThree.factory()
            obj_.build(child_)
            self.GradeThree.append(obj_)
            obj_.original_tagname_ = 'GradeThree'
        elif nodeName_ == 'SourceHints':
            obj_ = SourceHints.factory()
            obj_.build(child_)
            self.SourceHints.append(obj_)
            obj_.original_tagname_ = 'SourceHints'
        elif nodeName_ == 'StrengthCollection':
            obj_ = StrengthCollection.factory()
            obj_.build(child_)
            self.StrengthCollection.append(obj_)
            obj_.original_tagname_ = 'StrengthCollection'
        elif nodeName_ == 'AttributeClassCollection':
            obj_ = AttributeClassCollection.factory()
            obj_.build(child_)
            self.AttributeClassCollection.append(obj_)
            obj_.original_tagname_ = 'AttributeClassCollection'
        elif nodeName_ == 'EntityTypeCollection':
            obj_ = EntityTypeCollection.factory()
            obj_.build(child_)
            self.EntityTypeCollection.append(obj_)
            obj_.original_tagname_ = 'EntityTypeCollection'
        elif nodeName_ == 'LinkTypeCollection':
            obj_ = LinkTypeCollection.factory()
            obj_.build(child_)
            self.LinkTypeCollection.append(obj_)
            obj_.original_tagname_ = 'LinkTypeCollection'
        elif nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font.append(obj_)
            obj_.original_tagname_ = 'Font'
        elif nodeName_ == 'DatabaseProxyCollection':
            obj_ = DatabaseProxyCollection.factory()
            obj_.build(child_)
            self.DatabaseProxyCollection.append(obj_)
            obj_.original_tagname_ = 'DatabaseProxyCollection'
        elif nodeName_ == 'DateTimeFormatCollection':
            obj_ = DateTimeFormatCollection.factory()
            obj_.build(child_)
            self.DateTimeFormatCollection.append(obj_)
            obj_.original_tagname_ = 'DateTimeFormatCollection'
        elif nodeName_ == 'CurrentStyleCollection':
            obj_ = CurrentStyleCollection.factory()
            obj_.build(child_)
            self.CurrentStyleCollection.append(obj_)
            obj_.original_tagname_ = 'CurrentStyleCollection'
        elif nodeName_ == 'TimeZone':
            obj_ = TimeZone.factory()
            obj_.build(child_)
            self.TimeZone.append(obj_)
            obj_.original_tagname_ = 'TimeZone'
        elif nodeName_ == 'TimeBar':
            obj_ = TimeBar.factory()
            obj_.build(child_)
            self.TimeBar.append(obj_)
            obj_.original_tagname_ = 'TimeBar'
        elif nodeName_ == 'PrintSettings':
            obj_ = PrintSettings.factory()
            obj_.build(child_)
            self.PrintSettings.append(obj_)
            obj_.original_tagname_ = 'PrintSettings'
        elif nodeName_ == 'Summary':
            obj_ = Summary.factory()
            obj_.build(child_)
            self.Summary.append(obj_)
            obj_.original_tagname_ = 'Summary'
        elif nodeName_ == 'ChartItemCollection':
            obj_ = ChartItemCollection.factory()
            obj_.build(child_)
            self.ChartItemCollection.append(obj_)
            obj_.original_tagname_ = 'ChartItemCollection'
        elif nodeName_ == 'ConnectionCollection':
            obj_ = ConnectionCollection.factory()
            obj_.build(child_)
            self.ConnectionCollection.append(obj_)
            obj_.original_tagname_ = 'ConnectionCollection'
        elif nodeName_ == 'JunctionCollection':
            obj_ = JunctionCollection.factory()
            obj_.build(child_)
            self.JunctionCollection.append(obj_)
            obj_.original_tagname_ = 'JunctionCollection'
        elif nodeName_ == 'GroupCollection':
            obj_ = GroupCollection.factory()
            obj_.build(child_)
            self.GroupCollection.append(obj_)
            obj_.original_tagname_ = 'GroupCollection'
        elif nodeName_ == 'PaletteCollection':
            obj_ = PaletteCollection.factory()
            obj_.build(child_)
            self.PaletteCollection.append(obj_)
            obj_.original_tagname_ = 'PaletteCollection'
        elif nodeName_ == 'PaletteBarCollection':
            obj_ = PaletteBarCollection.factory()
            obj_.build(child_)
            self.PaletteBarCollection.append(obj_)
            obj_.original_tagname_ = 'PaletteBarCollection'
        elif nodeName_ == 'LegendDefinition':
            obj_ = LegendDefinition.factory()
            obj_.build(child_)
            self.LegendDefinition.append(obj_)
            obj_.original_tagname_ = 'LegendDefinition'
        elif nodeName_ == 'SnapshotCollection':
            obj_ = SnapshotCollection.factory()
            obj_.build(child_)
            self.SnapshotCollection.append(obj_)
            obj_.original_tagname_ = 'SnapshotCollection'
# end class Chart


class ChartItem(GeneratedsSuper):
    """Generic chart item.If True, a calendar date is associated with the
    chart item. Use DateTime to specify the date. Controlling items
    raise a run-time error if they cause the chart's time to flow
    right to left.Actual Date value associated with the chart item,
    where the value is represented in UTC. DateSet and/or TimeSet
    must be True. Controlling items raise a run-time error if they
    cause the chart's time to flow right to left.A string
    description of the date and time, for example ‘About
    3pm’.Description of the chart item.Index into the item's grade
    one in the chart's grading system.IDREF for the item's grade one
    in the chart's grading system.Index into the item's grade three
    in the chart's grading system.IDREF for the item's grade three
    in the chart's grading system.Index into the item's grade two in
    the chart's grading system.IDREF for the item's grade two in the
    chart's grading system.Chart item ID (see
    IdReferenceLinking).The IDREF of the item's group.Text used as
    the label for the chart item. If the chart item is an entity and
    LabelIsIdentity is True, this also sets the entity's Identity
    property - see LNEntity.Identity.Offset from UTC of the chart
    item's local date and time.If True, the chart item has a
    relative order on the chart with respect to its neighboring
    chart items. Has no effect on links that are not between theme
    lines. Controlling items raise a run-time error if they cause
    the chart's time to flow right to left.If True, the chart item
    is shown on the chart.If True, the chart item is selected on the
    chart.Source reference for the chart item, which indicates the
    source of material in card text, e.g. Document Number.Source
    type for the chart item, e.g. Witness, Informant etc.If True, a
    time is associated with the chart item. Use DateTime to specify
    the time value. Controlling items raise a run-time error if they
    cause the chart's time to flow right to left.X position of the
    chart item. For ends, this is identical to X property. For links
    between theme lines, defines their placement. For other links,
    has no effect. Controlling items raise a run-time error if they
    cause the chart's time to flow right to left."""
    subclass = None
    superclass = None
    def __init__(self, LocalDateTimeOffset=None, Shown=None, DateSet=False, GradeOneIndex=0, Description=None, GroupReference=None, GradeTwoIndex=0, Selected=False, GradeTwoReference=None, GradeThreeReference=None, DateTime=None, DateTimeDescription=None, SourceReference=None, SourceType=None, GradeThreeIndex=0, TimeSet=False, Ordered=False, Label=None, XPosition=0, Id=None, GradeOneReference=None, End=None, Link=None, AttributeCollection=None, CIStyle=None, PropertyBagCollection=None, TimeZone=None):
        self.original_tagname_ = None
        self.LocalDateTimeOffset = _cast(int, LocalDateTimeOffset)
        self.Shown = _cast(bool, Shown)
        self.DateSet = _cast(bool, DateSet)
        self.GradeOneIndex = _cast(int, GradeOneIndex)
        self.Description = _cast(None, Description)
        self.GroupReference = _cast(None, GroupReference)
        self.GradeTwoIndex = _cast(int, GradeTwoIndex)
        self.Selected = _cast(bool, Selected)
        self.GradeTwoReference = _cast(None, GradeTwoReference)
        self.GradeThreeReference = _cast(None, GradeThreeReference)
        if isinstance(DateTime, str):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
        self.DateTimeDescription = _cast(None, DateTimeDescription)
        self.SourceReference = _cast(None, SourceReference)
        self.SourceType = _cast(None, SourceType)
        self.GradeThreeIndex = _cast(int, GradeThreeIndex)
        self.TimeSet = _cast(bool, TimeSet)
        self.Ordered = _cast(bool, Ordered)
        self.Label = _cast(None, Label)
        self.XPosition = _cast(int, XPosition)
        self.Id = _cast(None, Id)
        self.GradeOneReference = _cast(None, GradeOneReference)
        self.End = End
        self.Link = Link
        self.AttributeCollection = AttributeCollection
        self.CIStyle = CIStyle
        self.PropertyBagCollection = PropertyBagCollection
        self.TimeZone = TimeZone
    def factory(*args_, **kwargs_):
        if ChartItem.subclass:
            return ChartItem.subclass(*args_, **kwargs_)
        else:
            return ChartItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_End(self): return self.End
    def set_End(self, End): self.End = End
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def get_AttributeCollection(self): return self.AttributeCollection
    def set_AttributeCollection(self, AttributeCollection): self.AttributeCollection = AttributeCollection
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_PropertyBagCollection(self): return self.PropertyBagCollection
    def set_PropertyBagCollection(self, PropertyBagCollection): self.PropertyBagCollection = PropertyBagCollection
    def get_TimeZone(self): return self.TimeZone
    def set_TimeZone(self, TimeZone): self.TimeZone = TimeZone
    def get_LocalDateTimeOffset(self): return self.LocalDateTimeOffset
    def set_LocalDateTimeOffset(self, LocalDateTimeOffset): self.LocalDateTimeOffset = LocalDateTimeOffset
    def get_Shown(self): return self.Shown
    def set_Shown(self, Shown): self.Shown = Shown
    def get_DateSet(self): return self.DateSet
    def set_DateSet(self, DateSet): self.DateSet = DateSet
    def get_GradeOneIndex(self): return self.GradeOneIndex
    def set_GradeOneIndex(self, GradeOneIndex): self.GradeOneIndex = GradeOneIndex
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_GroupReference(self): return self.GroupReference
    def set_GroupReference(self, GroupReference): self.GroupReference = GroupReference
    def get_GradeTwoIndex(self): return self.GradeTwoIndex
    def set_GradeTwoIndex(self, GradeTwoIndex): self.GradeTwoIndex = GradeTwoIndex
    def get_Selected(self): return self.Selected
    def set_Selected(self, Selected): self.Selected = Selected
    def get_GradeTwoReference(self): return self.GradeTwoReference
    def set_GradeTwoReference(self, GradeTwoReference): self.GradeTwoReference = GradeTwoReference
    def get_GradeThreeReference(self): return self.GradeThreeReference
    def set_GradeThreeReference(self, GradeThreeReference): self.GradeThreeReference = GradeThreeReference
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_DateTimeDescription(self): return self.DateTimeDescription
    def set_DateTimeDescription(self, DateTimeDescription): self.DateTimeDescription = DateTimeDescription
    def get_SourceReference(self): return self.SourceReference
    def set_SourceReference(self, SourceReference): self.SourceReference = SourceReference
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_GradeThreeIndex(self): return self.GradeThreeIndex
    def set_GradeThreeIndex(self, GradeThreeIndex): self.GradeThreeIndex = GradeThreeIndex
    def get_TimeSet(self): return self.TimeSet
    def set_TimeSet(self, TimeSet): self.TimeSet = TimeSet
    def get_Ordered(self): return self.Ordered
    def set_Ordered(self, Ordered): self.Ordered = Ordered
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_XPosition(self): return self.XPosition
    def set_XPosition(self, XPosition): self.XPosition = XPosition
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_GradeOneReference(self): return self.GradeOneReference
    def set_GradeOneReference(self, GradeOneReference): self.GradeOneReference = GradeOneReference
    def hasContent_(self):
        if (
            self.End is not None or
            self.Link is not None or
            self.AttributeCollection is not None or
            self.CIStyle is not None or
            self.PropertyBagCollection is not None or
            self.TimeZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChartItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChartItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartItem'):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            outfile.write(' LocalDateTimeOffset="%s"' % self.gds_format_integer(self.LocalDateTimeOffset, input_name='LocalDateTimeOffset'))
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            outfile.write(' Shown="%s"' % self.gds_format_boolean(self.Shown, input_name='Shown'))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            outfile.write(' DateSet="%s"' % self.gds_format_boolean(self.DateSet, input_name='DateSet'))
        if self.GradeOneIndex is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            outfile.write(' GradeOneIndex="%s"' % self.gds_format_integer(self.GradeOneIndex, input_name='GradeOneIndex'))
        if self.Description is not None and 'Description' not in already_processed:
            already_processed.add('Description')
            outfile.write(' Description=%s' % (self.gds_format_string(quote_attrib(self.Description).encode(ExternalEncoding), input_name='Description'), ))
        if self.GroupReference is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            outfile.write(' GroupReference=%s' % (self.gds_format_string(quote_attrib(self.GroupReference).encode(ExternalEncoding), input_name='GroupReference'), ))
        if self.GradeTwoIndex is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            outfile.write(' GradeTwoIndex="%s"' % self.gds_format_integer(self.GradeTwoIndex, input_name='GradeTwoIndex'))
        if self.Selected is not None and 'Selected' not in already_processed:
            already_processed.add('Selected')
            outfile.write(' Selected="%s"' % self.gds_format_boolean(self.Selected, input_name='Selected'))
        if self.GradeTwoReference is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            outfile.write(' GradeTwoReference=%s' % (self.gds_format_string(quote_attrib(self.GradeTwoReference).encode(ExternalEncoding), input_name='GradeTwoReference'), ))
        if self.GradeThreeReference is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            outfile.write(' GradeThreeReference=%s' % (self.gds_format_string(quote_attrib(self.GradeThreeReference).encode(ExternalEncoding), input_name='GradeThreeReference'), ))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            outfile.write(' DateTime="%s"' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.DateTimeDescription is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            outfile.write(' DateTimeDescription=%s' % (self.gds_format_string(quote_attrib(self.DateTimeDescription).encode(ExternalEncoding), input_name='DateTimeDescription'), ))
        if self.SourceReference is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            outfile.write(' SourceReference=%s' % (self.gds_format_string(quote_attrib(self.SourceReference).encode(ExternalEncoding), input_name='SourceReference'), ))
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            outfile.write(' SourceType=%s' % (self.gds_format_string(quote_attrib(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), ))
        if self.GradeThreeIndex is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            outfile.write(' GradeThreeIndex="%s"' % self.gds_format_integer(self.GradeThreeIndex, input_name='GradeThreeIndex'))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            outfile.write(' TimeSet="%s"' % self.gds_format_boolean(self.TimeSet, input_name='TimeSet'))
        if self.Ordered is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            outfile.write(' Ordered="%s"' % self.gds_format_boolean(self.Ordered, input_name='Ordered'))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            outfile.write(' Label=%s' % (self.gds_format_string(quote_attrib(self.Label).encode(ExternalEncoding), input_name='Label'), ))
        if self.XPosition is not None and 'XPosition' not in already_processed:
            already_processed.add('XPosition')
            outfile.write(' XPosition="%s"' % self.gds_format_integer(self.XPosition, input_name='XPosition'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.GradeOneReference is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            outfile.write(' GradeOneReference=%s' % (self.gds_format_string(quote_attrib(self.GradeOneReference).encode(ExternalEncoding), input_name='GradeOneReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.End is not None:
            self.End.export(outfile, level, namespace_, name_='End', pretty_print=pretty_print)
        if self.Link is not None:
            self.Link.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.AttributeCollection is not None:
            self.AttributeCollection.export(outfile, level, namespace_, name_='AttributeCollection', pretty_print=pretty_print)
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.PropertyBagCollection is not None:
            self.PropertyBagCollection.export(outfile, level, namespace_, name_='PropertyBagCollection', pretty_print=pretty_print)
        if self.TimeZone is not None:
            self.TimeZone.export(outfile, level, namespace_, name_='TimeZone', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ChartItem'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            showIndent(outfile, level)
            outfile.write('LocalDateTimeOffset=%d,\n' % (self.LocalDateTimeOffset,))
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            showIndent(outfile, level)
            outfile.write('Shown=%s,\n' % (self.Shown,))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            showIndent(outfile, level)
            outfile.write('DateSet=%s,\n' % (self.DateSet,))
        if self.GradeOneIndex is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            showIndent(outfile, level)
            outfile.write('GradeOneIndex=%d,\n' % (self.GradeOneIndex,))
        if self.Description is not None and 'Description' not in already_processed:
            already_processed.add('Description')
            showIndent(outfile, level)
            outfile.write('Description="%s",\n' % (self.Description,))
        if self.GroupReference is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            showIndent(outfile, level)
            outfile.write('GroupReference="%s",\n' % (self.GroupReference,))
        if self.GradeTwoIndex is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            showIndent(outfile, level)
            outfile.write('GradeTwoIndex=%d,\n' % (self.GradeTwoIndex,))
        if self.Selected is not None and 'Selected' not in already_processed:
            already_processed.add('Selected')
            showIndent(outfile, level)
            outfile.write('Selected=%s,\n' % (self.Selected,))
        if self.GradeTwoReference is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            showIndent(outfile, level)
            outfile.write('GradeTwoReference="%s",\n' % (self.GradeTwoReference,))
        if self.GradeThreeReference is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            showIndent(outfile, level)
            outfile.write('GradeThreeReference="%s",\n' % (self.GradeThreeReference,))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            showIndent(outfile, level)
            outfile.write('DateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.DateTimeDescription is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            showIndent(outfile, level)
            outfile.write('DateTimeDescription="%s",\n' % (self.DateTimeDescription,))
        if self.SourceReference is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            showIndent(outfile, level)
            outfile.write('SourceReference="%s",\n' % (self.SourceReference,))
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            showIndent(outfile, level)
            outfile.write('SourceType="%s",\n' % (self.SourceType,))
        if self.GradeThreeIndex is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            showIndent(outfile, level)
            outfile.write('GradeThreeIndex=%d,\n' % (self.GradeThreeIndex,))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            showIndent(outfile, level)
            outfile.write('TimeSet=%s,\n' % (self.TimeSet,))
        if self.Ordered is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            showIndent(outfile, level)
            outfile.write('Ordered=%s,\n' % (self.Ordered,))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            showIndent(outfile, level)
            outfile.write('Label="%s",\n' % (self.Label,))
        if self.XPosition is not None and 'XPosition' not in already_processed:
            already_processed.add('XPosition')
            showIndent(outfile, level)
            outfile.write('XPosition=%d,\n' % (self.XPosition,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.GradeOneReference is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            showIndent(outfile, level)
            outfile.write('GradeOneReference="%s",\n' % (self.GradeOneReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.End is not None:
            showIndent(outfile, level)
            outfile.write('End=model_.End(\n')
            self.End.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Link is not None:
            showIndent(outfile, level)
            outfile.write('Link=model_.Link(\n')
            self.Link.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AttributeCollection is not None:
            showIndent(outfile, level)
            outfile.write('AttributeCollection=model_.AttributeCollection(\n')
            self.AttributeCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertyBagCollection is not None:
            showIndent(outfile, level)
            outfile.write('PropertyBagCollection=model_.PropertyBagCollection(\n')
            self.PropertyBagCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeZone is not None:
            showIndent(outfile, level)
            outfile.write('TimeZone=model_.TimeZone(\n')
            self.TimeZone.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LocalDateTimeOffset', node)
        if value is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            try:
                self.LocalDateTimeOffset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Shown', node)
        if value is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            if value in ('true', '1'):
                self.Shown = True
            elif value in ('false', '0'):
                self.Shown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateSet', node)
        if value is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            if value in ('true', '1'):
                self.DateSet = True
            elif value in ('false', '0'):
                self.DateSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('GradeOneIndex', node)
        if value is not None and 'GradeOneIndex' not in already_processed:
            already_processed.add('GradeOneIndex')
            try:
                self.GradeOneIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Description', node)
        if value is not None and 'Description' not in already_processed:
            already_processed.add('Description')
            self.Description = value
        value = find_attr_value_('GroupReference', node)
        if value is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            self.GroupReference = value
        value = find_attr_value_('GradeTwoIndex', node)
        if value is not None and 'GradeTwoIndex' not in already_processed:
            already_processed.add('GradeTwoIndex')
            try:
                self.GradeTwoIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Selected', node)
        if value is not None and 'Selected' not in already_processed:
            already_processed.add('Selected')
            if value in ('true', '1'):
                self.Selected = True
            elif value in ('false', '0'):
                self.Selected = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('GradeTwoReference', node)
        if value is not None and 'GradeTwoReference' not in already_processed:
            already_processed.add('GradeTwoReference')
            self.GradeTwoReference = value
        value = find_attr_value_('GradeThreeReference', node)
        if value is not None and 'GradeThreeReference' not in already_processed:
            already_processed.add('GradeThreeReference')
            self.GradeThreeReference = value
        value = find_attr_value_('DateTime', node)
        if value is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            try:
                self.DateTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DateTime): %s' % exp)
        value = find_attr_value_('DateTimeDescription', node)
        if value is not None and 'DateTimeDescription' not in already_processed:
            already_processed.add('DateTimeDescription')
            self.DateTimeDescription = value
        value = find_attr_value_('SourceReference', node)
        if value is not None and 'SourceReference' not in already_processed:
            already_processed.add('SourceReference')
            self.SourceReference = value
        value = find_attr_value_('SourceType', node)
        if value is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            self.SourceType = value
        value = find_attr_value_('GradeThreeIndex', node)
        if value is not None and 'GradeThreeIndex' not in already_processed:
            already_processed.add('GradeThreeIndex')
            try:
                self.GradeThreeIndex = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TimeSet', node)
        if value is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            if value in ('true', '1'):
                self.TimeSet = True
            elif value in ('false', '0'):
                self.TimeSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Ordered', node)
        if value is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            if value in ('true', '1'):
                self.Ordered = True
            elif value in ('false', '0'):
                self.Ordered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Label', node)
        if value is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            self.Label = value
        value = find_attr_value_('XPosition', node)
        if value is not None and 'XPosition' not in already_processed:
            already_processed.add('XPosition')
            try:
                self.XPosition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('GradeOneReference', node)
        if value is not None and 'GradeOneReference' not in already_processed:
            already_processed.add('GradeOneReference')
            self.GradeOneReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'End':
            obj_ = End.factory()
            obj_.build(child_)
            self.End = obj_
            obj_.original_tagname_ = 'End'
        elif nodeName_ == 'Link':
            obj_ = Link.factory()
            obj_.build(child_)
            self.Link = obj_
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'AttributeCollection':
            obj_ = AttributeCollection.factory()
            obj_.build(child_)
            self.AttributeCollection = obj_
            obj_.original_tagname_ = 'AttributeCollection'
        elif nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'PropertyBagCollection':
            obj_ = PropertyBagCollection.factory()
            obj_.build(child_)
            self.PropertyBagCollection = obj_
            obj_.original_tagname_ = 'PropertyBagCollection'
        elif nodeName_ == 'TimeZone':
            obj_ = TimeZone.factory()
            obj_.build(child_)
            self.TimeZone = obj_
            obj_.original_tagname_ = 'TimeZone'
# end class ChartItem


class ChartItemCollection(GeneratedsSuper):
    """Collection of chart items on the chart."""
    subclass = None
    superclass = None
    def __init__(self, ChartItem=None):
        self.original_tagname_ = None
        if ChartItem is None:
            self.ChartItem = []
        else:
            self.ChartItem = ChartItem
    def factory(*args_, **kwargs_):
        if ChartItemCollection.subclass:
            return ChartItemCollection.subclass(*args_, **kwargs_)
        else:
            return ChartItemCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartItem(self): return self.ChartItem
    def set_ChartItem(self, ChartItem): self.ChartItem = ChartItem
    def add_ChartItem(self, value): self.ChartItem.append(value)
    def insert_ChartItem(self, index, value): self.ChartItem[index] = value
    def hasContent_(self):
        if (
            self.ChartItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChartItemCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartItemCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChartItemCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartItemCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartItemCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ChartItem_ in self.ChartItem:
            ChartItem_.export(outfile, level, namespace_, name_='ChartItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ChartItemCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartItem=[\n')
        level += 1
        for ChartItem_ in self.ChartItem:
            showIndent(outfile, level)
            outfile.write('model_.ChartItem(\n')
            ChartItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartItem':
            obj_ = ChartItem.factory()
            obj_.build(child_)
            self.ChartItem.append(obj_)
            obj_.original_tagname_ = 'ChartItem'
# end class ChartItemCollection


class Circle(GeneratedsSuper):
    """A circle chart item object. Part of the chart item inheritance
    hierarchy."""
    subclass = None
    superclass = None
    def __init__(self, CircleStyle=None):
        self.original_tagname_ = None
        self.CircleStyle = CircleStyle
    def factory(*args_, **kwargs_):
        if Circle.subclass:
            return Circle.subclass(*args_, **kwargs_)
        else:
            return Circle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CircleStyle(self): return self.CircleStyle
    def set_CircleStyle(self, CircleStyle): self.CircleStyle = CircleStyle
    def hasContent_(self):
        if (
            self.CircleStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Circle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Circle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Circle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Circle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Circle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CircleStyle is not None:
            self.CircleStyle.export(outfile, level, namespace_, name_='CircleStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Circle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CircleStyle is not None:
            showIndent(outfile, level)
            outfile.write('CircleStyle=model_.CircleStyle(\n')
            self.CircleStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CircleStyle':
            obj_ = CircleStyle.factory()
            obj_.build(child_)
            self.CircleStyle = obj_
            obj_.original_tagname_ = 'CircleStyle'
# end class Circle


class CircleStyle(GeneratedsSuper):
    """Style of the circle chart item. Part of the LNCIStyle inheritance
    hierarchy.If True, the diameter of the circle is dynamically
    resized to accommodate all characters in the circle's
    label.Color used to fill the chart item when Filled is
    True.Diameter of the circle, expressed in Inches.Type IDREF of
    entity used by this style. An entity type is a category of
    entity.If True, the circle is filled. Control the fill color
    using the BackColour property.Signifies whether the item is a
    solid colour, transparent or contains a gradient-fill.Width of
    the line used to draw the circle.Color of the line used to draw
    the chart item.Strength associated with the circle, which
    controls the circle border appearance.Strength IDREF of entity
    used by this style. An entity type is a category of entity.Type
    of entity used by this style. An entity type is a category of
    entity."""
    subclass = None
    superclass = None
    def __init__(self, Diameter=None, Autosize=None, Strength=None, StrengthReference=None, EntityTypeReference=None, FillStyle=None, LineColour=None, BackColour=None, LineWidth=None, Type=None, Filled=None):
        self.original_tagname_ = None
        self.Diameter = _cast(float, Diameter)
        self.Autosize = _cast(bool, Autosize)
        self.Strength = _cast(None, Strength)
        self.StrengthReference = _cast(None, StrengthReference)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.FillStyle = _cast(None, FillStyle)
        self.LineColour = _cast(int, LineColour)
        self.BackColour = _cast(int, BackColour)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
        self.Filled = _cast(bool, Filled)
    def factory(*args_, **kwargs_):
        if CircleStyle.subclass:
            return CircleStyle.subclass(*args_, **kwargs_)
        else:
            return CircleStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Diameter(self): return self.Diameter
    def set_Diameter(self, Diameter): self.Diameter = Diameter
    def get_Autosize(self): return self.Autosize
    def set_Autosize(self, Autosize): self.Autosize = Autosize
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_FillStyle(self): return self.FillStyle
    def set_FillStyle(self, FillStyle): self.FillStyle = FillStyle
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Filled(self): return self.Filled
    def set_Filled(self, Filled): self.Filled = Filled
    def validate_FillStyleEnum(self, value):
        # Validate type FillStyleEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CircleStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CircleStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CircleStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CircleStyle'):
        if self.Diameter is not None and 'Diameter' not in already_processed:
            already_processed.add('Diameter')
            outfile.write(' Diameter="%s"' % self.gds_format_double(self.Diameter, input_name='Diameter'))
        if self.Autosize is not None and 'Autosize' not in already_processed:
            already_processed.add('Autosize')
            outfile.write(' Autosize="%s"' % self.gds_format_boolean(self.Autosize, input_name='Autosize'))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            outfile.write(' FillStyle=%s' % (quote_attrib(self.FillStyle), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            outfile.write(' Filled="%s"' % self.gds_format_boolean(self.Filled, input_name='Filled'))
    def exportChildren(self, outfile, level, namespace_='', name_='CircleStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CircleStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Diameter is not None and 'Diameter' not in already_processed:
            already_processed.add('Diameter')
            showIndent(outfile, level)
            outfile.write('Diameter=%e,\n' % (self.Diameter,))
        if self.Autosize is not None and 'Autosize' not in already_processed:
            already_processed.add('Autosize')
            showIndent(outfile, level)
            outfile.write('Autosize=%s,\n' % (self.Autosize,))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            showIndent(outfile, level)
            outfile.write('FillStyle="%s",\n' % (self.FillStyle,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            showIndent(outfile, level)
            outfile.write('Filled=%s,\n' % (self.Filled,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Diameter', node)
        if value is not None and 'Diameter' not in already_processed:
            already_processed.add('Diameter')
            try:
                self.Diameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Diameter): %s' % exp)
        value = find_attr_value_('Autosize', node)
        if value is not None and 'Autosize' not in already_processed:
            already_processed.add('Autosize')
            if value in ('true', '1'):
                self.Autosize = True
            elif value in ('false', '0'):
                self.Autosize = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('FillStyle', node)
        if value is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            self.FillStyle = value
            self.validate_FillStyleEnum(self.FillStyle)    # validate type FillStyleEnum
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Filled', node)
        if value is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            if value in ('true', '1'):
                self.Filled = True
            elif value in ('false', '0'):
                self.Filled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CircleStyle


class CIStyle(GeneratedsSuper):
    """Generic chart item style.If True, the chart item is in the
    background layer.Format of the Date value when it is
    shown.Format IDREF of the Date value when it is shown.If True,
    the item's date and time description is shown. If False, the
    formatted DateTime itself is shown.Width of the text field on
    the chart item that displays the
    description/source/grades/attributes block when shown. Expressed
    in inches.If True, the SubTextWidth value defines the text width
    for the description, source, grades and attributes sub items
    that are displayed on chart items that use this style."""
    subclass = None
    superclass = None
    def __init__(self, UseSubTextWidth=None, ShowDateTimeDescription=None, SubTextWidth=None, Background=None, DateTimeFormat=None, DateTimeFormatReference=None, Font=None, SubItemCollection=None):
        self.original_tagname_ = None
        self.UseSubTextWidth = _cast(bool, UseSubTextWidth)
        self.ShowDateTimeDescription = _cast(bool, ShowDateTimeDescription)
        self.SubTextWidth = _cast(float, SubTextWidth)
        self.Background = _cast(bool, Background)
        self.DateTimeFormat = _cast(None, DateTimeFormat)
        self.DateTimeFormatReference = _cast(None, DateTimeFormatReference)
        self.Font = Font
        self.SubItemCollection = SubItemCollection
    def factory(*args_, **kwargs_):
        if CIStyle.subclass:
            return CIStyle.subclass(*args_, **kwargs_)
        else:
            return CIStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_SubItemCollection(self): return self.SubItemCollection
    def set_SubItemCollection(self, SubItemCollection): self.SubItemCollection = SubItemCollection
    def get_UseSubTextWidth(self): return self.UseSubTextWidth
    def set_UseSubTextWidth(self, UseSubTextWidth): self.UseSubTextWidth = UseSubTextWidth
    def get_ShowDateTimeDescription(self): return self.ShowDateTimeDescription
    def set_ShowDateTimeDescription(self, ShowDateTimeDescription): self.ShowDateTimeDescription = ShowDateTimeDescription
    def get_SubTextWidth(self): return self.SubTextWidth
    def set_SubTextWidth(self, SubTextWidth): self.SubTextWidth = SubTextWidth
    def get_Background(self): return self.Background
    def set_Background(self, Background): self.Background = Background
    def get_DateTimeFormat(self): return self.DateTimeFormat
    def set_DateTimeFormat(self, DateTimeFormat): self.DateTimeFormat = DateTimeFormat
    def get_DateTimeFormatReference(self): return self.DateTimeFormatReference
    def set_DateTimeFormatReference(self, DateTimeFormatReference): self.DateTimeFormatReference = DateTimeFormatReference
    def hasContent_(self):
        if (
            self.Font is not None or
            self.SubItemCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIStyle'):
        if self.UseSubTextWidth is not None and 'UseSubTextWidth' not in already_processed:
            already_processed.add('UseSubTextWidth')
            outfile.write(' UseSubTextWidth="%s"' % self.gds_format_boolean(self.UseSubTextWidth, input_name='UseSubTextWidth'))
        if self.ShowDateTimeDescription is not None and 'ShowDateTimeDescription' not in already_processed:
            already_processed.add('ShowDateTimeDescription')
            outfile.write(' ShowDateTimeDescription="%s"' % self.gds_format_boolean(self.ShowDateTimeDescription, input_name='ShowDateTimeDescription'))
        if self.SubTextWidth is not None and 'SubTextWidth' not in already_processed:
            already_processed.add('SubTextWidth')
            outfile.write(' SubTextWidth="%s"' % self.gds_format_double(self.SubTextWidth, input_name='SubTextWidth'))
        if self.Background is not None and 'Background' not in already_processed:
            already_processed.add('Background')
            outfile.write(' Background="%s"' % self.gds_format_boolean(self.Background, input_name='Background'))
        if self.DateTimeFormat is not None and 'DateTimeFormat' not in already_processed:
            already_processed.add('DateTimeFormat')
            outfile.write(' DateTimeFormat=%s' % (self.gds_format_string(quote_attrib(self.DateTimeFormat).encode(ExternalEncoding), input_name='DateTimeFormat'), ))
        if self.DateTimeFormatReference is not None and 'DateTimeFormatReference' not in already_processed:
            already_processed.add('DateTimeFormatReference')
            outfile.write(' DateTimeFormatReference=%s' % (self.gds_format_string(quote_attrib(self.DateTimeFormatReference).encode(ExternalEncoding), input_name='DateTimeFormatReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CIStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            self.Font.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
        if self.SubItemCollection is not None:
            self.SubItemCollection.export(outfile, level, namespace_, name_='SubItemCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CIStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.UseSubTextWidth is not None and 'UseSubTextWidth' not in already_processed:
            already_processed.add('UseSubTextWidth')
            showIndent(outfile, level)
            outfile.write('UseSubTextWidth=%s,\n' % (self.UseSubTextWidth,))
        if self.ShowDateTimeDescription is not None and 'ShowDateTimeDescription' not in already_processed:
            already_processed.add('ShowDateTimeDescription')
            showIndent(outfile, level)
            outfile.write('ShowDateTimeDescription=%s,\n' % (self.ShowDateTimeDescription,))
        if self.SubTextWidth is not None and 'SubTextWidth' not in already_processed:
            already_processed.add('SubTextWidth')
            showIndent(outfile, level)
            outfile.write('SubTextWidth=%e,\n' % (self.SubTextWidth,))
        if self.Background is not None and 'Background' not in already_processed:
            already_processed.add('Background')
            showIndent(outfile, level)
            outfile.write('Background=%s,\n' % (self.Background,))
        if self.DateTimeFormat is not None and 'DateTimeFormat' not in already_processed:
            already_processed.add('DateTimeFormat')
            showIndent(outfile, level)
            outfile.write('DateTimeFormat="%s",\n' % (self.DateTimeFormat,))
        if self.DateTimeFormatReference is not None and 'DateTimeFormatReference' not in already_processed:
            already_processed.add('DateTimeFormatReference')
            showIndent(outfile, level)
            outfile.write('DateTimeFormatReference="%s",\n' % (self.DateTimeFormatReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Font is not None:
            showIndent(outfile, level)
            outfile.write('Font=model_.Font(\n')
            self.Font.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubItemCollection is not None:
            showIndent(outfile, level)
            outfile.write('SubItemCollection=model_.SubItemCollection(\n')
            self.SubItemCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UseSubTextWidth', node)
        if value is not None and 'UseSubTextWidth' not in already_processed:
            already_processed.add('UseSubTextWidth')
            if value in ('true', '1'):
                self.UseSubTextWidth = True
            elif value in ('false', '0'):
                self.UseSubTextWidth = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ShowDateTimeDescription', node)
        if value is not None and 'ShowDateTimeDescription' not in already_processed:
            already_processed.add('ShowDateTimeDescription')
            if value in ('true', '1'):
                self.ShowDateTimeDescription = True
            elif value in ('false', '0'):
                self.ShowDateTimeDescription = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SubTextWidth', node)
        if value is not None and 'SubTextWidth' not in already_processed:
            already_processed.add('SubTextWidth')
            try:
                self.SubTextWidth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (SubTextWidth): %s' % exp)
        value = find_attr_value_('Background', node)
        if value is not None and 'Background' not in already_processed:
            already_processed.add('Background')
            if value in ('true', '1'):
                self.Background = True
            elif value in ('false', '0'):
                self.Background = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateTimeFormat', node)
        if value is not None and 'DateTimeFormat' not in already_processed:
            already_processed.add('DateTimeFormat')
            self.DateTimeFormat = value
        value = find_attr_value_('DateTimeFormatReference', node)
        if value is not None and 'DateTimeFormatReference' not in already_processed:
            already_processed.add('DateTimeFormatReference')
            self.DateTimeFormatReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
        elif nodeName_ == 'SubItemCollection':
            obj_ = SubItemCollection.factory()
            obj_.build(child_)
            self.SubItemCollection = obj_
            obj_.original_tagname_ = 'SubItemCollection'
# end class CIStyle


class Connection(GeneratedsSuper):
    """A connection, which is defined as a group of one or more links
    between two ends.Connection ID (see IdReferenceLinking)."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, ConnectionStyle=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ConnectionStyle = ConnectionStyle
    def factory(*args_, **kwargs_):
        if Connection.subclass:
            return Connection.subclass(*args_, **kwargs_)
        else:
            return Connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConnectionStyle(self): return self.ConnectionStyle
    def set_ConnectionStyle(self, ConnectionStyle): self.ConnectionStyle = ConnectionStyle
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ConnectionStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Connection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Connection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Connection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Connection'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Connection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConnectionStyle is not None:
            self.ConnectionStyle.export(outfile, level, namespace_, name_='ConnectionStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Connection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConnectionStyle is not None:
            showIndent(outfile, level)
            outfile.write('ConnectionStyle=model_.ConnectionStyle(\n')
            self.ConnectionStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConnectionStyle':
            obj_ = ConnectionStyle.factory()
            obj_.build(child_)
            self.ConnectionStyle = obj_
            obj_.original_tagname_ = 'ConnectionStyle'
# end class Connection


class ConnectionCollection(GeneratedsSuper):
    """Collection of connections on the chart."""
    subclass = None
    superclass = None
    def __init__(self, Connection=None):
        self.original_tagname_ = None
        if Connection is None:
            self.Connection = []
        else:
            self.Connection = Connection
    def factory(*args_, **kwargs_):
        if ConnectionCollection.subclass:
            return ConnectionCollection.subclass(*args_, **kwargs_)
        else:
            return ConnectionCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def add_Connection(self, value): self.Connection.append(value)
    def insert_Connection(self, index, value): self.Connection[index] = value
    def hasContent_(self):
        if (
            self.Connection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConnectionCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConnectionCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Connection_ in self.Connection:
            Connection_.export(outfile, level, namespace_, name_='Connection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConnectionCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Connection=[\n')
        level += 1
        for Connection_ in self.Connection:
            showIndent(outfile, level)
            outfile.write('model_.Connection(\n')
            Connection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Connection':
            obj_ = Connection.factory()
            obj_.build(child_)
            self.Connection.append(obj_)
            obj_.original_tagname_ = 'Connection'
# end class ConnectionCollection


class ConnectionStyle(GeneratedsSuper):
    """Style of the connection.Fanout applied to multiple links in this
    connection. Expressed in world coordinates.Style to use when
    there are multiple links in the connection.Theme line wiring
    style used after a junction created by this connection between a
    theme line and an event frame. This style is retained until the
    next junction to the right that alters the theme line wiring."""
    subclass = None
    superclass = None
    def __init__(self, Multiplicity=None, ThemeWiring=None, FanOut=None):
        self.original_tagname_ = None
        self.Multiplicity = _cast(None, Multiplicity)
        self.ThemeWiring = _cast(None, ThemeWiring)
        self.FanOut = _cast(int, FanOut)
    def factory(*args_, **kwargs_):
        if ConnectionStyle.subclass:
            return ConnectionStyle.subclass(*args_, **kwargs_)
        else:
            return ConnectionStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Multiplicity(self): return self.Multiplicity
    def set_Multiplicity(self, Multiplicity): self.Multiplicity = Multiplicity
    def get_ThemeWiring(self): return self.ThemeWiring
    def set_ThemeWiring(self, ThemeWiring): self.ThemeWiring = ThemeWiring
    def get_FanOut(self): return self.FanOut
    def set_FanOut(self, FanOut): self.FanOut = FanOut
    def validate_MultipleLinkStyleEnum(self, value):
        # Validate type MultipleLinkStyleEnum, a restriction on xsd:string.
        pass
    def validate_ThemeWiringOptionEnum(self, value):
        # Validate type ThemeWiringOptionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConnectionStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConnectionStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionStyle'):
        if self.Multiplicity is not None and 'Multiplicity' not in already_processed:
            already_processed.add('Multiplicity')
            outfile.write(' Multiplicity=%s' % (quote_attrib(self.Multiplicity), ))
        if self.ThemeWiring is not None and 'ThemeWiring' not in already_processed:
            already_processed.add('ThemeWiring')
            outfile.write(' ThemeWiring=%s' % (quote_attrib(self.ThemeWiring), ))
        if self.FanOut is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            outfile.write(' FanOut="%s"' % self.gds_format_integer(self.FanOut, input_name='FanOut'))
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ConnectionStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Multiplicity is not None and 'Multiplicity' not in already_processed:
            already_processed.add('Multiplicity')
            showIndent(outfile, level)
            outfile.write('Multiplicity="%s",\n' % (self.Multiplicity,))
        if self.ThemeWiring is not None and 'ThemeWiring' not in already_processed:
            already_processed.add('ThemeWiring')
            showIndent(outfile, level)
            outfile.write('ThemeWiring="%s",\n' % (self.ThemeWiring,))
        if self.FanOut is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            showIndent(outfile, level)
            outfile.write('FanOut=%d,\n' % (self.FanOut,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Multiplicity', node)
        if value is not None and 'Multiplicity' not in already_processed:
            already_processed.add('Multiplicity')
            self.Multiplicity = value
            self.validate_MultipleLinkStyleEnum(self.Multiplicity)    # validate type MultipleLinkStyleEnum
        value = find_attr_value_('ThemeWiring', node)
        if value is not None and 'ThemeWiring' not in already_processed:
            already_processed.add('ThemeWiring')
            self.ThemeWiring = value
            self.validate_ThemeWiringOptionEnum(self.ThemeWiring)    # validate type ThemeWiringOptionEnum
        value = find_attr_value_('FanOut', node)
        if value is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            try:
                self.FanOut = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConnectionStyle


class Corner(GeneratedsSuper):
    """Corner object on a connection.The IDREF of the corner's group.X
    position of the corner, expressed in world coordinates.Y
    position of the corner, expressed in world coordinates.Z
    position of the corner, expressed in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, Y=0, X=0, Z=0, GroupReference=None):
        self.original_tagname_ = None
        self.Y = _cast(int, Y)
        self.X = _cast(int, X)
        self.Z = _cast(int, Z)
        self.GroupReference = _cast(None, GroupReference)
    def factory(*args_, **kwargs_):
        if Corner.subclass:
            return Corner.subclass(*args_, **kwargs_)
        else:
            return Corner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def get_GroupReference(self): return self.GroupReference
    def set_GroupReference(self, GroupReference): self.GroupReference = GroupReference
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Corner', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Corner')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Corner', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Corner'):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            outfile.write(' Y="%s"' % self.gds_format_integer(self.Y, input_name='Y'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            outfile.write(' X="%s"' % self.gds_format_integer(self.X, input_name='X'))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            outfile.write(' Z="%s"' % self.gds_format_integer(self.Z, input_name='Z'))
        if self.GroupReference is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            outfile.write(' GroupReference=%s' % (self.gds_format_string(quote_attrib(self.GroupReference).encode(ExternalEncoding), input_name='GroupReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Corner', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Corner'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            showIndent(outfile, level)
            outfile.write('Y=%d,\n' % (self.Y,))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            showIndent(outfile, level)
            outfile.write('X=%d,\n' % (self.X,))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            showIndent(outfile, level)
            outfile.write('Z=%d,\n' % (self.Z,))
        if self.GroupReference is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            showIndent(outfile, level)
            outfile.write('GroupReference="%s",\n' % (self.GroupReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            try:
                self.Z = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GroupReference', node)
        if value is not None and 'GroupReference' not in already_processed:
            already_processed.add('GroupReference')
            self.GroupReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Corner


class CornerCollection(GeneratedsSuper):
    """Collection of corners within a connection."""
    subclass = None
    superclass = None
    def __init__(self, Corner=None):
        self.original_tagname_ = None
        if Corner is None:
            self.Corner = []
        else:
            self.Corner = Corner
    def factory(*args_, **kwargs_):
        if CornerCollection.subclass:
            return CornerCollection.subclass(*args_, **kwargs_)
        else:
            return CornerCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Corner(self): return self.Corner
    def set_Corner(self, Corner): self.Corner = Corner
    def add_Corner(self, value): self.Corner.append(value)
    def insert_Corner(self, index, value): self.Corner[index] = value
    def hasContent_(self):
        if (
            self.Corner
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CornerCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CornerCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CornerCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CornerCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CornerCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Corner_ in self.Corner:
            Corner_.export(outfile, level, namespace_, name_='Corner', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CornerCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Corner=[\n')
        level += 1
        for Corner_ in self.Corner:
            showIndent(outfile, level)
            outfile.write('model_.Corner(\n')
            Corner_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Corner':
            obj_ = Corner.factory()
            obj_.build(child_)
            self.Corner.append(obj_)
            obj_.original_tagname_ = 'Corner'
# end class CornerCollection


class CurrentBoxStyle(GeneratedsSuper):
    """Current box style, which is the default style used when creating new
    box items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, BoxStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.BoxStyle = BoxStyle
    def factory(*args_, **kwargs_):
        if CurrentBoxStyle.subclass:
            return CurrentBoxStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentBoxStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_BoxStyle(self): return self.BoxStyle
    def set_BoxStyle(self, BoxStyle): self.BoxStyle = BoxStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.BoxStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentBoxStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentBoxStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentBoxStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentBoxStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentBoxStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.BoxStyle is not None:
            self.BoxStyle.export(outfile, level, namespace_, name_='BoxStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentBoxStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BoxStyle is not None:
            showIndent(outfile, level)
            outfile.write('BoxStyle=model_.BoxStyle(\n')
            self.BoxStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'BoxStyle':
            obj_ = BoxStyle.factory()
            obj_.build(child_)
            self.BoxStyle = obj_
            obj_.original_tagname_ = 'BoxStyle'
# end class CurrentBoxStyle


class CurrentCircleStyle(GeneratedsSuper):
    """Current circle style, which is the default style used when creating
    new circle items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, CircleStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.CircleStyle = CircleStyle
    def factory(*args_, **kwargs_):
        if CurrentCircleStyle.subclass:
            return CurrentCircleStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentCircleStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_CircleStyle(self): return self.CircleStyle
    def set_CircleStyle(self, CircleStyle): self.CircleStyle = CircleStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.CircleStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentCircleStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentCircleStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentCircleStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentCircleStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentCircleStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.CircleStyle is not None:
            self.CircleStyle.export(outfile, level, namespace_, name_='CircleStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentCircleStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CircleStyle is not None:
            showIndent(outfile, level)
            outfile.write('CircleStyle=model_.CircleStyle(\n')
            self.CircleStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'CircleStyle':
            obj_ = CircleStyle.factory()
            obj_.build(child_)
            self.CircleStyle = obj_
            obj_.original_tagname_ = 'CircleStyle'
# end class CurrentCircleStyle


class CurrentEventStyle(GeneratedsSuper):
    """Current event frame style, which is the default style used when
    creating new event frame items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, EventStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.EventStyle = EventStyle
    def factory(*args_, **kwargs_):
        if CurrentEventStyle.subclass:
            return CurrentEventStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentEventStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_EventStyle(self): return self.EventStyle
    def set_EventStyle(self, EventStyle): self.EventStyle = EventStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.EventStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentEventStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentEventStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentEventStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentEventStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentEventStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.EventStyle is not None:
            self.EventStyle.export(outfile, level, namespace_, name_='EventStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentEventStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EventStyle is not None:
            showIndent(outfile, level)
            outfile.write('EventStyle=model_.EventStyle(\n')
            self.EventStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'EventStyle':
            obj_ = EventStyle.factory()
            obj_.build(child_)
            self.EventStyle = obj_
            obj_.original_tagname_ = 'EventStyle'
# end class CurrentEventStyle


class CurrentIconStyle(GeneratedsSuper):
    """Current icon style, which is the default style used when creating
    new icon items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, IconStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.IconStyle = IconStyle
    def factory(*args_, **kwargs_):
        if CurrentIconStyle.subclass:
            return CurrentIconStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentIconStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_IconStyle(self): return self.IconStyle
    def set_IconStyle(self, IconStyle): self.IconStyle = IconStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.IconStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentIconStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentIconStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentIconStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentIconStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentIconStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.IconStyle is not None:
            self.IconStyle.export(outfile, level, namespace_, name_='IconStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentIconStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IconStyle is not None:
            showIndent(outfile, level)
            outfile.write('IconStyle=model_.IconStyle(\n')
            self.IconStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'IconStyle':
            obj_ = IconStyle.factory()
            obj_.build(child_)
            self.IconStyle = obj_
            obj_.original_tagname_ = 'IconStyle'
# end class CurrentIconStyle


class CurrentLabelStyle(GeneratedsSuper):
    """Current label style, which is the default style used when creating
    new label items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, LabelStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.LabelStyle = LabelStyle
    def factory(*args_, **kwargs_):
        if CurrentLabelStyle.subclass:
            return CurrentLabelStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentLabelStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_LabelStyle(self): return self.LabelStyle
    def set_LabelStyle(self, LabelStyle): self.LabelStyle = LabelStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.LabelStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentLabelStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentLabelStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentLabelStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentLabelStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentLabelStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.LabelStyle is not None:
            self.LabelStyle.export(outfile, level, namespace_, name_='LabelStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentLabelStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LabelStyle is not None:
            showIndent(outfile, level)
            outfile.write('LabelStyle=model_.LabelStyle(\n')
            self.LabelStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'LabelStyle':
            obj_ = LabelStyle.factory()
            obj_.build(child_)
            self.LabelStyle = obj_
            obj_.original_tagname_ = 'LabelStyle'
# end class CurrentLabelStyle


class CurrentLinkStyle(GeneratedsSuper):
    """Current link style, which is the default style used when creating
    new link items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, LinkStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.LinkStyle = LinkStyle
    def factory(*args_, **kwargs_):
        if CurrentLinkStyle.subclass:
            return CurrentLinkStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentLinkStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_LinkStyle(self): return self.LinkStyle
    def set_LinkStyle(self, LinkStyle): self.LinkStyle = LinkStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.LinkStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentLinkStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentLinkStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentLinkStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentLinkStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentLinkStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.LinkStyle is not None:
            self.LinkStyle.export(outfile, level, namespace_, name_='LinkStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentLinkStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinkStyle is not None:
            showIndent(outfile, level)
            outfile.write('LinkStyle=model_.LinkStyle(\n')
            self.LinkStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'LinkStyle':
            obj_ = LinkStyle.factory()
            obj_.build(child_)
            self.LinkStyle = obj_
            obj_.original_tagname_ = 'LinkStyle'
# end class CurrentLinkStyle


class CurrentOleItemStyle(GeneratedsSuper):
    """Current OLE object style, which is the default style used when
    creating new OLE objects."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, OleItemStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.OleItemStyle = OleItemStyle
    def factory(*args_, **kwargs_):
        if CurrentOleItemStyle.subclass:
            return CurrentOleItemStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentOleItemStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_OleItemStyle(self): return self.OleItemStyle
    def set_OleItemStyle(self, OleItemStyle): self.OleItemStyle = OleItemStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.OleItemStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentOleItemStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentOleItemStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentOleItemStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentOleItemStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentOleItemStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.OleItemStyle is not None:
            self.OleItemStyle.export(outfile, level, namespace_, name_='OleItemStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentOleItemStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OleItemStyle is not None:
            showIndent(outfile, level)
            outfile.write('OleItemStyle=model_.OleItemStyle(\n')
            self.OleItemStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'OleItemStyle':
            obj_ = OleItemStyle.factory()
            obj_.build(child_)
            self.OleItemStyle = obj_
            obj_.original_tagname_ = 'OleItemStyle'
# end class CurrentOleItemStyle


class CurrentStyleCollection(GeneratedsSuper):
    """Collection of current chart item styles for the chart."""
    subclass = None
    superclass = None
    def __init__(self, ConnectionStyle=None, CurrentBoxStyle=None, CurrentCircleStyle=None, CurrentEventStyle=None, CurrentIconStyle=None, CurrentLabelStyle=None, CurrentLinkStyle=None, CurrentOleItemStyle=None, CurrentTextBlockStyle=None, CurrentThemeStyle=None):
        self.original_tagname_ = None
        self.ConnectionStyle = ConnectionStyle
        self.CurrentBoxStyle = CurrentBoxStyle
        self.CurrentCircleStyle = CurrentCircleStyle
        self.CurrentEventStyle = CurrentEventStyle
        self.CurrentIconStyle = CurrentIconStyle
        self.CurrentLabelStyle = CurrentLabelStyle
        self.CurrentLinkStyle = CurrentLinkStyle
        self.CurrentOleItemStyle = CurrentOleItemStyle
        self.CurrentTextBlockStyle = CurrentTextBlockStyle
        self.CurrentThemeStyle = CurrentThemeStyle
    def factory(*args_, **kwargs_):
        if CurrentStyleCollection.subclass:
            return CurrentStyleCollection.subclass(*args_, **kwargs_)
        else:
            return CurrentStyleCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConnectionStyle(self): return self.ConnectionStyle
    def set_ConnectionStyle(self, ConnectionStyle): self.ConnectionStyle = ConnectionStyle
    def get_CurrentBoxStyle(self): return self.CurrentBoxStyle
    def set_CurrentBoxStyle(self, CurrentBoxStyle): self.CurrentBoxStyle = CurrentBoxStyle
    def get_CurrentCircleStyle(self): return self.CurrentCircleStyle
    def set_CurrentCircleStyle(self, CurrentCircleStyle): self.CurrentCircleStyle = CurrentCircleStyle
    def get_CurrentEventStyle(self): return self.CurrentEventStyle
    def set_CurrentEventStyle(self, CurrentEventStyle): self.CurrentEventStyle = CurrentEventStyle
    def get_CurrentIconStyle(self): return self.CurrentIconStyle
    def set_CurrentIconStyle(self, CurrentIconStyle): self.CurrentIconStyle = CurrentIconStyle
    def get_CurrentLabelStyle(self): return self.CurrentLabelStyle
    def set_CurrentLabelStyle(self, CurrentLabelStyle): self.CurrentLabelStyle = CurrentLabelStyle
    def get_CurrentLinkStyle(self): return self.CurrentLinkStyle
    def set_CurrentLinkStyle(self, CurrentLinkStyle): self.CurrentLinkStyle = CurrentLinkStyle
    def get_CurrentOleItemStyle(self): return self.CurrentOleItemStyle
    def set_CurrentOleItemStyle(self, CurrentOleItemStyle): self.CurrentOleItemStyle = CurrentOleItemStyle
    def get_CurrentTextBlockStyle(self): return self.CurrentTextBlockStyle
    def set_CurrentTextBlockStyle(self, CurrentTextBlockStyle): self.CurrentTextBlockStyle = CurrentTextBlockStyle
    def get_CurrentThemeStyle(self): return self.CurrentThemeStyle
    def set_CurrentThemeStyle(self, CurrentThemeStyle): self.CurrentThemeStyle = CurrentThemeStyle
    def hasContent_(self):
        if (
            self.ConnectionStyle is not None or
            self.CurrentBoxStyle is not None or
            self.CurrentCircleStyle is not None or
            self.CurrentEventStyle is not None or
            self.CurrentIconStyle is not None or
            self.CurrentLabelStyle is not None or
            self.CurrentLinkStyle is not None or
            self.CurrentOleItemStyle is not None or
            self.CurrentTextBlockStyle is not None or
            self.CurrentThemeStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentStyleCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentStyleCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentStyleCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentStyleCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentStyleCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConnectionStyle is not None:
            self.ConnectionStyle.export(outfile, level, namespace_, name_='ConnectionStyle', pretty_print=pretty_print)
        if self.CurrentBoxStyle is not None:
            self.CurrentBoxStyle.export(outfile, level, namespace_, name_='CurrentBoxStyle', pretty_print=pretty_print)
        if self.CurrentCircleStyle is not None:
            self.CurrentCircleStyle.export(outfile, level, namespace_, name_='CurrentCircleStyle', pretty_print=pretty_print)
        if self.CurrentEventStyle is not None:
            self.CurrentEventStyle.export(outfile, level, namespace_, name_='CurrentEventStyle', pretty_print=pretty_print)
        if self.CurrentIconStyle is not None:
            self.CurrentIconStyle.export(outfile, level, namespace_, name_='CurrentIconStyle', pretty_print=pretty_print)
        if self.CurrentLabelStyle is not None:
            self.CurrentLabelStyle.export(outfile, level, namespace_, name_='CurrentLabelStyle', pretty_print=pretty_print)
        if self.CurrentLinkStyle is not None:
            self.CurrentLinkStyle.export(outfile, level, namespace_, name_='CurrentLinkStyle', pretty_print=pretty_print)
        if self.CurrentOleItemStyle is not None:
            self.CurrentOleItemStyle.export(outfile, level, namespace_, name_='CurrentOleItemStyle', pretty_print=pretty_print)
        if self.CurrentTextBlockStyle is not None:
            self.CurrentTextBlockStyle.export(outfile, level, namespace_, name_='CurrentTextBlockStyle', pretty_print=pretty_print)
        if self.CurrentThemeStyle is not None:
            self.CurrentThemeStyle.export(outfile, level, namespace_, name_='CurrentThemeStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentStyleCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConnectionStyle is not None:
            showIndent(outfile, level)
            outfile.write('ConnectionStyle=model_.ConnectionStyle(\n')
            self.ConnectionStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentBoxStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentBoxStyle=model_.CurrentBoxStyle(\n')
            self.CurrentBoxStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentCircleStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentCircleStyle=model_.CurrentCircleStyle(\n')
            self.CurrentCircleStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentEventStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentEventStyle=model_.CurrentEventStyle(\n')
            self.CurrentEventStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentIconStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentIconStyle=model_.CurrentIconStyle(\n')
            self.CurrentIconStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentLabelStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentLabelStyle=model_.CurrentLabelStyle(\n')
            self.CurrentLabelStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentLinkStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentLinkStyle=model_.CurrentLinkStyle(\n')
            self.CurrentLinkStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentOleItemStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentOleItemStyle=model_.CurrentOleItemStyle(\n')
            self.CurrentOleItemStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentTextBlockStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentTextBlockStyle=model_.CurrentTextBlockStyle(\n')
            self.CurrentTextBlockStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentThemeStyle is not None:
            showIndent(outfile, level)
            outfile.write('CurrentThemeStyle=model_.CurrentThemeStyle(\n')
            self.CurrentThemeStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConnectionStyle':
            obj_ = ConnectionStyle.factory()
            obj_.build(child_)
            self.ConnectionStyle = obj_
            obj_.original_tagname_ = 'ConnectionStyle'
        elif nodeName_ == 'CurrentBoxStyle':
            obj_ = CurrentBoxStyle.factory()
            obj_.build(child_)
            self.CurrentBoxStyle = obj_
            obj_.original_tagname_ = 'CurrentBoxStyle'
        elif nodeName_ == 'CurrentCircleStyle':
            obj_ = CurrentCircleStyle.factory()
            obj_.build(child_)
            self.CurrentCircleStyle = obj_
            obj_.original_tagname_ = 'CurrentCircleStyle'
        elif nodeName_ == 'CurrentEventStyle':
            obj_ = CurrentEventStyle.factory()
            obj_.build(child_)
            self.CurrentEventStyle = obj_
            obj_.original_tagname_ = 'CurrentEventStyle'
        elif nodeName_ == 'CurrentIconStyle':
            obj_ = CurrentIconStyle.factory()
            obj_.build(child_)
            self.CurrentIconStyle = obj_
            obj_.original_tagname_ = 'CurrentIconStyle'
        elif nodeName_ == 'CurrentLabelStyle':
            obj_ = CurrentLabelStyle.factory()
            obj_.build(child_)
            self.CurrentLabelStyle = obj_
            obj_.original_tagname_ = 'CurrentLabelStyle'
        elif nodeName_ == 'CurrentLinkStyle':
            obj_ = CurrentLinkStyle.factory()
            obj_.build(child_)
            self.CurrentLinkStyle = obj_
            obj_.original_tagname_ = 'CurrentLinkStyle'
        elif nodeName_ == 'CurrentOleItemStyle':
            obj_ = CurrentOleItemStyle.factory()
            obj_.build(child_)
            self.CurrentOleItemStyle = obj_
            obj_.original_tagname_ = 'CurrentOleItemStyle'
        elif nodeName_ == 'CurrentTextBlockStyle':
            obj_ = CurrentTextBlockStyle.factory()
            obj_.build(child_)
            self.CurrentTextBlockStyle = obj_
            obj_.original_tagname_ = 'CurrentTextBlockStyle'
        elif nodeName_ == 'CurrentThemeStyle':
            obj_ = CurrentThemeStyle.factory()
            obj_.build(child_)
            self.CurrentThemeStyle = obj_
            obj_.original_tagname_ = 'CurrentThemeStyle'
# end class CurrentStyleCollection


class CurrentTextBlockStyle(GeneratedsSuper):
    """Current text block style, which is the default style used when
    creating new text block items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, TextBlockStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.TextBlockStyle = TextBlockStyle
    def factory(*args_, **kwargs_):
        if CurrentTextBlockStyle.subclass:
            return CurrentTextBlockStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentTextBlockStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_TextBlockStyle(self): return self.TextBlockStyle
    def set_TextBlockStyle(self, TextBlockStyle): self.TextBlockStyle = TextBlockStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.TextBlockStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentTextBlockStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentTextBlockStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentTextBlockStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentTextBlockStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentTextBlockStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.TextBlockStyle is not None:
            self.TextBlockStyle.export(outfile, level, namespace_, name_='TextBlockStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentTextBlockStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextBlockStyle is not None:
            showIndent(outfile, level)
            outfile.write('TextBlockStyle=model_.TextBlockStyle(\n')
            self.TextBlockStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'TextBlockStyle':
            obj_ = TextBlockStyle.factory()
            obj_.build(child_)
            self.TextBlockStyle = obj_
            obj_.original_tagname_ = 'TextBlockStyle'
# end class CurrentTextBlockStyle


class CurrentThemeStyle(GeneratedsSuper):
    """Current text block style, which is the default style used when
    creating new text block items."""
    subclass = None
    superclass = None
    def __init__(self, CIStyle=None, ThemeStyle=None):
        self.original_tagname_ = None
        self.CIStyle = CIStyle
        self.ThemeStyle = ThemeStyle
    def factory(*args_, **kwargs_):
        if CurrentThemeStyle.subclass:
            return CurrentThemeStyle.subclass(*args_, **kwargs_)
        else:
            return CurrentThemeStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIStyle(self): return self.CIStyle
    def set_CIStyle(self, CIStyle): self.CIStyle = CIStyle
    def get_ThemeStyle(self): return self.ThemeStyle
    def set_ThemeStyle(self, ThemeStyle): self.ThemeStyle = ThemeStyle
    def hasContent_(self):
        if (
            self.CIStyle is not None or
            self.ThemeStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentThemeStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentThemeStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentThemeStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentThemeStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentThemeStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIStyle is not None:
            self.CIStyle.export(outfile, level, namespace_, name_='CIStyle', pretty_print=pretty_print)
        if self.ThemeStyle is not None:
            self.ThemeStyle.export(outfile, level, namespace_, name_='ThemeStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentThemeStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIStyle is not None:
            showIndent(outfile, level)
            outfile.write('CIStyle=model_.CIStyle(\n')
            self.CIStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThemeStyle is not None:
            showIndent(outfile, level)
            outfile.write('ThemeStyle=model_.ThemeStyle(\n')
            self.ThemeStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIStyle':
            obj_ = CIStyle.factory()
            obj_.build(child_)
            self.CIStyle = obj_
            obj_.original_tagname_ = 'CIStyle'
        elif nodeName_ == 'ThemeStyle':
            obj_ = ThemeStyle.factory()
            obj_.build(child_)
            self.ThemeStyle = obj_
            obj_.original_tagname_ = 'ThemeStyle'
# end class CurrentThemeStyle


class CustomProperty(GeneratedsSuper):
    """A custom chart property"""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, Value=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.Name = _cast(None, Name)
        self.Value = _cast(None, Value)
    def factory(*args_, **kwargs_):
        if CustomProperty.subclass:
            return CustomProperty.subclass(*args_, **kwargs_)
        else:
            return CustomProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_CustomPropertyTypeEnum(self, value):
        # Validate type CustomPropertyTypeEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomProperty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomProperty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomProperty'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(' Value=%s' % (self.gds_format_string(quote_attrib(self.Value).encode(ExternalEncoding), input_name='Value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomProperty', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CustomProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            showIndent(outfile, level)
            outfile.write('Value="%s",\n' % (self.Value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_CustomPropertyTypeEnum(self.Type)    # validate type CustomPropertyTypeEnum
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CustomProperty


class CustomPropertyCollection(GeneratedsSuper):
    """Collection of custom properties for the chart"""
    subclass = None
    superclass = None
    def __init__(self, CustomProperty=None):
        self.original_tagname_ = None
        if CustomProperty is None:
            self.CustomProperty = []
        else:
            self.CustomProperty = CustomProperty
    def factory(*args_, **kwargs_):
        if CustomPropertyCollection.subclass:
            return CustomPropertyCollection.subclass(*args_, **kwargs_)
        else:
            return CustomPropertyCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomProperty(self): return self.CustomProperty
    def set_CustomProperty(self, CustomProperty): self.CustomProperty = CustomProperty
    def add_CustomProperty(self, value): self.CustomProperty.append(value)
    def insert_CustomProperty(self, index, value): self.CustomProperty[index] = value
    def hasContent_(self):
        if (
            self.CustomProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomPropertyCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomPropertyCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomPropertyCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomPropertyCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomPropertyCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomProperty_ in self.CustomProperty:
            CustomProperty_.export(outfile, level, namespace_, name_='CustomProperty', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomPropertyCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustomProperty=[\n')
        level += 1
        for CustomProperty_ in self.CustomProperty:
            showIndent(outfile, level)
            outfile.write('model_.CustomProperty(\n')
            CustomProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomProperty':
            obj_ = CustomProperty.factory()
            obj_.build(child_)
            self.CustomProperty.append(obj_)
            obj_.original_tagname_ = 'CustomProperty'
# end class CustomPropertyCollection


class DatabaseKey(GeneratedsSuper):
    """Database key object for a specific entity or link object proxy.Proxy
    object for an entity object or a link object.Proxy object IDREF
    for an entity object or a link object.ClassID of database proxy
    to which this database key belongs.InstanceName of database
    proxy to which this database key belongs.Database proxy IDREF to
    which this database key belongs."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseObject=None, DatabaseProxyInstanceName=None, DatabaseProxyClassID=None, DatabaseObjectProxyReference=None, DatabaseProxyReference=None, Key=None, DatabasePropertyCollection=None):
        self.original_tagname_ = None
        self.DatabaseObject = _cast(None, DatabaseObject)
        self.DatabaseProxyInstanceName = _cast(None, DatabaseProxyInstanceName)
        self.DatabaseProxyClassID = _cast(None, DatabaseProxyClassID)
        self.DatabaseObjectProxyReference = _cast(None, DatabaseObjectProxyReference)
        self.DatabaseProxyReference = _cast(None, DatabaseProxyReference)
        if Key is None:
            self.Key = []
        else:
            self.Key = Key
        self.DatabasePropertyCollection = DatabasePropertyCollection
    def factory(*args_, **kwargs_):
        if DatabaseKey.subclass:
            return DatabaseKey.subclass(*args_, **kwargs_)
        else:
            return DatabaseKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def add_Key(self, value): self.Key.append(value)
    def insert_Key(self, index, value): self.Key[index] = value
    def get_DatabasePropertyCollection(self): return self.DatabasePropertyCollection
    def set_DatabasePropertyCollection(self, DatabasePropertyCollection): self.DatabasePropertyCollection = DatabasePropertyCollection
    def get_DatabaseObject(self): return self.DatabaseObject
    def set_DatabaseObject(self, DatabaseObject): self.DatabaseObject = DatabaseObject
    def get_DatabaseProxyInstanceName(self): return self.DatabaseProxyInstanceName
    def set_DatabaseProxyInstanceName(self, DatabaseProxyInstanceName): self.DatabaseProxyInstanceName = DatabaseProxyInstanceName
    def get_DatabaseProxyClassID(self): return self.DatabaseProxyClassID
    def set_DatabaseProxyClassID(self, DatabaseProxyClassID): self.DatabaseProxyClassID = DatabaseProxyClassID
    def get_DatabaseObjectProxyReference(self): return self.DatabaseObjectProxyReference
    def set_DatabaseObjectProxyReference(self, DatabaseObjectProxyReference): self.DatabaseObjectProxyReference = DatabaseObjectProxyReference
    def get_DatabaseProxyReference(self): return self.DatabaseProxyReference
    def set_DatabaseProxyReference(self, DatabaseProxyReference): self.DatabaseProxyReference = DatabaseProxyReference
    def hasContent_(self):
        if (
            self.Key or
            self.DatabasePropertyCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseKey', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseKey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseKey', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseKey'):
        if self.DatabaseObject is not None and 'DatabaseObject' not in already_processed:
            already_processed.add('DatabaseObject')
            outfile.write(' DatabaseObject=%s' % (self.gds_format_string(quote_attrib(self.DatabaseObject).encode(ExternalEncoding), input_name='DatabaseObject'), ))
        if self.DatabaseProxyInstanceName is not None and 'DatabaseProxyInstanceName' not in already_processed:
            already_processed.add('DatabaseProxyInstanceName')
            outfile.write(' DatabaseProxyInstanceName=%s' % (self.gds_format_string(quote_attrib(self.DatabaseProxyInstanceName).encode(ExternalEncoding), input_name='DatabaseProxyInstanceName'), ))
        if self.DatabaseProxyClassID is not None and 'DatabaseProxyClassID' not in already_processed:
            already_processed.add('DatabaseProxyClassID')
            outfile.write(' DatabaseProxyClassID=%s' % (self.gds_format_string(quote_attrib(self.DatabaseProxyClassID).encode(ExternalEncoding), input_name='DatabaseProxyClassID'), ))
        if self.DatabaseObjectProxyReference is not None and 'DatabaseObjectProxyReference' not in already_processed:
            already_processed.add('DatabaseObjectProxyReference')
            outfile.write(' DatabaseObjectProxyReference=%s' % (self.gds_format_string(quote_attrib(self.DatabaseObjectProxyReference).encode(ExternalEncoding), input_name='DatabaseObjectProxyReference'), ))
        if self.DatabaseProxyReference is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            outfile.write(' DatabaseProxyReference=%s' % (self.gds_format_string(quote_attrib(self.DatabaseProxyReference).encode(ExternalEncoding), input_name='DatabaseProxyReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseKey', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Key_ in self.Key:
            Key_.export(outfile, level, namespace_, name_='Key', pretty_print=pretty_print)
        if self.DatabasePropertyCollection is not None:
            self.DatabasePropertyCollection.export(outfile, level, namespace_, name_='DatabasePropertyCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabaseKey'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DatabaseObject is not None and 'DatabaseObject' not in already_processed:
            already_processed.add('DatabaseObject')
            showIndent(outfile, level)
            outfile.write('DatabaseObject="%s",\n' % (self.DatabaseObject,))
        if self.DatabaseProxyInstanceName is not None and 'DatabaseProxyInstanceName' not in already_processed:
            already_processed.add('DatabaseProxyInstanceName')
            showIndent(outfile, level)
            outfile.write('DatabaseProxyInstanceName="%s",\n' % (self.DatabaseProxyInstanceName,))
        if self.DatabaseProxyClassID is not None and 'DatabaseProxyClassID' not in already_processed:
            already_processed.add('DatabaseProxyClassID')
            showIndent(outfile, level)
            outfile.write('DatabaseProxyClassID="%s",\n' % (self.DatabaseProxyClassID,))
        if self.DatabaseObjectProxyReference is not None and 'DatabaseObjectProxyReference' not in already_processed:
            already_processed.add('DatabaseObjectProxyReference')
            showIndent(outfile, level)
            outfile.write('DatabaseObjectProxyReference="%s",\n' % (self.DatabaseObjectProxyReference,))
        if self.DatabaseProxyReference is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            showIndent(outfile, level)
            outfile.write('DatabaseProxyReference="%s",\n' % (self.DatabaseProxyReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Key=[\n')
        level += 1
        for Key_ in self.Key:
            showIndent(outfile, level)
            outfile.write('model_.Key(\n')
            Key_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DatabasePropertyCollection is not None:
            showIndent(outfile, level)
            outfile.write('DatabasePropertyCollection=model_.DatabasePropertyCollection(\n')
            self.DatabasePropertyCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DatabaseObject', node)
        if value is not None and 'DatabaseObject' not in already_processed:
            already_processed.add('DatabaseObject')
            self.DatabaseObject = value
        value = find_attr_value_('DatabaseProxyInstanceName', node)
        if value is not None and 'DatabaseProxyInstanceName' not in already_processed:
            already_processed.add('DatabaseProxyInstanceName')
            self.DatabaseProxyInstanceName = value
        value = find_attr_value_('DatabaseProxyClassID', node)
        if value is not None and 'DatabaseProxyClassID' not in already_processed:
            already_processed.add('DatabaseProxyClassID')
            self.DatabaseProxyClassID = value
        value = find_attr_value_('DatabaseObjectProxyReference', node)
        if value is not None and 'DatabaseObjectProxyReference' not in already_processed:
            already_processed.add('DatabaseObjectProxyReference')
            self.DatabaseObjectProxyReference = value
        value = find_attr_value_('DatabaseProxyReference', node)
        if value is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            self.DatabaseProxyReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Key':
            obj_ = Key.factory()
            obj_.build(child_)
            self.Key.append(obj_)
            obj_.original_tagname_ = 'Key'
        elif nodeName_ == 'DatabasePropertyCollection':
            obj_ = DatabasePropertyCollection.factory()
            obj_.build(child_)
            self.DatabasePropertyCollection = obj_
            obj_.original_tagname_ = 'DatabasePropertyCollection'
# end class DatabaseKey


class DatabaseKeyCollection(GeneratedsSuper):
    """Collection of database keys on an entity or link."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseKey=None):
        self.original_tagname_ = None
        if DatabaseKey is None:
            self.DatabaseKey = []
        else:
            self.DatabaseKey = DatabaseKey
    def factory(*args_, **kwargs_):
        if DatabaseKeyCollection.subclass:
            return DatabaseKeyCollection.subclass(*args_, **kwargs_)
        else:
            return DatabaseKeyCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseKey(self): return self.DatabaseKey
    def set_DatabaseKey(self, DatabaseKey): self.DatabaseKey = DatabaseKey
    def add_DatabaseKey(self, value): self.DatabaseKey.append(value)
    def insert_DatabaseKey(self, index, value): self.DatabaseKey[index] = value
    def hasContent_(self):
        if (
            self.DatabaseKey
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseKeyCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseKeyCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseKeyCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseKeyCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseKeyCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabaseKey_ in self.DatabaseKey:
            DatabaseKey_.export(outfile, level, namespace_, name_='DatabaseKey', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabaseKeyCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabaseKey=[\n')
        level += 1
        for DatabaseKey_ in self.DatabaseKey:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseKey(\n')
            DatabaseKey_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseKey':
            obj_ = DatabaseKey.factory()
            obj_.build(child_)
            self.DatabaseKey.append(obj_)
            obj_.original_tagname_ = 'DatabaseKey'
# end class DatabaseKeyCollection


class DatabaseObjectProxy(GeneratedsSuper):
    """Proxy object for an entity object or a link object.Object IDREF that
    provides an interface to a connected database.Database object
    proxy ID (see IdReferenceLinking).Name of this database object
    proxy.Database proxy to which this database object proxy
    belongs.Internal chart type of this database object proxy, which
    is either LNEntityType or LNLinkType. Check this to ensure it is
    compatible with the type of database-object proxy supporting the
    interface.Internal chart type IDREF of this database object
    proxy, which is either LNEntityType or LNLinkType. Check this to
    ensure it is compatible with the type of database-object proxy
    supporting the interface.The semantic type assigned to this
    database object proxy."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, SemanticTypeGuid=None, PreferredTypeReference=None, PreferredType=None, ParentProxy=None, Id=None, DatabaseProxyReference=None, DatabasePropertyTypeCollection=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.PreferredTypeReference = _cast(None, PreferredTypeReference)
        self.PreferredType = _cast(None, PreferredType)
        self.ParentProxy = _cast(None, ParentProxy)
        self.Id = _cast(None, Id)
        self.DatabaseProxyReference = _cast(None, DatabaseProxyReference)
        self.DatabasePropertyTypeCollection = DatabasePropertyTypeCollection
    def factory(*args_, **kwargs_):
        if DatabaseObjectProxy.subclass:
            return DatabaseObjectProxy.subclass(*args_, **kwargs_)
        else:
            return DatabaseObjectProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabasePropertyTypeCollection(self): return self.DatabasePropertyTypeCollection
    def set_DatabasePropertyTypeCollection(self, DatabasePropertyTypeCollection): self.DatabasePropertyTypeCollection = DatabasePropertyTypeCollection
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_PreferredTypeReference(self): return self.PreferredTypeReference
    def set_PreferredTypeReference(self, PreferredTypeReference): self.PreferredTypeReference = PreferredTypeReference
    def get_PreferredType(self): return self.PreferredType
    def set_PreferredType(self, PreferredType): self.PreferredType = PreferredType
    def get_ParentProxy(self): return self.ParentProxy
    def set_ParentProxy(self, ParentProxy): self.ParentProxy = ParentProxy
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_DatabaseProxyReference(self): return self.DatabaseProxyReference
    def set_DatabaseProxyReference(self, DatabaseProxyReference): self.DatabaseProxyReference = DatabaseProxyReference
    def hasContent_(self):
        if (
            self.DatabasePropertyTypeCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseObjectProxy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseObjectProxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseObjectProxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseObjectProxy'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.PreferredTypeReference is not None and 'PreferredTypeReference' not in already_processed:
            already_processed.add('PreferredTypeReference')
            outfile.write(' PreferredTypeReference=%s' % (self.gds_format_string(quote_attrib(self.PreferredTypeReference).encode(ExternalEncoding), input_name='PreferredTypeReference'), ))
        if self.PreferredType is not None and 'PreferredType' not in already_processed:
            already_processed.add('PreferredType')
            outfile.write(' PreferredType=%s' % (self.gds_format_string(quote_attrib(self.PreferredType).encode(ExternalEncoding), input_name='PreferredType'), ))
        if self.ParentProxy is not None and 'ParentProxy' not in already_processed:
            already_processed.add('ParentProxy')
            outfile.write(' ParentProxy=%s' % (self.gds_format_string(quote_attrib(self.ParentProxy).encode(ExternalEncoding), input_name='ParentProxy'), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.DatabaseProxyReference is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            outfile.write(' DatabaseProxyReference=%s' % (self.gds_format_string(quote_attrib(self.DatabaseProxyReference).encode(ExternalEncoding), input_name='DatabaseProxyReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseObjectProxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DatabasePropertyTypeCollection is not None:
            self.DatabasePropertyTypeCollection.export(outfile, level, namespace_, name_='DatabasePropertyTypeCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabaseObjectProxy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.PreferredTypeReference is not None and 'PreferredTypeReference' not in already_processed:
            already_processed.add('PreferredTypeReference')
            showIndent(outfile, level)
            outfile.write('PreferredTypeReference="%s",\n' % (self.PreferredTypeReference,))
        if self.PreferredType is not None and 'PreferredType' not in already_processed:
            already_processed.add('PreferredType')
            showIndent(outfile, level)
            outfile.write('PreferredType="%s",\n' % (self.PreferredType,))
        if self.ParentProxy is not None and 'ParentProxy' not in already_processed:
            already_processed.add('ParentProxy')
            showIndent(outfile, level)
            outfile.write('ParentProxy="%s",\n' % (self.ParentProxy,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.DatabaseProxyReference is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            showIndent(outfile, level)
            outfile.write('DatabaseProxyReference="%s",\n' % (self.DatabaseProxyReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DatabasePropertyTypeCollection is not None:
            showIndent(outfile, level)
            outfile.write('DatabasePropertyTypeCollection=model_.DatabasePropertyTypeCollection(\n')
            self.DatabasePropertyTypeCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('PreferredTypeReference', node)
        if value is not None and 'PreferredTypeReference' not in already_processed:
            already_processed.add('PreferredTypeReference')
            self.PreferredTypeReference = value
        value = find_attr_value_('PreferredType', node)
        if value is not None and 'PreferredType' not in already_processed:
            already_processed.add('PreferredType')
            self.PreferredType = value
        value = find_attr_value_('ParentProxy', node)
        if value is not None and 'ParentProxy' not in already_processed:
            already_processed.add('ParentProxy')
            self.ParentProxy = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('DatabaseProxyReference', node)
        if value is not None and 'DatabaseProxyReference' not in already_processed:
            already_processed.add('DatabaseProxyReference')
            self.DatabaseProxyReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabasePropertyTypeCollection':
            obj_ = DatabasePropertyTypeCollection.factory()
            obj_.build(child_)
            self.DatabasePropertyTypeCollection = obj_
            obj_.original_tagname_ = 'DatabasePropertyTypeCollection'
# end class DatabaseObjectProxy


class DatabaseProperty(GeneratedsSuper):
    """The object which represents a single database property.Database
    property type with which the database property is associated.
    Raises an error if the database property type is already
    assigned to another database property.Database property type
    IDREF with which the database property is associated. Raises an
    error if the database property type is already assigned to
    another database property.Offset from UTC of the chart item's
    local date and time.Value for the database property. Raises an
    error if the datatype of the value does not match the datatype
    of the database property type with which it is associated.Is the
    database property marked as Visible."""
    subclass = None
    superclass = None
    def __init__(self, LocalDateTimeOffset=None, Visible=None, DatabasePropertyTypeReference=None, DatabasePropertyType=None, Value=None):
        self.original_tagname_ = None
        self.LocalDateTimeOffset = _cast(int, LocalDateTimeOffset)
        self.Visible = _cast(bool, Visible)
        self.DatabasePropertyTypeReference = _cast(None, DatabasePropertyTypeReference)
        self.DatabasePropertyType = _cast(None, DatabasePropertyType)
        self.Value = _cast(None, Value)
    def factory(*args_, **kwargs_):
        if DatabaseProperty.subclass:
            return DatabaseProperty.subclass(*args_, **kwargs_)
        else:
            return DatabaseProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalDateTimeOffset(self): return self.LocalDateTimeOffset
    def set_LocalDateTimeOffset(self, LocalDateTimeOffset): self.LocalDateTimeOffset = LocalDateTimeOffset
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_DatabasePropertyTypeReference(self): return self.DatabasePropertyTypeReference
    def set_DatabasePropertyTypeReference(self, DatabasePropertyTypeReference): self.DatabasePropertyTypeReference = DatabasePropertyTypeReference
    def get_DatabasePropertyType(self): return self.DatabasePropertyType
    def set_DatabasePropertyType(self, DatabasePropertyType): self.DatabasePropertyType = DatabasePropertyType
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_AttributeValue(self, value):
        # Validate type AttributeValue, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseProperty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseProperty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseProperty'):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            outfile.write(' LocalDateTimeOffset="%s"' % self.gds_format_integer(self.LocalDateTimeOffset, input_name='LocalDateTimeOffset'))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.DatabasePropertyTypeReference is not None and 'DatabasePropertyTypeReference' not in already_processed:
            already_processed.add('DatabasePropertyTypeReference')
            outfile.write(' DatabasePropertyTypeReference=%s' % (self.gds_format_string(quote_attrib(self.DatabasePropertyTypeReference).encode(ExternalEncoding), input_name='DatabasePropertyTypeReference'), ))
        if self.DatabasePropertyType is not None and 'DatabasePropertyType' not in already_processed:
            already_processed.add('DatabasePropertyType')
            outfile.write(' DatabasePropertyType=%s' % (self.gds_format_string(quote_attrib(self.DatabasePropertyType).encode(ExternalEncoding), input_name='DatabasePropertyType'), ))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(' Value=%s' % (quote_attrib(self.Value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseProperty', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DatabaseProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LocalDateTimeOffset is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            showIndent(outfile, level)
            outfile.write('LocalDateTimeOffset=%d,\n' % (self.LocalDateTimeOffset,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.DatabasePropertyTypeReference is not None and 'DatabasePropertyTypeReference' not in already_processed:
            already_processed.add('DatabasePropertyTypeReference')
            showIndent(outfile, level)
            outfile.write('DatabasePropertyTypeReference="%s",\n' % (self.DatabasePropertyTypeReference,))
        if self.DatabasePropertyType is not None and 'DatabasePropertyType' not in already_processed:
            already_processed.add('DatabasePropertyType')
            showIndent(outfile, level)
            outfile.write('DatabasePropertyType="%s",\n' % (self.DatabasePropertyType,))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % (self.Value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LocalDateTimeOffset', node)
        if value is not None and 'LocalDateTimeOffset' not in already_processed:
            already_processed.add('LocalDateTimeOffset')
            try:
                self.LocalDateTimeOffset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DatabasePropertyTypeReference', node)
        if value is not None and 'DatabasePropertyTypeReference' not in already_processed:
            already_processed.add('DatabasePropertyTypeReference')
            self.DatabasePropertyTypeReference = value
        value = find_attr_value_('DatabasePropertyType', node)
        if value is not None and 'DatabasePropertyType' not in already_processed:
            already_processed.add('DatabasePropertyType')
            self.DatabasePropertyType = value
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value
            self.validate_AttributeValue(self.Value)    # validate type AttributeValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DatabaseProperty


class DatabasePropertyCollection(GeneratedsSuper):
    """Collection of database properties."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseProperty=None):
        self.original_tagname_ = None
        if DatabaseProperty is None:
            self.DatabaseProperty = []
        else:
            self.DatabaseProperty = DatabaseProperty
    def factory(*args_, **kwargs_):
        if DatabasePropertyCollection.subclass:
            return DatabasePropertyCollection.subclass(*args_, **kwargs_)
        else:
            return DatabasePropertyCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseProperty(self): return self.DatabaseProperty
    def set_DatabaseProperty(self, DatabaseProperty): self.DatabaseProperty = DatabaseProperty
    def add_DatabaseProperty(self, value): self.DatabaseProperty.append(value)
    def insert_DatabaseProperty(self, index, value): self.DatabaseProperty[index] = value
    def hasContent_(self):
        if (
            self.DatabaseProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabasePropertyCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabasePropertyCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabasePropertyCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabasePropertyCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabasePropertyCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabaseProperty_ in self.DatabaseProperty:
            DatabaseProperty_.export(outfile, level, namespace_, name_='DatabaseProperty', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabasePropertyCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabaseProperty=[\n')
        level += 1
        for DatabaseProperty_ in self.DatabaseProperty:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseProperty(\n')
            DatabaseProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseProperty':
            obj_ = DatabaseProperty.factory()
            obj_.build(child_)
            self.DatabaseProperty.append(obj_)
            obj_.original_tagname_ = 'DatabaseProperty'
# end class DatabasePropertyCollection


class DatabasePropertyType(GeneratedsSuper):
    """The object which represents a single database property type.The data
    form associated with the database property type.AttributeType
    enumeration value, which indicates the type of the database
    property type. Possible types are Flag, Text, Numeric or Date &
    Time.If True, a calendar date is associated with database
    properties of this type.Database property type ID (see
    IdReferenceLinking).Name of the property type.The property
    semantic type assigned to this database property type.If True, a
    time is associated with database properties of this type."""
    subclass = None
    superclass = None
    def __init__(self, DataFormGuid=None, TimeSet=None, DateSet=None, Name=None, DataType=None, SemanticTypeGuid=None, Id=None):
        self.original_tagname_ = None
        self.DataFormGuid = _cast(None, DataFormGuid)
        self.TimeSet = _cast(bool, TimeSet)
        self.DateSet = _cast(bool, DateSet)
        self.Name = _cast(None, Name)
        self.DataType = _cast(None, DataType)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.Id = _cast(None, Id)
    def factory(*args_, **kwargs_):
        if DatabasePropertyType.subclass:
            return DatabasePropertyType.subclass(*args_, **kwargs_)
        else:
            return DatabasePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataFormGuid(self): return self.DataFormGuid
    def set_DataFormGuid(self, DataFormGuid): self.DataFormGuid = DataFormGuid
    def get_TimeSet(self): return self.TimeSet
    def set_TimeSet(self, TimeSet): self.TimeSet = TimeSet
    def get_DateSet(self): return self.DateSet
    def set_DateSet(self, DateSet): self.DateSet = DateSet
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_AttributeTypeEnum(self, value):
        # Validate type AttributeTypeEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabasePropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabasePropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabasePropertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabasePropertyType'):
        if self.DataFormGuid is not None and 'DataFormGuid' not in already_processed:
            already_processed.add('DataFormGuid')
            outfile.write(' DataFormGuid=%s' % (quote_attrib(self.DataFormGuid), ))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            outfile.write(' TimeSet="%s"' % self.gds_format_boolean(self.TimeSet, input_name='TimeSet'))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            outfile.write(' DateSet="%s"' % self.gds_format_boolean(self.DateSet, input_name='DateSet'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            outfile.write(' DataType=%s' % (quote_attrib(self.DataType), ))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DatabasePropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DatabasePropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataFormGuid is not None and 'DataFormGuid' not in already_processed:
            already_processed.add('DataFormGuid')
            showIndent(outfile, level)
            outfile.write('DataFormGuid="%s",\n' % (self.DataFormGuid,))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            showIndent(outfile, level)
            outfile.write('TimeSet=%s,\n' % (self.TimeSet,))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            showIndent(outfile, level)
            outfile.write('DateSet=%s,\n' % (self.DateSet,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            showIndent(outfile, level)
            outfile.write('DataType="%s",\n' % (self.DataType,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataFormGuid', node)
        if value is not None and 'DataFormGuid' not in already_processed:
            already_processed.add('DataFormGuid')
            self.DataFormGuid = value
        value = find_attr_value_('TimeSet', node)
        if value is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            if value in ('true', '1'):
                self.TimeSet = True
            elif value in ('false', '0'):
                self.TimeSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateSet', node)
        if value is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            if value in ('true', '1'):
                self.DateSet = True
            elif value in ('false', '0'):
                self.DateSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('DataType', node)
        if value is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            self.DataType = value
            self.validate_AttributeTypeEnum(self.DataType)    # validate type AttributeTypeEnum
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DatabasePropertyType


class DatabasePropertyTypeCollection(GeneratedsSuper):
    """Collection of database property types."""
    subclass = None
    superclass = None
    def __init__(self, DatabasePropertyType=None):
        self.original_tagname_ = None
        if DatabasePropertyType is None:
            self.DatabasePropertyType = []
        else:
            self.DatabasePropertyType = DatabasePropertyType
    def factory(*args_, **kwargs_):
        if DatabasePropertyTypeCollection.subclass:
            return DatabasePropertyTypeCollection.subclass(*args_, **kwargs_)
        else:
            return DatabasePropertyTypeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabasePropertyType(self): return self.DatabasePropertyType
    def set_DatabasePropertyType(self, DatabasePropertyType): self.DatabasePropertyType = DatabasePropertyType
    def add_DatabasePropertyType(self, value): self.DatabasePropertyType.append(value)
    def insert_DatabasePropertyType(self, index, value): self.DatabasePropertyType[index] = value
    def hasContent_(self):
        if (
            self.DatabasePropertyType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabasePropertyTypeCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabasePropertyTypeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabasePropertyTypeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabasePropertyTypeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabasePropertyTypeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabasePropertyType_ in self.DatabasePropertyType:
            DatabasePropertyType_.export(outfile, level, namespace_, name_='DatabasePropertyType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabasePropertyTypeCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabasePropertyType=[\n')
        level += 1
        for DatabasePropertyType_ in self.DatabasePropertyType:
            showIndent(outfile, level)
            outfile.write('model_.DatabasePropertyType(\n')
            DatabasePropertyType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabasePropertyType':
            obj_ = DatabasePropertyType.factory()
            obj_.build(child_)
            self.DatabasePropertyType.append(obj_)
            obj_.original_tagname_ = 'DatabasePropertyType'
# end class DatabasePropertyTypeCollection


class DatabaseProxy(GeneratedsSuper):
    """Object that provides an interface to a connected database.Unique
    identifier, expressed as a GUID value, for the database proxy
    type within the chart.Unique name for the database proxy within
    the chart.String used to connect to this database, which for
    example, can be information qualifying when and how to make the
    connection. The string content is database-type
    dependent.Database proxy ID (see IdReferenceLinking).Name of
    this database proxy.A human readbale name of this database
    proxy.If True, chart items can have multiple keys associated
    with this proxy."""
    subclass = None
    superclass = None
    def __init__(self, ClassID=None, ConnectString=None, DisplayName=None, MultipleKeysEnabled=True, ClassName=None, InstanceName=None, Id=None, EntityObjects=None, LinkObjects=None):
        self.original_tagname_ = None
        self.ClassID = _cast(None, ClassID)
        self.ConnectString = _cast(None, ConnectString)
        self.DisplayName = _cast(None, DisplayName)
        self.MultipleKeysEnabled = _cast(bool, MultipleKeysEnabled)
        self.ClassName = _cast(None, ClassName)
        self.InstanceName = _cast(None, InstanceName)
        self.Id = _cast(None, Id)
        if EntityObjects is None:
            self.EntityObjects = []
        else:
            self.EntityObjects = EntityObjects
        if LinkObjects is None:
            self.LinkObjects = []
        else:
            self.LinkObjects = LinkObjects
    def factory(*args_, **kwargs_):
        if DatabaseProxy.subclass:
            return DatabaseProxy.subclass(*args_, **kwargs_)
        else:
            return DatabaseProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntityObjects(self): return self.EntityObjects
    def set_EntityObjects(self, EntityObjects): self.EntityObjects = EntityObjects
    def add_EntityObjects(self, value): self.EntityObjects.append(value)
    def insert_EntityObjects(self, index, value): self.EntityObjects[index] = value
    def get_LinkObjects(self): return self.LinkObjects
    def set_LinkObjects(self, LinkObjects): self.LinkObjects = LinkObjects
    def add_LinkObjects(self, value): self.LinkObjects.append(value)
    def insert_LinkObjects(self, index, value): self.LinkObjects[index] = value
    def get_ClassID(self): return self.ClassID
    def set_ClassID(self, ClassID): self.ClassID = ClassID
    def get_ConnectString(self): return self.ConnectString
    def set_ConnectString(self, ConnectString): self.ConnectString = ConnectString
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def get_MultipleKeysEnabled(self): return self.MultipleKeysEnabled
    def set_MultipleKeysEnabled(self, MultipleKeysEnabled): self.MultipleKeysEnabled = MultipleKeysEnabled
    def get_ClassName(self): return self.ClassName
    def set_ClassName(self, ClassName): self.ClassName = ClassName
    def get_InstanceName(self): return self.InstanceName
    def set_InstanceName(self, InstanceName): self.InstanceName = InstanceName
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.EntityObjects or
            self.LinkObjects
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseProxy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseProxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseProxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseProxy'):
        if self.ClassID is not None and 'ClassID' not in already_processed:
            already_processed.add('ClassID')
            outfile.write(' ClassID=%s' % (self.gds_format_string(quote_attrib(self.ClassID).encode(ExternalEncoding), input_name='ClassID'), ))
        if self.ConnectString is not None and 'ConnectString' not in already_processed:
            already_processed.add('ConnectString')
            outfile.write(' ConnectString=%s' % (self.gds_format_string(quote_attrib(self.ConnectString).encode(ExternalEncoding), input_name='ConnectString'), ))
        if self.DisplayName is not None and 'DisplayName' not in already_processed:
            already_processed.add('DisplayName')
            outfile.write(' DisplayName=%s' % (self.gds_format_string(quote_attrib(self.DisplayName).encode(ExternalEncoding), input_name='DisplayName'), ))
        if self.MultipleKeysEnabled is not None and 'MultipleKeysEnabled' not in already_processed:
            already_processed.add('MultipleKeysEnabled')
            outfile.write(' MultipleKeysEnabled="%s"' % self.gds_format_boolean(self.MultipleKeysEnabled, input_name='MultipleKeysEnabled'))
        if self.ClassName is not None and 'ClassName' not in already_processed:
            already_processed.add('ClassName')
            outfile.write(' ClassName=%s' % (self.gds_format_string(quote_attrib(self.ClassName).encode(ExternalEncoding), input_name='ClassName'), ))
        if self.InstanceName is not None and 'InstanceName' not in already_processed:
            already_processed.add('InstanceName')
            outfile.write(' InstanceName=%s' % (self.gds_format_string(quote_attrib(self.InstanceName).encode(ExternalEncoding), input_name='InstanceName'), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseProxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EntityObjects_ in self.EntityObjects:
            EntityObjects_.export(outfile, level, namespace_, name_='EntityObjects', pretty_print=pretty_print)
        for LinkObjects_ in self.LinkObjects:
            LinkObjects_.export(outfile, level, namespace_, name_='LinkObjects', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabaseProxy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ClassID is not None and 'ClassID' not in already_processed:
            already_processed.add('ClassID')
            showIndent(outfile, level)
            outfile.write('ClassID="%s",\n' % (self.ClassID,))
        if self.ConnectString is not None and 'ConnectString' not in already_processed:
            already_processed.add('ConnectString')
            showIndent(outfile, level)
            outfile.write('ConnectString="%s",\n' % (self.ConnectString,))
        if self.DisplayName is not None and 'DisplayName' not in already_processed:
            already_processed.add('DisplayName')
            showIndent(outfile, level)
            outfile.write('DisplayName="%s",\n' % (self.DisplayName,))
        if self.MultipleKeysEnabled is not None and 'MultipleKeysEnabled' not in already_processed:
            already_processed.add('MultipleKeysEnabled')
            showIndent(outfile, level)
            outfile.write('MultipleKeysEnabled=%s,\n' % (self.MultipleKeysEnabled,))
        if self.ClassName is not None and 'ClassName' not in already_processed:
            already_processed.add('ClassName')
            showIndent(outfile, level)
            outfile.write('ClassName="%s",\n' % (self.ClassName,))
        if self.InstanceName is not None and 'InstanceName' not in already_processed:
            already_processed.add('InstanceName')
            showIndent(outfile, level)
            outfile.write('InstanceName="%s",\n' % (self.InstanceName,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EntityObjects=[\n')
        level += 1
        for EntityObjects_ in self.EntityObjects:
            showIndent(outfile, level)
            outfile.write('model_.EntityObjects(\n')
            EntityObjects_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinkObjects=[\n')
        level += 1
        for LinkObjects_ in self.LinkObjects:
            showIndent(outfile, level)
            outfile.write('model_.LinkObjects(\n')
            LinkObjects_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ClassID', node)
        if value is not None and 'ClassID' not in already_processed:
            already_processed.add('ClassID')
            self.ClassID = value
        value = find_attr_value_('ConnectString', node)
        if value is not None and 'ConnectString' not in already_processed:
            already_processed.add('ConnectString')
            self.ConnectString = value
        value = find_attr_value_('DisplayName', node)
        if value is not None and 'DisplayName' not in already_processed:
            already_processed.add('DisplayName')
            self.DisplayName = value
        value = find_attr_value_('MultipleKeysEnabled', node)
        if value is not None and 'MultipleKeysEnabled' not in already_processed:
            already_processed.add('MultipleKeysEnabled')
            if value in ('true', '1'):
                self.MultipleKeysEnabled = True
            elif value in ('false', '0'):
                self.MultipleKeysEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ClassName', node)
        if value is not None and 'ClassName' not in already_processed:
            already_processed.add('ClassName')
            self.ClassName = value
        value = find_attr_value_('InstanceName', node)
        if value is not None and 'InstanceName' not in already_processed:
            already_processed.add('InstanceName')
            self.InstanceName = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntityObjects':
            obj_ = EntityObjects.factory()
            obj_.build(child_)
            self.EntityObjects.append(obj_)
            obj_.original_tagname_ = 'EntityObjects'
        elif nodeName_ == 'LinkObjects':
            obj_ = LinkObjects.factory()
            obj_.build(child_)
            self.LinkObjects.append(obj_)
            obj_.original_tagname_ = 'LinkObjects'
# end class DatabaseProxy


class DatabaseProxyCollection(GeneratedsSuper):
    """Collection of database proxies associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseProxy=None):
        self.original_tagname_ = None
        if DatabaseProxy is None:
            self.DatabaseProxy = []
        else:
            self.DatabaseProxy = DatabaseProxy
    def factory(*args_, **kwargs_):
        if DatabaseProxyCollection.subclass:
            return DatabaseProxyCollection.subclass(*args_, **kwargs_)
        else:
            return DatabaseProxyCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseProxy(self): return self.DatabaseProxy
    def set_DatabaseProxy(self, DatabaseProxy): self.DatabaseProxy = DatabaseProxy
    def add_DatabaseProxy(self, value): self.DatabaseProxy.append(value)
    def insert_DatabaseProxy(self, index, value): self.DatabaseProxy[index] = value
    def hasContent_(self):
        if (
            self.DatabaseProxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatabaseProxyCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseProxyCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatabaseProxyCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseProxyCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseProxyCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabaseProxy_ in self.DatabaseProxy:
            DatabaseProxy_.export(outfile, level, namespace_, name_='DatabaseProxy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatabaseProxyCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabaseProxy=[\n')
        level += 1
        for DatabaseProxy_ in self.DatabaseProxy:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseProxy(\n')
            DatabaseProxy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseProxy':
            obj_ = DatabaseProxy.factory()
            obj_.build(child_)
            self.DatabaseProxy.append(obj_)
            obj_.original_tagname_ = 'DatabaseProxy'
# end class DatabaseProxyCollection


class DateTimeFormat(GeneratedsSuper):
    """Format object for date and time data.String that represents the
    required datetime format.Datetime format ID (see
    IdReferenceLinking).Name used for this datetime format."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Id=None, Format=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.Id = _cast(None, Id)
        self.Format = _cast(None, Format)
    def factory(*args_, **kwargs_):
        if DateTimeFormat.subclass:
            return DateTimeFormat.subclass(*args_, **kwargs_)
        else:
            return DateTimeFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeFormat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeFormat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeFormat'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.Format is not None and 'Format' not in already_processed:
            already_processed.add('Format')
            outfile.write(' Format=%s' % (self.gds_format_string(quote_attrib(self.Format).encode(ExternalEncoding), input_name='Format'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeFormat', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DateTimeFormat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.Format is not None and 'Format' not in already_processed:
            already_processed.add('Format')
            showIndent(outfile, level)
            outfile.write('Format="%s",\n' % (self.Format,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('Format', node)
        if value is not None and 'Format' not in already_processed:
            already_processed.add('Format')
            self.Format = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DateTimeFormat


class DateTimeFormatCollection(GeneratedsSuper):
    """Collection of datetime formats, which can be used to control the
    format used for displaying a chart item's DateTime."""
    subclass = None
    superclass = None
    def __init__(self, DateTimeFormat=None):
        self.original_tagname_ = None
        if DateTimeFormat is None:
            self.DateTimeFormat = []
        else:
            self.DateTimeFormat = DateTimeFormat
    def factory(*args_, **kwargs_):
        if DateTimeFormatCollection.subclass:
            return DateTimeFormatCollection.subclass(*args_, **kwargs_)
        else:
            return DateTimeFormatCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateTimeFormat(self): return self.DateTimeFormat
    def set_DateTimeFormat(self, DateTimeFormat): self.DateTimeFormat = DateTimeFormat
    def add_DateTimeFormat(self, value): self.DateTimeFormat.append(value)
    def insert_DateTimeFormat(self, index, value): self.DateTimeFormat[index] = value
    def hasContent_(self):
        if (
            self.DateTimeFormat
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeFormatCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeFormatCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeFormatCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeFormatCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeFormatCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DateTimeFormat_ in self.DateTimeFormat:
            DateTimeFormat_.export(outfile, level, namespace_, name_='DateTimeFormat', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DateTimeFormatCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DateTimeFormat=[\n')
        level += 1
        for DateTimeFormat_ in self.DateTimeFormat:
            showIndent(outfile, level)
            outfile.write('model_.DateTimeFormat(\n')
            DateTimeFormat_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateTimeFormat':
            obj_ = DateTimeFormat.factory()
            obj_.build(child_)
            self.DateTimeFormat.append(obj_)
            obj_.original_tagname_ = 'DateTimeFormat'
# end class DateTimeFormatCollection


class End(GeneratedsSuper):
    """A chart item that has a coordinate position and can be linked to
    other ends. Part of the chart item inheritance hierarchy.X
    position of the end, expressed in world coordinates. Controlling
    items raise a run-time error if they cause the chart's time to
    flow right to left.Y position of the item, expressed in world
    coordinates.Z position of the item, expressed in world
    coordinates."""
    subclass = None
    superclass = None
    def __init__(self, Y=0, X=0, Z=0, Entity=None, Label=None):
        self.original_tagname_ = None
        self.Y = _cast(int, Y)
        self.X = _cast(int, X)
        self.Z = _cast(int, Z)
        self.Entity = Entity
        self.Label = Label
    def factory(*args_, **kwargs_):
        if End.subclass:
            return End.subclass(*args_, **kwargs_)
        else:
            return End(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entity(self): return self.Entity
    def set_Entity(self, Entity): self.Entity = Entity
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def hasContent_(self):
        if (
            self.Entity is not None or
            self.Label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='End', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='End')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='End', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='End'):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            outfile.write(' Y="%s"' % self.gds_format_integer(self.Y, input_name='Y'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            outfile.write(' X="%s"' % self.gds_format_integer(self.X, input_name='X'))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            outfile.write(' Z="%s"' % self.gds_format_integer(self.Z, input_name='Z'))
    def exportChildren(self, outfile, level, namespace_='', name_='End', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Entity is not None:
            self.Entity.export(outfile, level, namespace_, name_='Entity', pretty_print=pretty_print)
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='End'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            showIndent(outfile, level)
            outfile.write('Y=%d,\n' % (self.Y,))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            showIndent(outfile, level)
            outfile.write('X=%d,\n' % (self.X,))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            showIndent(outfile, level)
            outfile.write('Z=%d,\n' % (self.Z,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Entity is not None:
            showIndent(outfile, level)
            outfile.write('Entity=model_.Entity(\n')
            self.Entity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.Label(\n')
            self.Label.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            try:
                self.Z = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entity':
            obj_ = Entity.factory()
            obj_.build(child_)
            self.Entity = obj_
            obj_.original_tagname_ = 'Entity'
        elif nodeName_ == 'Label':
            obj_ = Label.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
# end class End


class Entity(GeneratedsSuper):
    """An end item that has an identity property and possibly database
    keys. Part of the chart item inheritance hierarchy.Entity ID
    that can be used when IdReferenceLinking is False.The entity's
    identity. If a new identity matches an existing identity, a run-
    time error is raised. If LabelIsIdentity is True, the Identity
    is equivalent to the Label property.If True, the Label property
    assumes the Identity property value. In this case, set both the
    identity and label with the Identity property. If False, use the
    Label property to set the label independently.The entity
    semantic type assigned to this entity."""
    subclass = None
    superclass = None
    def __init__(self, EntityId=None, SemanticTypeGuid=None, Identity=None, LabelIsIdentity=False, Box=None, Circle=None, Event=None, Icon=None, OleItem=None, TextBlock=None, Theme=None, DatabaseKeyCollection=None, CardCollection=None):
        self.original_tagname_ = None
        self.EntityId = _cast(None, EntityId)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.Identity = _cast(None, Identity)
        self.LabelIsIdentity = _cast(bool, LabelIsIdentity)
        self.Box = Box
        self.Circle = Circle
        self.Event = Event
        self.Icon = Icon
        self.OleItem = OleItem
        self.TextBlock = TextBlock
        self.Theme = Theme
        self.DatabaseKeyCollection = DatabaseKeyCollection
        self.CardCollection = CardCollection
    def factory(*args_, **kwargs_):
        if Entity.subclass:
            return Entity.subclass(*args_, **kwargs_)
        else:
            return Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Box(self): return self.Box
    def set_Box(self, Box): self.Box = Box
    def get_Circle(self): return self.Circle
    def set_Circle(self, Circle): self.Circle = Circle
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def get_Icon(self): return self.Icon
    def set_Icon(self, Icon): self.Icon = Icon
    def get_OleItem(self): return self.OleItem
    def set_OleItem(self, OleItem): self.OleItem = OleItem
    def get_TextBlock(self): return self.TextBlock
    def set_TextBlock(self, TextBlock): self.TextBlock = TextBlock
    def get_Theme(self): return self.Theme
    def set_Theme(self, Theme): self.Theme = Theme
    def get_DatabaseKeyCollection(self): return self.DatabaseKeyCollection
    def set_DatabaseKeyCollection(self, DatabaseKeyCollection): self.DatabaseKeyCollection = DatabaseKeyCollection
    def get_CardCollection(self): return self.CardCollection
    def set_CardCollection(self, CardCollection): self.CardCollection = CardCollection
    def get_EntityId(self): return self.EntityId
    def set_EntityId(self, EntityId): self.EntityId = EntityId
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_Identity(self): return self.Identity
    def set_Identity(self, Identity): self.Identity = Identity
    def get_LabelIsIdentity(self): return self.LabelIsIdentity
    def set_LabelIsIdentity(self, LabelIsIdentity): self.LabelIsIdentity = LabelIsIdentity
    def hasContent_(self):
        if (
            self.Box is not None or
            self.Circle is not None or
            self.Event is not None or
            self.Icon is not None or
            self.OleItem is not None or
            self.TextBlock is not None or
            self.Theme is not None or
            self.DatabaseKeyCollection is not None or
            self.CardCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Entity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Entity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Entity'):
        if self.EntityId is not None and 'EntityId' not in already_processed:
            already_processed.add('EntityId')
            outfile.write(' EntityId=%s' % (self.gds_format_string(quote_attrib(self.EntityId).encode(ExternalEncoding), input_name='EntityId'), ))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.Identity is not None and 'Identity' not in already_processed:
            already_processed.add('Identity')
            outfile.write(' Identity=%s' % (self.gds_format_string(quote_attrib(self.Identity).encode(ExternalEncoding), input_name='Identity'), ))
        if self.LabelIsIdentity is not None and 'LabelIsIdentity' not in already_processed:
            already_processed.add('LabelIsIdentity')
            outfile.write(' LabelIsIdentity="%s"' % self.gds_format_boolean(self.LabelIsIdentity, input_name='LabelIsIdentity'))
    def exportChildren(self, outfile, level, namespace_='', name_='Entity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Box is not None:
            self.Box.export(outfile, level, namespace_, name_='Box', pretty_print=pretty_print)
        if self.Circle is not None:
            self.Circle.export(outfile, level, namespace_, name_='Circle', pretty_print=pretty_print)
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
        if self.Icon is not None:
            self.Icon.export(outfile, level, namespace_, name_='Icon', pretty_print=pretty_print)
        if self.OleItem is not None:
            self.OleItem.export(outfile, level, namespace_, name_='OleItem', pretty_print=pretty_print)
        if self.TextBlock is not None:
            self.TextBlock.export(outfile, level, namespace_, name_='TextBlock', pretty_print=pretty_print)
        if self.Theme is not None:
            self.Theme.export(outfile, level, namespace_, name_='Theme', pretty_print=pretty_print)
        if self.DatabaseKeyCollection is not None:
            self.DatabaseKeyCollection.export(outfile, level, namespace_, name_='DatabaseKeyCollection', pretty_print=pretty_print)
        if self.CardCollection is not None:
            self.CardCollection.export(outfile, level, namespace_, name_='CardCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Entity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EntityId is not None and 'EntityId' not in already_processed:
            already_processed.add('EntityId')
            showIndent(outfile, level)
            outfile.write('EntityId="%s",\n' % (self.EntityId,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.Identity is not None and 'Identity' not in already_processed:
            already_processed.add('Identity')
            showIndent(outfile, level)
            outfile.write('Identity="%s",\n' % (self.Identity,))
        if self.LabelIsIdentity is not None and 'LabelIsIdentity' not in already_processed:
            already_processed.add('LabelIsIdentity')
            showIndent(outfile, level)
            outfile.write('LabelIsIdentity=%s,\n' % (self.LabelIsIdentity,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Box is not None:
            showIndent(outfile, level)
            outfile.write('Box=model_.Box(\n')
            self.Box.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Circle is not None:
            showIndent(outfile, level)
            outfile.write('Circle=model_.Circle(\n')
            self.Circle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.Event(\n')
            self.Event.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Icon is not None:
            showIndent(outfile, level)
            outfile.write('Icon=model_.Icon(\n')
            self.Icon.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OleItem is not None:
            showIndent(outfile, level)
            outfile.write('OleItem=model_.OleItem(\n')
            self.OleItem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextBlock is not None:
            showIndent(outfile, level)
            outfile.write('TextBlock=model_.TextBlock(\n')
            self.TextBlock.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Theme is not None:
            showIndent(outfile, level)
            outfile.write('Theme=model_.Theme(\n')
            self.Theme.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DatabaseKeyCollection is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseKeyCollection=model_.DatabaseKeyCollection(\n')
            self.DatabaseKeyCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CardCollection is not None:
            showIndent(outfile, level)
            outfile.write('CardCollection=model_.CardCollection(\n')
            self.CardCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EntityId', node)
        if value is not None and 'EntityId' not in already_processed:
            already_processed.add('EntityId')
            self.EntityId = value
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('Identity', node)
        if value is not None and 'Identity' not in already_processed:
            already_processed.add('Identity')
            self.Identity = value
        value = find_attr_value_('LabelIsIdentity', node)
        if value is not None and 'LabelIsIdentity' not in already_processed:
            already_processed.add('LabelIsIdentity')
            if value in ('true', '1'):
                self.LabelIsIdentity = True
            elif value in ('false', '0'):
                self.LabelIsIdentity = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Box':
            obj_ = Box.factory()
            obj_.build(child_)
            self.Box = obj_
            obj_.original_tagname_ = 'Box'
        elif nodeName_ == 'Circle':
            obj_ = Circle.factory()
            obj_.build(child_)
            self.Circle = obj_
            obj_.original_tagname_ = 'Circle'
        elif nodeName_ == 'Event':
            obj_ = Event.factory()
            obj_.build(child_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'Icon':
            obj_ = Icon.factory()
            obj_.build(child_)
            self.Icon = obj_
            obj_.original_tagname_ = 'Icon'
        elif nodeName_ == 'OleItem':
            obj_ = OleItem.factory()
            obj_.build(child_)
            self.OleItem = obj_
            obj_.original_tagname_ = 'OleItem'
        elif nodeName_ == 'TextBlock':
            obj_ = TextBlock.factory()
            obj_.build(child_)
            self.TextBlock = obj_
            obj_.original_tagname_ = 'TextBlock'
        elif nodeName_ == 'Theme':
            obj_ = Theme.factory()
            obj_.build(child_)
            self.Theme = obj_
            obj_.original_tagname_ = 'Theme'
        elif nodeName_ == 'DatabaseKeyCollection':
            obj_ = DatabaseKeyCollection.factory()
            obj_.build(child_)
            self.DatabaseKeyCollection = obj_
            obj_.original_tagname_ = 'DatabaseKeyCollection'
        elif nodeName_ == 'CardCollection':
            obj_ = CardCollection.factory()
            obj_.build(child_)
            self.CardCollection = obj_
            obj_.original_tagname_ = 'CardCollection'
# end class Entity


class EntityObjects(GeneratedsSuper):
    """Collction of entity object proxies supported by this database."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseObjectProxy=None):
        self.original_tagname_ = None
        if DatabaseObjectProxy is None:
            self.DatabaseObjectProxy = []
        else:
            self.DatabaseObjectProxy = DatabaseObjectProxy
    def factory(*args_, **kwargs_):
        if EntityObjects.subclass:
            return EntityObjects.subclass(*args_, **kwargs_)
        else:
            return EntityObjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseObjectProxy(self): return self.DatabaseObjectProxy
    def set_DatabaseObjectProxy(self, DatabaseObjectProxy): self.DatabaseObjectProxy = DatabaseObjectProxy
    def add_DatabaseObjectProxy(self, value): self.DatabaseObjectProxy.append(value)
    def insert_DatabaseObjectProxy(self, index, value): self.DatabaseObjectProxy[index] = value
    def hasContent_(self):
        if (
            self.DatabaseObjectProxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityObjects', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityObjects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityObjects'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EntityObjects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabaseObjectProxy_ in self.DatabaseObjectProxy:
            DatabaseObjectProxy_.export(outfile, level, namespace_, name_='DatabaseObjectProxy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityObjects'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabaseObjectProxy=[\n')
        level += 1
        for DatabaseObjectProxy_ in self.DatabaseObjectProxy:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseObjectProxy(\n')
            DatabaseObjectProxy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseObjectProxy':
            obj_ = DatabaseObjectProxy.factory()
            obj_.build(child_)
            self.DatabaseObjectProxy.append(obj_)
            obj_.original_tagname_ = 'DatabaseObjectProxy'
# end class EntityObjects


class EntityType(GeneratedsSuper):
    """Entity type, which is a category of entity. An entity type can be
    applied to any entity representation. An entity type is part of
    an entity style.Color associated with the entity type.Filename
    for the bitmap associated with this entity type. This does not
    include the path or the file extension.Entity type format ID
    (see IdReferenceLinking).Name of the entity type. When the value
    is set, a run-time error is raised if the name already exists
    within the entity type collection.Preferred representation for
    this entity type.The entity semantic type assigned to this
    entity type.Optional colour to be used for icon shading."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Colour=0, SemanticTypeGuid=None, IconFile='General', PreferredRepresentation='RepresentAsIcon', IconShadingColour=None, Id=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.Colour = _cast(int, Colour)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.IconFile = _cast(None, IconFile)
        self.PreferredRepresentation = _cast(None, PreferredRepresentation)
        self.IconShadingColour = _cast(int, IconShadingColour)
        self.Id = _cast(None, Id)
    def factory(*args_, **kwargs_):
        if EntityType.subclass:
            return EntityType.subclass(*args_, **kwargs_)
        else:
            return EntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Colour(self): return self.Colour
    def set_Colour(self, Colour): self.Colour = Colour
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_IconFile(self): return self.IconFile
    def set_IconFile(self, IconFile): self.IconFile = IconFile
    def get_PreferredRepresentation(self): return self.PreferredRepresentation
    def set_PreferredRepresentation(self, PreferredRepresentation): self.PreferredRepresentation = PreferredRepresentation
    def get_IconShadingColour(self): return self.IconShadingColour
    def set_IconShadingColour(self, IconShadingColour): self.IconShadingColour = IconShadingColour
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_PreferredRepresentationEnum(self, value):
        # Validate type PreferredRepresentationEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            outfile.write(' Colour="%s"' % self.gds_format_integer(self.Colour, input_name='Colour'))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.IconFile is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            outfile.write(' IconFile=%s' % (self.gds_format_string(quote_attrib(self.IconFile).encode(ExternalEncoding), input_name='IconFile'), ))
        if self.PreferredRepresentation is not None and 'PreferredRepresentation' not in already_processed:
            already_processed.add('PreferredRepresentation')
            outfile.write(' PreferredRepresentation=%s' % (quote_attrib(self.PreferredRepresentation), ))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            outfile.write(' IconShadingColour="%s"' % self.gds_format_integer(self.IconShadingColour, input_name='IconShadingColour'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            showIndent(outfile, level)
            outfile.write('Colour=%d,\n' % (self.Colour,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.IconFile is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            showIndent(outfile, level)
            outfile.write('IconFile="%s",\n' % (self.IconFile,))
        if self.PreferredRepresentation is not None and 'PreferredRepresentation' not in already_processed:
            already_processed.add('PreferredRepresentation')
            showIndent(outfile, level)
            outfile.write('PreferredRepresentation="%s",\n' % (self.PreferredRepresentation,))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            showIndent(outfile, level)
            outfile.write('IconShadingColour=%d,\n' % (self.IconShadingColour,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('Colour', node)
        if value is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            try:
                self.Colour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('IconFile', node)
        if value is not None and 'IconFile' not in already_processed:
            already_processed.add('IconFile')
            self.IconFile = value
        value = find_attr_value_('PreferredRepresentation', node)
        if value is not None and 'PreferredRepresentation' not in already_processed:
            already_processed.add('PreferredRepresentation')
            self.PreferredRepresentation = value
            self.validate_PreferredRepresentationEnum(self.PreferredRepresentation)    # validate type PreferredRepresentationEnum
        value = find_attr_value_('IconShadingColour', node)
        if value is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            try:
                self.IconShadingColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityType


class EntityTypeCollection(GeneratedsSuper):
    """Collection of all the entity types in the chart."""
    subclass = None
    superclass = None
    def __init__(self, EntityType=None):
        self.original_tagname_ = None
        if EntityType is None:
            self.EntityType = []
        else:
            self.EntityType = EntityType
    def factory(*args_, **kwargs_):
        if EntityTypeCollection.subclass:
            return EntityTypeCollection.subclass(*args_, **kwargs_)
        else:
            return EntityTypeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntityType(self): return self.EntityType
    def set_EntityType(self, EntityType): self.EntityType = EntityType
    def add_EntityType(self, value): self.EntityType.append(value)
    def insert_EntityType(self, index, value): self.EntityType[index] = value
    def hasContent_(self):
        if (
            self.EntityType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityTypeCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityTypeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityTypeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityTypeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EntityTypeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EntityType_ in self.EntityType:
            EntityType_.export(outfile, level, namespace_, name_='EntityType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityTypeCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EntityType=[\n')
        level += 1
        for EntityType_ in self.EntityType:
            showIndent(outfile, level)
            outfile.write('model_.EntityType(\n')
            EntityType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntityType':
            obj_ = EntityType.factory()
            obj_.build(child_)
            self.EntityType.append(obj_)
            obj_.original_tagname_ = 'EntityType'
# end class EntityTypeCollection


class EntityTypeEntry(GeneratedsSuper):
    """Entity type stored as an entry on a palette.Type of entity used by
    this entry. An entity type is a category of entity.Type IDREF of
    entity used by this entry. An entity type is a category of
    entity."""
    subclass = None
    superclass = None
    def __init__(self, EntityTypeReference=None, Entity=None):
        self.original_tagname_ = None
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.Entity = _cast(None, Entity)
    def factory(*args_, **kwargs_):
        if EntityTypeEntry.subclass:
            return EntityTypeEntry.subclass(*args_, **kwargs_)
        else:
            return EntityTypeEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_Entity(self): return self.Entity
    def set_Entity(self, Entity): self.Entity = Entity
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityTypeEntry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityTypeEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityTypeEntry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityTypeEntry'):
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.Entity is not None and 'Entity' not in already_processed:
            already_processed.add('Entity')
            outfile.write(' Entity=%s' % (self.gds_format_string(quote_attrib(self.Entity).encode(ExternalEncoding), input_name='Entity'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityTypeEntry', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntityTypeEntry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.Entity is not None and 'Entity' not in already_processed:
            already_processed.add('Entity')
            showIndent(outfile, level)
            outfile.write('Entity="%s",\n' % (self.Entity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('Entity', node)
        if value is not None and 'Entity' not in already_processed:
            already_processed.add('Entity')
            self.Entity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityTypeEntry


class EntityTypeEntryCollection(GeneratedsSuper):
    """Collection of entity type entries on this palette."""
    subclass = None
    superclass = None
    def __init__(self, EntityTypeEntry=None):
        self.original_tagname_ = None
        if EntityTypeEntry is None:
            self.EntityTypeEntry = []
        else:
            self.EntityTypeEntry = EntityTypeEntry
    def factory(*args_, **kwargs_):
        if EntityTypeEntryCollection.subclass:
            return EntityTypeEntryCollection.subclass(*args_, **kwargs_)
        else:
            return EntityTypeEntryCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntityTypeEntry(self): return self.EntityTypeEntry
    def set_EntityTypeEntry(self, EntityTypeEntry): self.EntityTypeEntry = EntityTypeEntry
    def add_EntityTypeEntry(self, value): self.EntityTypeEntry.append(value)
    def insert_EntityTypeEntry(self, index, value): self.EntityTypeEntry[index] = value
    def hasContent_(self):
        if (
            self.EntityTypeEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityTypeEntryCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityTypeEntryCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityTypeEntryCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityTypeEntryCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EntityTypeEntryCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EntityTypeEntry_ in self.EntityTypeEntry:
            EntityTypeEntry_.export(outfile, level, namespace_, name_='EntityTypeEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityTypeEntryCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EntityTypeEntry=[\n')
        level += 1
        for EntityTypeEntry_ in self.EntityTypeEntry:
            showIndent(outfile, level)
            outfile.write('model_.EntityTypeEntry(\n')
            EntityTypeEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntityTypeEntry':
            obj_ = EntityTypeEntry.factory()
            obj_.build(child_)
            self.EntityTypeEntry.append(obj_)
            obj_.original_tagname_ = 'EntityTypeEntry'
# end class EntityTypeEntryCollection


class Event(GeneratedsSuper):
    """An event frame chart item object. Part of the chart item inheritance
    hierarchy."""
    subclass = None
    superclass = None
    def __init__(self, EventStyle=None):
        self.original_tagname_ = None
        self.EventStyle = EventStyle
    def factory(*args_, **kwargs_):
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventStyle(self): return self.EventStyle
    def set_EventStyle(self, EventStyle): self.EventStyle = EventStyle
    def hasContent_(self):
        if (
            self.EventStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Event', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Event'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EventStyle is not None:
            self.EventStyle.export(outfile, level, namespace_, name_='EventStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Event'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EventStyle is not None:
            showIndent(outfile, level)
            outfile.write('EventStyle=model_.EventStyle(\n')
            self.EventStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventStyle':
            obj_ = EventStyle.factory()
            obj_.build(child_)
            self.EventStyle = obj_
            obj_.original_tagname_ = 'EventStyle'
# end class Event


class EventStyle(GeneratedsSuper):
    """Style of the event frame chart item. Part of the LNCIStyle
    inheritance hierarchy.Text alignment setting for the label
    text.Mask that controls the auto sizing options for the event
    frame. If auto sizing is enabled for the width and/or height, a
    run-time error is raised if you set the Width and/or Height
    properties.Color used to fill the chart item when Filled is
    True.Scales the icon used to represent the type of the event
    frame chart item.Type IDREF of entity used by this style. An
    entity type is a category of entity.If True, the event frame is
    filled. Control the fill color using the BackColour
    property.Signifies whether the item is a solid colour,
    transparent or contains a gradient-fill.Height of the item,
    expressed in Inches. When the value is set, a run-time error is
    raised if the AutosizeOption property is not set to
    AutosizeManualHeight.Width of the lines of the event frame.Color
    of the line used to draw the chart item.If True, the link area
    within the event frame is visible.Strength associated with the
    event frame, which controls the event frame border
    appearance.Strength IDREF associated with the event frame, which
    controls the event frame border appearance.Type of entity used
    by this style. An entity type is a category of entity.If True,
    the entity type icon is visible.If True, the entity type name is
    visible within the event frame.Width of the item, expressed in
    Inches. When the value is set, a run-time error is raised if the
    AutosizeOption property is not set to AutosizeManualWidth.Colour
    used to override type's shaded icon colour."""
    subclass = None
    superclass = None
    def __init__(self, TypeIconVisible=None, LineWidth=None, Width=None, StrengthReference=None, LinkAreaVisible=None, EntityTypeReference=None, FillStyle=None, LineColour=None, Enlargement=None, BackColour=None, Alignment=None, Strength=None, TypeNameVisible=None, Height=None, Type=None, IconShadingColour=None, Filled=None, AutoSizeOption=None, IconPicture=None):
        self.original_tagname_ = None
        self.TypeIconVisible = _cast(bool, TypeIconVisible)
        self.LineWidth = _cast(int, LineWidth)
        self.Width = _cast(float, Width)
        self.StrengthReference = _cast(None, StrengthReference)
        self.LinkAreaVisible = _cast(bool, LinkAreaVisible)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.FillStyle = _cast(None, FillStyle)
        self.LineColour = _cast(int, LineColour)
        self.Enlargement = _cast(None, Enlargement)
        self.BackColour = _cast(int, BackColour)
        self.Alignment = _cast(None, Alignment)
        self.Strength = _cast(None, Strength)
        self.TypeNameVisible = _cast(bool, TypeNameVisible)
        self.Height = _cast(float, Height)
        self.Type = _cast(None, Type)
        self.IconShadingColour = _cast(int, IconShadingColour)
        self.Filled = _cast(bool, Filled)
        self.AutoSizeOption = _cast(None, AutoSizeOption)
        self.IconPicture = IconPicture
    def factory(*args_, **kwargs_):
        if EventStyle.subclass:
            return EventStyle.subclass(*args_, **kwargs_)
        else:
            return EventStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IconPicture(self): return self.IconPicture
    def set_IconPicture(self, IconPicture): self.IconPicture = IconPicture
    def get_TypeIconVisible(self): return self.TypeIconVisible
    def set_TypeIconVisible(self, TypeIconVisible): self.TypeIconVisible = TypeIconVisible
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_LinkAreaVisible(self): return self.LinkAreaVisible
    def set_LinkAreaVisible(self, LinkAreaVisible): self.LinkAreaVisible = LinkAreaVisible
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_FillStyle(self): return self.FillStyle
    def set_FillStyle(self, FillStyle): self.FillStyle = FillStyle
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_Enlargement(self): return self.Enlargement
    def set_Enlargement(self, Enlargement): self.Enlargement = Enlargement
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_Alignment(self): return self.Alignment
    def set_Alignment(self, Alignment): self.Alignment = Alignment
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_TypeNameVisible(self): return self.TypeNameVisible
    def set_TypeNameVisible(self, TypeNameVisible): self.TypeNameVisible = TypeNameVisible
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_IconShadingColour(self): return self.IconShadingColour
    def set_IconShadingColour(self, IconShadingColour): self.IconShadingColour = IconShadingColour
    def get_Filled(self): return self.Filled
    def set_Filled(self, Filled): self.Filled = Filled
    def get_AutoSizeOption(self): return self.AutoSizeOption
    def set_AutoSizeOption(self, AutoSizeOption): self.AutoSizeOption = AutoSizeOption
    def validate_FillStyleEnum(self, value):
        # Validate type FillStyleEnum, a restriction on xsd:string.
        pass
    def validate_IconEnlargementEnum(self, value):
        # Validate type IconEnlargementEnum, a restriction on xsd:string.
        pass
    def validate_TextAlignmentEnum(self, value):
        # Validate type TextAlignmentEnum, a restriction on xsd:string.
        pass
    def validate_AutoSizeOptionEnum(self, value):
        # Validate type AutoSizeOptionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.IconPicture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventStyle'):
        if self.TypeIconVisible is not None and 'TypeIconVisible' not in already_processed:
            already_processed.add('TypeIconVisible')
            outfile.write(' TypeIconVisible="%s"' % self.gds_format_boolean(self.TypeIconVisible, input_name='TypeIconVisible'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            outfile.write(' Width="%s"' % self.gds_format_double(self.Width, input_name='Width'))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.LinkAreaVisible is not None and 'LinkAreaVisible' not in already_processed:
            already_processed.add('LinkAreaVisible')
            outfile.write(' LinkAreaVisible="%s"' % self.gds_format_boolean(self.LinkAreaVisible, input_name='LinkAreaVisible'))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            outfile.write(' FillStyle=%s' % (quote_attrib(self.FillStyle), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            outfile.write(' Enlargement=%s' % (quote_attrib(self.Enlargement), ))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            outfile.write(' Alignment=%s' % (quote_attrib(self.Alignment), ))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.TypeNameVisible is not None and 'TypeNameVisible' not in already_processed:
            already_processed.add('TypeNameVisible')
            outfile.write(' TypeNameVisible="%s"' % self.gds_format_boolean(self.TypeNameVisible, input_name='TypeNameVisible'))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            outfile.write(' Height="%s"' % self.gds_format_double(self.Height, input_name='Height'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            outfile.write(' IconShadingColour="%s"' % self.gds_format_integer(self.IconShadingColour, input_name='IconShadingColour'))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            outfile.write(' Filled="%s"' % self.gds_format_boolean(self.Filled, input_name='Filled'))
        if self.AutoSizeOption is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            outfile.write(' AutoSizeOption=%s' % (quote_attrib(self.AutoSizeOption), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IconPicture is not None:
            self.IconPicture.export(outfile, level, namespace_, name_='IconPicture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EventStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TypeIconVisible is not None and 'TypeIconVisible' not in already_processed:
            already_processed.add('TypeIconVisible')
            showIndent(outfile, level)
            outfile.write('TypeIconVisible=%s,\n' % (self.TypeIconVisible,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            showIndent(outfile, level)
            outfile.write('Width=%e,\n' % (self.Width,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.LinkAreaVisible is not None and 'LinkAreaVisible' not in already_processed:
            already_processed.add('LinkAreaVisible')
            showIndent(outfile, level)
            outfile.write('LinkAreaVisible=%s,\n' % (self.LinkAreaVisible,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            showIndent(outfile, level)
            outfile.write('FillStyle="%s",\n' % (self.FillStyle,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            showIndent(outfile, level)
            outfile.write('Enlargement="%s",\n' % (self.Enlargement,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            showIndent(outfile, level)
            outfile.write('Alignment="%s",\n' % (self.Alignment,))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.TypeNameVisible is not None and 'TypeNameVisible' not in already_processed:
            already_processed.add('TypeNameVisible')
            showIndent(outfile, level)
            outfile.write('TypeNameVisible=%s,\n' % (self.TypeNameVisible,))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            showIndent(outfile, level)
            outfile.write('Height=%e,\n' % (self.Height,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            showIndent(outfile, level)
            outfile.write('IconShadingColour=%d,\n' % (self.IconShadingColour,))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            showIndent(outfile, level)
            outfile.write('Filled=%s,\n' % (self.Filled,))
        if self.AutoSizeOption is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            showIndent(outfile, level)
            outfile.write('AutoSizeOption="%s",\n' % (self.AutoSizeOption,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IconPicture is not None:
            showIndent(outfile, level)
            outfile.write('IconPicture=model_.IconPicture(\n')
            self.IconPicture.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TypeIconVisible', node)
        if value is not None and 'TypeIconVisible' not in already_processed:
            already_processed.add('TypeIconVisible')
            if value in ('true', '1'):
                self.TypeIconVisible = True
            elif value in ('false', '0'):
                self.TypeIconVisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Width): %s' % exp)
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('LinkAreaVisible', node)
        if value is not None and 'LinkAreaVisible' not in already_processed:
            already_processed.add('LinkAreaVisible')
            if value in ('true', '1'):
                self.LinkAreaVisible = True
            elif value in ('false', '0'):
                self.LinkAreaVisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('FillStyle', node)
        if value is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            self.FillStyle = value
            self.validate_FillStyleEnum(self.FillStyle)    # validate type FillStyleEnum
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Enlargement', node)
        if value is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            self.Enlargement = value
            self.validate_IconEnlargementEnum(self.Enlargement)    # validate type IconEnlargementEnum
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Alignment', node)
        if value is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            self.Alignment = value
            self.validate_TextAlignmentEnum(self.Alignment)    # validate type TextAlignmentEnum
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('TypeNameVisible', node)
        if value is not None and 'TypeNameVisible' not in already_processed:
            already_processed.add('TypeNameVisible')
            if value in ('true', '1'):
                self.TypeNameVisible = True
            elif value in ('false', '0'):
                self.TypeNameVisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Height): %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('IconShadingColour', node)
        if value is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            try:
                self.IconShadingColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Filled', node)
        if value is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            if value in ('true', '1'):
                self.Filled = True
            elif value in ('false', '0'):
                self.Filled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('AutoSizeOption', node)
        if value is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            self.AutoSizeOption = value
            self.validate_AutoSizeOptionEnum(self.AutoSizeOption)    # validate type AutoSizeOptionEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IconPicture':
            obj_ = IconPicture.factory()
            obj_.build(child_)
            self.IconPicture = obj_
            obj_.original_tagname_ = 'IconPicture'
# end class EventStyle


class Field(GeneratedsSuper):
    """Field in the summary.Field in the summary.Type of summary
    information field."""
    subclass = None
    superclass = None
    def __init__(self, Field=None, Type='SummaryFieldAuthor'):
        self.original_tagname_ = None
        self.Field = _cast(None, Field)
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if Field.subclass:
            return Field.subclass(*args_, **kwargs_)
        else:
            return Field(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Field(self): return self.Field
    def set_Field(self, Field): self.Field = Field
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SummaryFieldsEnum(self, value):
        # Validate type SummaryFieldsEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Field', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Field')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Field', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Field'):
        if self.Field is not None and 'Field' not in already_processed:
            already_processed.add('Field')
            outfile.write(' Field=%s' % (self.gds_format_string(quote_attrib(self.Field).encode(ExternalEncoding), input_name='Field'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Field', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Field'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Field is not None and 'Field' not in already_processed:
            already_processed.add('Field')
            showIndent(outfile, level)
            outfile.write('Field="%s",\n' % (self.Field,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Field', node)
        if value is not None and 'Field' not in already_processed:
            already_processed.add('Field')
            self.Field = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_SummaryFieldsEnum(self.Type)    # validate type SummaryFieldsEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Field


class FieldCollection(GeneratedsSuper):
    """Collection of summary fields for the chart."""
    subclass = None
    superclass = None
    def __init__(self, Field=None):
        self.original_tagname_ = None
        if Field is None:
            self.Field = []
        else:
            self.Field = Field
    def factory(*args_, **kwargs_):
        if FieldCollection.subclass:
            return FieldCollection.subclass(*args_, **kwargs_)
        else:
            return FieldCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Field(self): return self.Field
    def set_Field(self, Field): self.Field = Field
    def add_Field(self, value): self.Field.append(value)
    def insert_Field(self, index, value): self.Field[index] = value
    def hasContent_(self):
        if (
            self.Field
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FieldCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FieldCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FieldCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Field_ in self.Field:
            Field_.export(outfile, level, namespace_, name_='Field', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FieldCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Field=[\n')
        level += 1
        for Field_ in self.Field:
            showIndent(outfile, level)
            outfile.write('model_.Field(\n')
            Field_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Field':
            obj_ = Field.factory()
            obj_.build(child_)
            self.Field.append(obj_)
            obj_.original_tagname_ = 'Field'
# end class FieldCollection


class Font(GeneratedsSuper):
    """Defines aspects of the font style. To change the font of a chart
    item style, you must get the font object, change the font
    settings, and assign the font settings to the chart item
    style.Color used behind the text.If True, the text is shown in
    bold.Character set for the font. For example, ANSI or
    Japanese.Name of the font used for the text. For example, Arial
    or Courier.Color used for the text.If True, the text is shown in
    italics.Size of the text characters, expressed in points. For
    example, 10 or 12.If True, strikeout the text, that is, draw a
    line through it.If True, the text is underlined."""
    subclass = None
    superclass = None
    def __init__(self, Strikeout=False, FaceName='Arial', Bold=False, CharSet='CharSetDefault', Underline=False, BackColour=16777215, Italic=False, PointSize=8, FontColour=0):
        self.original_tagname_ = None
        self.Strikeout = _cast(bool, Strikeout)
        self.FaceName = _cast(None, FaceName)
        self.Bold = _cast(bool, Bold)
        self.CharSet = _cast(None, CharSet)
        self.Underline = _cast(bool, Underline)
        self.BackColour = _cast(int, BackColour)
        self.Italic = _cast(bool, Italic)
        self.PointSize = _cast(int, PointSize)
        self.FontColour = _cast(int, FontColour)
    def factory(*args_, **kwargs_):
        if Font.subclass:
            return Font.subclass(*args_, **kwargs_)
        else:
            return Font(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strikeout(self): return self.Strikeout
    def set_Strikeout(self, Strikeout): self.Strikeout = Strikeout
    def get_FaceName(self): return self.FaceName
    def set_FaceName(self, FaceName): self.FaceName = FaceName
    def get_Bold(self): return self.Bold
    def set_Bold(self, Bold): self.Bold = Bold
    def get_CharSet(self): return self.CharSet
    def set_CharSet(self, CharSet): self.CharSet = CharSet
    def get_Underline(self): return self.Underline
    def set_Underline(self, Underline): self.Underline = Underline
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_Italic(self): return self.Italic
    def set_Italic(self, Italic): self.Italic = Italic
    def get_PointSize(self): return self.PointSize
    def set_PointSize(self, PointSize): self.PointSize = PointSize
    def get_FontColour(self): return self.FontColour
    def set_FontColour(self, FontColour): self.FontColour = FontColour
    def validate_FontCharSetEnum(self, value):
        # Validate type FontCharSetEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Font', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Font')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Font', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Font'):
        if self.Strikeout is not None and 'Strikeout' not in already_processed:
            already_processed.add('Strikeout')
            outfile.write(' Strikeout="%s"' % self.gds_format_boolean(self.Strikeout, input_name='Strikeout'))
        if self.FaceName is not None and 'FaceName' not in already_processed:
            already_processed.add('FaceName')
            outfile.write(' FaceName=%s' % (self.gds_format_string(quote_attrib(self.FaceName).encode(ExternalEncoding), input_name='FaceName'), ))
        if self.Bold is not None and 'Bold' not in already_processed:
            already_processed.add('Bold')
            outfile.write(' Bold="%s"' % self.gds_format_boolean(self.Bold, input_name='Bold'))
        if self.CharSet is not None and 'CharSet' not in already_processed:
            already_processed.add('CharSet')
            outfile.write(' CharSet=%s' % (quote_attrib(self.CharSet), ))
        if self.Underline is not None and 'Underline' not in already_processed:
            already_processed.add('Underline')
            outfile.write(' Underline="%s"' % self.gds_format_boolean(self.Underline, input_name='Underline'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.Italic is not None and 'Italic' not in already_processed:
            already_processed.add('Italic')
            outfile.write(' Italic="%s"' % self.gds_format_boolean(self.Italic, input_name='Italic'))
        if self.PointSize is not None and 'PointSize' not in already_processed:
            already_processed.add('PointSize')
            outfile.write(' PointSize="%s"' % self.gds_format_integer(self.PointSize, input_name='PointSize'))
        if self.FontColour is not None and 'FontColour' not in already_processed:
            already_processed.add('FontColour')
            outfile.write(' FontColour="%s"' % self.gds_format_integer(self.FontColour, input_name='FontColour'))
    def exportChildren(self, outfile, level, namespace_='', name_='Font', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Font'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Strikeout is not None and 'Strikeout' not in already_processed:
            already_processed.add('Strikeout')
            showIndent(outfile, level)
            outfile.write('Strikeout=%s,\n' % (self.Strikeout,))
        if self.FaceName is not None and 'FaceName' not in already_processed:
            already_processed.add('FaceName')
            showIndent(outfile, level)
            outfile.write('FaceName="%s",\n' % (self.FaceName,))
        if self.Bold is not None and 'Bold' not in already_processed:
            already_processed.add('Bold')
            showIndent(outfile, level)
            outfile.write('Bold=%s,\n' % (self.Bold,))
        if self.CharSet is not None and 'CharSet' not in already_processed:
            already_processed.add('CharSet')
            showIndent(outfile, level)
            outfile.write('CharSet="%s",\n' % (self.CharSet,))
        if self.Underline is not None and 'Underline' not in already_processed:
            already_processed.add('Underline')
            showIndent(outfile, level)
            outfile.write('Underline=%s,\n' % (self.Underline,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.Italic is not None and 'Italic' not in already_processed:
            already_processed.add('Italic')
            showIndent(outfile, level)
            outfile.write('Italic=%s,\n' % (self.Italic,))
        if self.PointSize is not None and 'PointSize' not in already_processed:
            already_processed.add('PointSize')
            showIndent(outfile, level)
            outfile.write('PointSize=%d,\n' % (self.PointSize,))
        if self.FontColour is not None and 'FontColour' not in already_processed:
            already_processed.add('FontColour')
            showIndent(outfile, level)
            outfile.write('FontColour=%d,\n' % (self.FontColour,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Strikeout', node)
        if value is not None and 'Strikeout' not in already_processed:
            already_processed.add('Strikeout')
            if value in ('true', '1'):
                self.Strikeout = True
            elif value in ('false', '0'):
                self.Strikeout = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('FaceName', node)
        if value is not None and 'FaceName' not in already_processed:
            already_processed.add('FaceName')
            self.FaceName = value
        value = find_attr_value_('Bold', node)
        if value is not None and 'Bold' not in already_processed:
            already_processed.add('Bold')
            if value in ('true', '1'):
                self.Bold = True
            elif value in ('false', '0'):
                self.Bold = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CharSet', node)
        if value is not None and 'CharSet' not in already_processed:
            already_processed.add('CharSet')
            self.CharSet = value
            self.validate_FontCharSetEnum(self.CharSet)    # validate type FontCharSetEnum
        value = find_attr_value_('Underline', node)
        if value is not None and 'Underline' not in already_processed:
            already_processed.add('Underline')
            if value in ('true', '1'):
                self.Underline = True
            elif value in ('false', '0'):
                self.Underline = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Italic', node)
        if value is not None and 'Italic' not in already_processed:
            already_processed.add('Italic')
            if value in ('true', '1'):
                self.Italic = True
            elif value in ('false', '0'):
                self.Italic = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PointSize', node)
        if value is not None and 'PointSize' not in already_processed:
            already_processed.add('PointSize')
            try:
                self.PointSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('FontColour', node)
        if value is not None and 'FontColour' not in already_processed:
            already_processed.add('FontColour')
            try:
                self.FontColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Font


class Footer(GeneratedsSuper):
    """The object which represents a single print footer element.Position
    of the print footer object.Name of the property to be displayed
    by the footer object.Is the footer object visible."""
    subclass = None
    superclass = None
    def __init__(self, Position=None, Property=None, Visible=None):
        self.original_tagname_ = None
        self.Position = _cast(None, Position)
        self.Property = _cast(None, Property)
        self.Visible = _cast(bool, Visible)
    def factory(*args_, **kwargs_):
        if Footer.subclass:
            return Footer.subclass(*args_, **kwargs_)
        else:
            return Footer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def validate_HeaderFooterPositionEnum(self, value):
        # Validate type HeaderFooterPositionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Footer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Footer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Footer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Footer'):
        if self.Position is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            outfile.write(' Position=%s' % (quote_attrib(self.Position), ))
        if self.Property is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            outfile.write(' Property=%s' % (self.gds_format_string(quote_attrib(self.Property).encode(ExternalEncoding), input_name='Property'), ))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
    def exportChildren(self, outfile, level, namespace_='', name_='Footer', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Footer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Position is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            showIndent(outfile, level)
            outfile.write('Position="%s",\n' % (self.Position,))
        if self.Property is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            showIndent(outfile, level)
            outfile.write('Property="%s",\n' % (self.Property,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Position', node)
        if value is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            self.Position = value
            self.validate_HeaderFooterPositionEnum(self.Position)    # validate type HeaderFooterPositionEnum
        value = find_attr_value_('Property', node)
        if value is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            self.Property = value
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Footer


class FooterCollection(GeneratedsSuper):
    """Collection of print footer properties."""
    subclass = None
    superclass = None
    def __init__(self, Footer=None):
        self.original_tagname_ = None
        if Footer is None:
            self.Footer = []
        else:
            self.Footer = Footer
    def factory(*args_, **kwargs_):
        if FooterCollection.subclass:
            return FooterCollection.subclass(*args_, **kwargs_)
        else:
            return FooterCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Footer(self): return self.Footer
    def set_Footer(self, Footer): self.Footer = Footer
    def add_Footer(self, value): self.Footer.append(value)
    def insert_Footer(self, index, value): self.Footer[index] = value
    def hasContent_(self):
        if (
            self.Footer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FooterCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FooterCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FooterCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FooterCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FooterCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Footer_ in self.Footer:
            Footer_.export(outfile, level, namespace_, name_='Footer', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FooterCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Footer=[\n')
        level += 1
        for Footer_ in self.Footer:
            showIndent(outfile, level)
            outfile.write('model_.Footer(\n')
            Footer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Footer':
            obj_ = Footer.factory()
            obj_.build(child_)
            self.Footer.append(obj_)
            obj_.original_tagname_ = 'Footer'
# end class FooterCollection


class FrameStyle(GeneratedsSuper):
    """Frame Style DataColour of the FrameVisibility of the FrameMargin
    size of the Frame"""
    subclass = None
    superclass = None
    def __init__(self, Visible=None, Colour=None, Margin=None):
        self.original_tagname_ = None
        self.Visible = _cast(bool, Visible)
        self.Colour = _cast(int, Colour)
        self.Margin = _cast(int, Margin)
    def factory(*args_, **kwargs_):
        if FrameStyle.subclass:
            return FrameStyle.subclass(*args_, **kwargs_)
        else:
            return FrameStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_Colour(self): return self.Colour
    def set_Colour(self, Colour): self.Colour = Colour
    def get_Margin(self): return self.Margin
    def set_Margin(self, Margin): self.Margin = Margin
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FrameStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrameStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FrameStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FrameStyle'):
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            outfile.write(' Colour="%s"' % self.gds_format_integer(self.Colour, input_name='Colour'))
        if self.Margin is not None and 'Margin' not in already_processed:
            already_processed.add('Margin')
            outfile.write(' Margin="%s"' % self.gds_format_integer(self.Margin, input_name='Margin'))
    def exportChildren(self, outfile, level, namespace_='', name_='FrameStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FrameStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            showIndent(outfile, level)
            outfile.write('Colour=%d,\n' % (self.Colour,))
        if self.Margin is not None and 'Margin' not in already_processed:
            already_processed.add('Margin')
            showIndent(outfile, level)
            outfile.write('Margin=%d,\n' % (self.Margin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Colour', node)
        if value is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            try:
                self.Colour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Margin', node)
        if value is not None and 'Margin' not in already_processed:
            already_processed.add('Margin')
            try:
                self.Margin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrameStyle


class GradeOne(GeneratedsSuper):
    """Ordered collection of grade strings."""
    subclass = None
    superclass = None
    def __init__(self, StringCollection=None):
        self.original_tagname_ = None
        self.StringCollection = StringCollection
    def factory(*args_, **kwargs_):
        if GradeOne.subclass:
            return GradeOne.subclass(*args_, **kwargs_)
        else:
            return GradeOne(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StringCollection(self): return self.StringCollection
    def set_StringCollection(self, StringCollection): self.StringCollection = StringCollection
    def hasContent_(self):
        if (
            self.StringCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GradeOne', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradeOne')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GradeOne', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradeOne'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GradeOne', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringCollection is not None:
            self.StringCollection.export(outfile, level, namespace_, name_='StringCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GradeOne'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StringCollection is not None:
            showIndent(outfile, level)
            outfile.write('StringCollection=model_.StringCollection(\n')
            self.StringCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StringCollection':
            obj_ = StringCollection.factory()
            obj_.build(child_)
            self.StringCollection = obj_
            obj_.original_tagname_ = 'StringCollection'
# end class GradeOne


class GradeThree(GeneratedsSuper):
    """Ordered collection of grade strings."""
    subclass = None
    superclass = None
    def __init__(self, StringCollection=None):
        self.original_tagname_ = None
        self.StringCollection = StringCollection
    def factory(*args_, **kwargs_):
        if GradeThree.subclass:
            return GradeThree.subclass(*args_, **kwargs_)
        else:
            return GradeThree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StringCollection(self): return self.StringCollection
    def set_StringCollection(self, StringCollection): self.StringCollection = StringCollection
    def hasContent_(self):
        if (
            self.StringCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GradeThree', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradeThree')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GradeThree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradeThree'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GradeThree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringCollection is not None:
            self.StringCollection.export(outfile, level, namespace_, name_='StringCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GradeThree'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StringCollection is not None:
            showIndent(outfile, level)
            outfile.write('StringCollection=model_.StringCollection(\n')
            self.StringCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StringCollection':
            obj_ = StringCollection.factory()
            obj_.build(child_)
            self.StringCollection = obj_
            obj_.original_tagname_ = 'StringCollection'
# end class GradeThree


class GradeTwo(GeneratedsSuper):
    """Ordered collection of grade strings."""
    subclass = None
    superclass = None
    def __init__(self, StringCollection=None):
        self.original_tagname_ = None
        self.StringCollection = StringCollection
    def factory(*args_, **kwargs_):
        if GradeTwo.subclass:
            return GradeTwo.subclass(*args_, **kwargs_)
        else:
            return GradeTwo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StringCollection(self): return self.StringCollection
    def set_StringCollection(self, StringCollection): self.StringCollection = StringCollection
    def hasContent_(self):
        if (
            self.StringCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GradeTwo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradeTwo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GradeTwo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradeTwo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GradeTwo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringCollection is not None:
            self.StringCollection.export(outfile, level, namespace_, name_='StringCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GradeTwo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StringCollection is not None:
            showIndent(outfile, level)
            outfile.write('StringCollection=model_.StringCollection(\n')
            self.StringCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StringCollection':
            obj_ = StringCollection.factory()
            obj_.build(child_)
            self.StringCollection = obj_
            obj_.original_tagname_ = 'StringCollection'
# end class GradeTwo


class Group(GeneratedsSuper):
    """ID of the group."""
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
    def factory(*args_, **kwargs_):
        if Group.subclass:
            return Group.subclass(*args_, **kwargs_)
        else:
            return Group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Group', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Group', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Group'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Group', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Group'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Group


class GroupCollection(GeneratedsSuper):
    """Collection of groups associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, Group=None):
        self.original_tagname_ = None
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
    def factory(*args_, **kwargs_):
        if GroupCollection.subclass:
            return GroupCollection.subclass(*args_, **kwargs_)
        else:
            return GroupCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group(self, index, value): self.Group[index] = value
    def hasContent_(self):
        if (
            self.Group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GroupCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GroupCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.Group(\n')
            Group_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = Group.factory()
            obj_.build(child_)
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
# end class GroupCollection


class Header(GeneratedsSuper):
    """The object which represents a single print header element.Position
    of the print header object.Name of the property to be displayed
    by the header object.Is the header object visible."""
    subclass = None
    superclass = None
    def __init__(self, Position=None, Property=None, Visible=None):
        self.original_tagname_ = None
        self.Position = _cast(None, Position)
        self.Property = _cast(None, Property)
        self.Visible = _cast(bool, Visible)
    def factory(*args_, **kwargs_):
        if Header.subclass:
            return Header.subclass(*args_, **kwargs_)
        else:
            return Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def validate_HeaderFooterPositionEnum(self, value):
        # Validate type HeaderFooterPositionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Header', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Header', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Header'):
        if self.Position is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            outfile.write(' Position=%s' % (quote_attrib(self.Position), ))
        if self.Property is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            outfile.write(' Property=%s' % (self.gds_format_string(quote_attrib(self.Property).encode(ExternalEncoding), input_name='Property'), ))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
    def exportChildren(self, outfile, level, namespace_='', name_='Header', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Header'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Position is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            showIndent(outfile, level)
            outfile.write('Position="%s",\n' % (self.Position,))
        if self.Property is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            showIndent(outfile, level)
            outfile.write('Property="%s",\n' % (self.Property,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Position', node)
        if value is not None and 'Position' not in already_processed:
            already_processed.add('Position')
            self.Position = value
            self.validate_HeaderFooterPositionEnum(self.Position)    # validate type HeaderFooterPositionEnum
        value = find_attr_value_('Property', node)
        if value is not None and 'Property' not in already_processed:
            already_processed.add('Property')
            self.Property = value
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Header


class HeaderCollection(GeneratedsSuper):
    """Collection of print header properties."""
    subclass = None
    superclass = None
    def __init__(self, Header=None):
        self.original_tagname_ = None
        if Header is None:
            self.Header = []
        else:
            self.Header = Header
    def factory(*args_, **kwargs_):
        if HeaderCollection.subclass:
            return HeaderCollection.subclass(*args_, **kwargs_)
        else:
            return HeaderCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def add_Header(self, value): self.Header.append(value)
    def insert_Header(self, index, value): self.Header[index] = value
    def hasContent_(self):
        if (
            self.Header
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HeaderCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeaderCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HeaderCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HeaderCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HeaderCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Header_ in self.Header:
            Header_.export(outfile, level, namespace_, name_='Header', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HeaderCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Header=[\n')
        level += 1
        for Header_ in self.Header:
            showIndent(outfile, level)
            outfile.write('model_.Header(\n')
            Header_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Header':
            obj_ = Header.factory()
            obj_.build(child_)
            self.Header.append(obj_)
            obj_.original_tagname_ = 'Header'
# end class HeaderCollection


class Icon(GeneratedsSuper):
    """A icon chart item object. Part of the chart item inheritance
    hierarchy.X position of the label, relative to icon position, in
    world coordinates.Y position of the label, relative to icon
    position, in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, TextX=0, TextY=16, IconStyle=None):
        self.original_tagname_ = None
        self.TextX = _cast(int, TextX)
        self.TextY = _cast(int, TextY)
        self.IconStyle = IconStyle
    def factory(*args_, **kwargs_):
        if Icon.subclass:
            return Icon.subclass(*args_, **kwargs_)
        else:
            return Icon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IconStyle(self): return self.IconStyle
    def set_IconStyle(self, IconStyle): self.IconStyle = IconStyle
    def get_TextX(self): return self.TextX
    def set_TextX(self, TextX): self.TextX = TextX
    def get_TextY(self): return self.TextY
    def set_TextY(self, TextY): self.TextY = TextY
    def hasContent_(self):
        if (
            self.IconStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Icon', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Icon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Icon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Icon'):
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            outfile.write(' TextX="%s"' % self.gds_format_integer(self.TextX, input_name='TextX'))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            outfile.write(' TextY="%s"' % self.gds_format_integer(self.TextY, input_name='TextY'))
    def exportChildren(self, outfile, level, namespace_='', name_='Icon', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IconStyle is not None:
            self.IconStyle.export(outfile, level, namespace_, name_='IconStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Icon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            showIndent(outfile, level)
            outfile.write('TextX=%d,\n' % (self.TextX,))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            showIndent(outfile, level)
            outfile.write('TextY=%d,\n' % (self.TextY,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IconStyle is not None:
            showIndent(outfile, level)
            outfile.write('IconStyle=model_.IconStyle(\n')
            self.IconStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TextX', node)
        if value is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            try:
                self.TextX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TextY', node)
        if value is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            try:
                self.TextY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IconStyle':
            obj_ = IconStyle.factory()
            obj_.build(child_)
            self.IconStyle = obj_
            obj_.original_tagname_ = 'IconStyle'
# end class Icon


class IconPicture(GeneratedsSuper):
    """Picture stored with a chart item. Represents
    LNPictureOwner.Determines the custom size used for the
    picture.GUID identifying the base64 data in this element.The
    data for the picture stored with the chart item.The uncompressed
    length, in bytes, of the picture data.Determines which mechanism
    controls how a picture stored by the chart item is
    sized.Determines whether the picture should be shown on the
    icon."""
    subclass = None
    superclass = None
    def __init__(self, DataGuid=None, Visible=False, CustomSize=1.0, DataLength=None, Data=None, PictureSizeMethod='UseEnlargement'):
        self.original_tagname_ = None
        self.DataGuid = _cast(None, DataGuid)
        self.Visible = _cast(bool, Visible)
        self.CustomSize = _cast(float, CustomSize)
        self.DataLength = _cast(int, DataLength)
        self.Data = _cast(None, Data)
        self.PictureSizeMethod = _cast(None, PictureSizeMethod)
    def factory(*args_, **kwargs_):
        if IconPicture.subclass:
            return IconPicture.subclass(*args_, **kwargs_)
        else:
            return IconPicture(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataGuid(self): return self.DataGuid
    def set_DataGuid(self, DataGuid): self.DataGuid = DataGuid
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_CustomSize(self): return self.CustomSize
    def set_CustomSize(self, CustomSize): self.CustomSize = CustomSize
    def get_DataLength(self): return self.DataLength
    def set_DataLength(self, DataLength): self.DataLength = DataLength
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_PictureSizeMethod(self): return self.PictureSizeMethod
    def set_PictureSizeMethod(self, PictureSizeMethod): self.PictureSizeMethod = PictureSizeMethod
    def validate_PictureSizeMethodEnum(self, value):
        # Validate type PictureSizeMethodEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IconPicture', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IconPicture')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IconPicture', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IconPicture'):
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            outfile.write(' DataGuid=%s' % (self.gds_format_string(quote_attrib(self.DataGuid).encode(ExternalEncoding), input_name='DataGuid'), ))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.CustomSize is not None and 'CustomSize' not in already_processed:
            already_processed.add('CustomSize')
            outfile.write(' CustomSize="%s"' % self.gds_format_double(self.CustomSize, input_name='CustomSize'))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            outfile.write(' DataLength="%s"' % self.gds_format_integer(self.DataLength, input_name='DataLength'))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            outfile.write(' Data=%s' % (quote_attrib(self.Data), ))
        if self.PictureSizeMethod is not None and 'PictureSizeMethod' not in already_processed:
            already_processed.add('PictureSizeMethod')
            outfile.write(' PictureSizeMethod=%s' % (quote_attrib(self.PictureSizeMethod), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IconPicture', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IconPicture'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            showIndent(outfile, level)
            outfile.write('DataGuid="%s",\n' % (self.DataGuid,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.CustomSize is not None and 'CustomSize' not in already_processed:
            already_processed.add('CustomSize')
            showIndent(outfile, level)
            outfile.write('CustomSize=%e,\n' % (self.CustomSize,))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            showIndent(outfile, level)
            outfile.write('DataLength=%d,\n' % (self.DataLength,))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % (self.Data,))
        if self.PictureSizeMethod is not None and 'PictureSizeMethod' not in already_processed:
            already_processed.add('PictureSizeMethod')
            showIndent(outfile, level)
            outfile.write('PictureSizeMethod="%s",\n' % (self.PictureSizeMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataGuid', node)
        if value is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            self.DataGuid = value
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CustomSize', node)
        if value is not None and 'CustomSize' not in already_processed:
            already_processed.add('CustomSize')
            try:
                self.CustomSize = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CustomSize): %s' % exp)
        value = find_attr_value_('DataLength', node)
        if value is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            try:
                self.DataLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Data', node)
        if value is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            self.Data = value
        value = find_attr_value_('PictureSizeMethod', node)
        if value is not None and 'PictureSizeMethod' not in already_processed:
            already_processed.add('PictureSizeMethod')
            self.PictureSizeMethod = value
            self.validate_PictureSizeMethodEnum(self.PictureSizeMethod)    # validate type PictureSizeMethodEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IconPicture


class IconStyle(GeneratedsSuper):
    """Style of the icon chart item. Part of the LNCIStyle inheritance
    hierarchy.Scales the icon used to represent the type of the
    chart item.Type IDREF of entity used by this style. An entity
    type is a category of entity.Type of entity used by this style.
    An entity type is a category of entity.Colour used to override
    type's shaded icon colour."""
    subclass = None
    superclass = None
    def __init__(self, Enlargement=None, IconShadingColour=None, EntityTypeReference=None, Type=None, FrameStyle=None, IconPicture=None):
        self.original_tagname_ = None
        self.Enlargement = _cast(None, Enlargement)
        self.IconShadingColour = _cast(int, IconShadingColour)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.Type = _cast(None, Type)
        self.FrameStyle = FrameStyle
        self.IconPicture = IconPicture
    def factory(*args_, **kwargs_):
        if IconStyle.subclass:
            return IconStyle.subclass(*args_, **kwargs_)
        else:
            return IconStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FrameStyle(self): return self.FrameStyle
    def set_FrameStyle(self, FrameStyle): self.FrameStyle = FrameStyle
    def get_IconPicture(self): return self.IconPicture
    def set_IconPicture(self, IconPicture): self.IconPicture = IconPicture
    def get_Enlargement(self): return self.Enlargement
    def set_Enlargement(self, Enlargement): self.Enlargement = Enlargement
    def get_IconShadingColour(self): return self.IconShadingColour
    def set_IconShadingColour(self, IconShadingColour): self.IconShadingColour = IconShadingColour
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_IconEnlargementEnum(self, value):
        # Validate type IconEnlargementEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.FrameStyle is not None or
            self.IconPicture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IconStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IconStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IconStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IconStyle'):
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            outfile.write(' Enlargement=%s' % (quote_attrib(self.Enlargement), ))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            outfile.write(' IconShadingColour="%s"' % self.gds_format_integer(self.IconShadingColour, input_name='IconShadingColour'))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IconStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FrameStyle is not None:
            self.FrameStyle.export(outfile, level, namespace_, name_='FrameStyle', pretty_print=pretty_print)
        if self.IconPicture is not None:
            self.IconPicture.export(outfile, level, namespace_, name_='IconPicture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IconStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            showIndent(outfile, level)
            outfile.write('Enlargement="%s",\n' % (self.Enlargement,))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            showIndent(outfile, level)
            outfile.write('IconShadingColour=%d,\n' % (self.IconShadingColour,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FrameStyle is not None:
            showIndent(outfile, level)
            outfile.write('FrameStyle=model_.FrameStyle(\n')
            self.FrameStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IconPicture is not None:
            showIndent(outfile, level)
            outfile.write('IconPicture=model_.IconPicture(\n')
            self.IconPicture.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Enlargement', node)
        if value is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            self.Enlargement = value
            self.validate_IconEnlargementEnum(self.Enlargement)    # validate type IconEnlargementEnum
        value = find_attr_value_('IconShadingColour', node)
        if value is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            try:
                self.IconShadingColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FrameStyle':
            obj_ = FrameStyle.factory()
            obj_.build(child_)
            self.FrameStyle = obj_
            obj_.original_tagname_ = 'FrameStyle'
        elif nodeName_ == 'IconPicture':
            obj_ = IconPicture.factory()
            obj_.build(child_)
            self.IconPicture = obj_
            obj_.original_tagname_ = 'IconPicture'
# end class IconStyle


class Junction(GeneratedsSuper):
    """A junction, which is defined as the point where a link or connection
    is attached to a theme line."""
    subclass = None
    superclass = None
    def __init__(self, JunctionStyle=None):
        self.original_tagname_ = None
        self.JunctionStyle = JunctionStyle
    def factory(*args_, **kwargs_):
        if Junction.subclass:
            return Junction.subclass(*args_, **kwargs_)
        else:
            return Junction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JunctionStyle(self): return self.JunctionStyle
    def set_JunctionStyle(self, JunctionStyle): self.JunctionStyle = JunctionStyle
    def hasContent_(self):
        if (
            self.JunctionStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Junction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Junction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Junction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Junction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Junction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.JunctionStyle is not None:
            self.JunctionStyle.export(outfile, level, namespace_, name_='JunctionStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Junction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.JunctionStyle is not None:
            showIndent(outfile, level)
            outfile.write('JunctionStyle=model_.JunctionStyle(\n')
            self.JunctionStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JunctionStyle':
            obj_ = JunctionStyle.factory()
            obj_.build(child_)
            self.JunctionStyle = obj_
            obj_.original_tagname_ = 'JunctionStyle'
# end class Junction


class JunctionCollection(GeneratedsSuper):
    """Collection of junctions on the chart."""
    subclass = None
    superclass = None
    def __init__(self, ThemeJunctions=None):
        self.original_tagname_ = None
        if ThemeJunctions is None:
            self.ThemeJunctions = []
        else:
            self.ThemeJunctions = ThemeJunctions
    def factory(*args_, **kwargs_):
        if JunctionCollection.subclass:
            return JunctionCollection.subclass(*args_, **kwargs_)
        else:
            return JunctionCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThemeJunctions(self): return self.ThemeJunctions
    def set_ThemeJunctions(self, ThemeJunctions): self.ThemeJunctions = ThemeJunctions
    def add_ThemeJunctions(self, value): self.ThemeJunctions.append(value)
    def insert_ThemeJunctions(self, index, value): self.ThemeJunctions[index] = value
    def hasContent_(self):
        if (
            self.ThemeJunctions
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='JunctionCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JunctionCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='JunctionCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JunctionCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JunctionCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ThemeJunctions_ in self.ThemeJunctions:
            ThemeJunctions_.export(outfile, level, namespace_, name_='ThemeJunctions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='JunctionCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ThemeJunctions=[\n')
        level += 1
        for ThemeJunctions_ in self.ThemeJunctions:
            showIndent(outfile, level)
            outfile.write('model_.ThemeJunctions(\n')
            ThemeJunctions_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThemeJunctions':
            obj_ = ThemeJunctions.factory()
            obj_.build(child_)
            self.ThemeJunctions.append(obj_)
            obj_.original_tagname_ = 'ThemeJunctions'
# end class JunctionCollection


class JunctionStyle(GeneratedsSuper):
    """Style of the junction.Color of the theme line segment after this
    junction if ThemeColourAfter is set to StyleCustom.Line width of
    the theme line segment after this junction if
    ThemeLineWidthAfter is set to StyleCustom.Strength of the theme
    line segment after this junction if ThemeStrengthAfter is set to
    StyleCustom.Strength IDREF of the theme line segment after this
    junction if ThemeStrengthAfter is set to StyleCustom.Determines
    what style setting controls the color of the theme line segment
    after this junction.Determines what style setting controls the
    line width of the theme line segment after this
    junction.Determines what style setting controls the strength of
    the theme line segment after this junction."""
    subclass = None
    superclass = None
    def __init__(self, Strength=None, StrengthReference=None, ThemeStrengthAfter='StyleCustom', Colour=None, ThemeColourAfter='StyleCustom', ThemeLineWidthAfter='StyleCustom', LineWidth=None):
        self.original_tagname_ = None
        self.Strength = _cast(None, Strength)
        self.StrengthReference = _cast(None, StrengthReference)
        self.ThemeStrengthAfter = _cast(None, ThemeStrengthAfter)
        self.Colour = _cast(int, Colour)
        self.ThemeColourAfter = _cast(None, ThemeColourAfter)
        self.ThemeLineWidthAfter = _cast(None, ThemeLineWidthAfter)
        self.LineWidth = _cast(int, LineWidth)
    def factory(*args_, **kwargs_):
        if JunctionStyle.subclass:
            return JunctionStyle.subclass(*args_, **kwargs_)
        else:
            return JunctionStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_ThemeStrengthAfter(self): return self.ThemeStrengthAfter
    def set_ThemeStrengthAfter(self, ThemeStrengthAfter): self.ThemeStrengthAfter = ThemeStrengthAfter
    def get_Colour(self): return self.Colour
    def set_Colour(self, Colour): self.Colour = Colour
    def get_ThemeColourAfter(self): return self.ThemeColourAfter
    def set_ThemeColourAfter(self, ThemeColourAfter): self.ThemeColourAfter = ThemeColourAfter
    def get_ThemeLineWidthAfter(self): return self.ThemeLineWidthAfter
    def set_ThemeLineWidthAfter(self, ThemeLineWidthAfter): self.ThemeLineWidthAfter = ThemeLineWidthAfter
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def validate_JunctionOptionEnum(self, value):
        # Validate type JunctionOptionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='JunctionStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JunctionStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='JunctionStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JunctionStyle'):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.ThemeStrengthAfter is not None and 'ThemeStrengthAfter' not in already_processed:
            already_processed.add('ThemeStrengthAfter')
            outfile.write(' ThemeStrengthAfter=%s' % (quote_attrib(self.ThemeStrengthAfter), ))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            outfile.write(' Colour="%s"' % self.gds_format_integer(self.Colour, input_name='Colour'))
        if self.ThemeColourAfter is not None and 'ThemeColourAfter' not in already_processed:
            already_processed.add('ThemeColourAfter')
            outfile.write(' ThemeColourAfter=%s' % (quote_attrib(self.ThemeColourAfter), ))
        if self.ThemeLineWidthAfter is not None and 'ThemeLineWidthAfter' not in already_processed:
            already_processed.add('ThemeLineWidthAfter')
            outfile.write(' ThemeLineWidthAfter=%s' % (quote_attrib(self.ThemeLineWidthAfter), ))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
    def exportChildren(self, outfile, level, namespace_='', name_='JunctionStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='JunctionStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.ThemeStrengthAfter is not None and 'ThemeStrengthAfter' not in already_processed:
            already_processed.add('ThemeStrengthAfter')
            showIndent(outfile, level)
            outfile.write('ThemeStrengthAfter="%s",\n' % (self.ThemeStrengthAfter,))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            showIndent(outfile, level)
            outfile.write('Colour=%d,\n' % (self.Colour,))
        if self.ThemeColourAfter is not None and 'ThemeColourAfter' not in already_processed:
            already_processed.add('ThemeColourAfter')
            showIndent(outfile, level)
            outfile.write('ThemeColourAfter="%s",\n' % (self.ThemeColourAfter,))
        if self.ThemeLineWidthAfter is not None and 'ThemeLineWidthAfter' not in already_processed:
            already_processed.add('ThemeLineWidthAfter')
            showIndent(outfile, level)
            outfile.write('ThemeLineWidthAfter="%s",\n' % (self.ThemeLineWidthAfter,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('ThemeStrengthAfter', node)
        if value is not None and 'ThemeStrengthAfter' not in already_processed:
            already_processed.add('ThemeStrengthAfter')
            self.ThemeStrengthAfter = value
            self.validate_JunctionOptionEnum(self.ThemeStrengthAfter)    # validate type JunctionOptionEnum
        value = find_attr_value_('Colour', node)
        if value is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            try:
                self.Colour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ThemeColourAfter', node)
        if value is not None and 'ThemeColourAfter' not in already_processed:
            already_processed.add('ThemeColourAfter')
            self.ThemeColourAfter = value
            self.validate_JunctionOptionEnum(self.ThemeColourAfter)    # validate type JunctionOptionEnum
        value = find_attr_value_('ThemeLineWidthAfter', node)
        if value is not None and 'ThemeLineWidthAfter' not in already_processed:
            already_processed.add('ThemeLineWidthAfter')
            self.ThemeLineWidthAfter = value
            self.validate_JunctionOptionEnum(self.ThemeLineWidthAfter)    # validate type JunctionOptionEnum
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JunctionStyle


class Key(GeneratedsSuper):
    """The key parts of a database key.Returns the i'th member of this key.
    Index is 0-based."""
    subclass = None
    superclass = None
    def __init__(self, Item=None):
        self.original_tagname_ = None
        self.Item = _cast(None, Item)
    def factory(*args_, **kwargs_):
        if Key.subclass:
            return Key.subclass(*args_, **kwargs_)
        else:
            return Key(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Key', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Key')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Key', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Key'):
        if self.Item is not None and 'Item' not in already_processed:
            already_processed.add('Item')
            outfile.write(' Item=%s' % (self.gds_format_string(quote_attrib(self.Item).encode(ExternalEncoding), input_name='Item'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Key', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Key'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Item is not None and 'Item' not in already_processed:
            already_processed.add('Item')
            showIndent(outfile, level)
            outfile.write('Item="%s",\n' % (self.Item,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Item', node)
        if value is not None and 'Item' not in already_processed:
            already_processed.add('Item')
            self.Item = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Key


class Label(GeneratedsSuper):
    """The label chart item object. Part of the chart item inheritance
    hierarchy.Label ID that can be used when IdReferenceLinking is
    False."""
    subclass = None
    superclass = None
    def __init__(self, LabelId=None, LabelStyle=None):
        self.original_tagname_ = None
        self.LabelId = _cast(None, LabelId)
        self.LabelStyle = LabelStyle
    def factory(*args_, **kwargs_):
        if Label.subclass:
            return Label.subclass(*args_, **kwargs_)
        else:
            return Label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LabelStyle(self): return self.LabelStyle
    def set_LabelStyle(self, LabelStyle): self.LabelStyle = LabelStyle
    def get_LabelId(self): return self.LabelId
    def set_LabelId(self, LabelId): self.LabelId = LabelId
    def hasContent_(self):
        if (
            self.LabelStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Label', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Label'):
        if self.LabelId is not None and 'LabelId' not in already_processed:
            already_processed.add('LabelId')
            outfile.write(' LabelId=%s' % (self.gds_format_string(quote_attrib(self.LabelId).encode(ExternalEncoding), input_name='LabelId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LabelStyle is not None:
            self.LabelStyle.export(outfile, level, namespace_, name_='LabelStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Label'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LabelId is not None and 'LabelId' not in already_processed:
            already_processed.add('LabelId')
            showIndent(outfile, level)
            outfile.write('LabelId="%s",\n' % (self.LabelId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LabelStyle is not None:
            showIndent(outfile, level)
            outfile.write('LabelStyle=model_.LabelStyle(\n')
            self.LabelStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LabelId', node)
        if value is not None and 'LabelId' not in already_processed:
            already_processed.add('LabelId')
            self.LabelId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LabelStyle':
            obj_ = LabelStyle.factory()
            obj_.build(child_)
            self.LabelStyle = obj_
            obj_.original_tagname_ = 'LabelStyle'
# end class Label


class LabelStyle(GeneratedsSuper):
    """Style of the label. Part of the LNCIStyle inheritance hierarchy.Text
    alignment setting for the label text."""
    subclass = None
    superclass = None
    def __init__(self, Alignment=None):
        self.original_tagname_ = None
        self.Alignment = _cast(None, Alignment)
    def factory(*args_, **kwargs_):
        if LabelStyle.subclass:
            return LabelStyle.subclass(*args_, **kwargs_)
        else:
            return LabelStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Alignment(self): return self.Alignment
    def set_Alignment(self, Alignment): self.Alignment = Alignment
    def validate_TextAlignmentEnum(self, value):
        # Validate type TextAlignmentEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LabelStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LabelStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LabelStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LabelStyle'):
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            outfile.write(' Alignment=%s' % (quote_attrib(self.Alignment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LabelStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LabelStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            showIndent(outfile, level)
            outfile.write('Alignment="%s",\n' % (self.Alignment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Alignment', node)
        if value is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            self.Alignment = value
            self.validate_TextAlignmentEnum(self.Alignment)    # validate type TextAlignmentEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LabelStyle


class LegendDefinition(GeneratedsSuper):
    """The legend settings for the chart.Arrangement setting for the
    legend.Horizontal alignment setting for the legend.If True, the
    legend is displayed.Vertical alignment setting for the legend.X
    position of the legend, expressed in world coordinates.Y
    position of the legend, expressed in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, Shown=True, VerticalAlignment='LegendAlignmentBottom', X=0, Y=0, HorizontalAlignment='LegendAlignmentRight', Arrange='LegendArrangementSquare', Font=None, LegendItem=None):
        self.original_tagname_ = None
        self.Shown = _cast(bool, Shown)
        self.VerticalAlignment = _cast(None, VerticalAlignment)
        self.X = _cast(int, X)
        self.Y = _cast(int, Y)
        self.HorizontalAlignment = _cast(None, HorizontalAlignment)
        self.Arrange = _cast(None, Arrange)
        self.Font = Font
        if LegendItem is None:
            self.LegendItem = []
        else:
            self.LegendItem = LegendItem
    def factory(*args_, **kwargs_):
        if LegendDefinition.subclass:
            return LegendDefinition.subclass(*args_, **kwargs_)
        else:
            return LegendDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_LegendItem(self): return self.LegendItem
    def set_LegendItem(self, LegendItem): self.LegendItem = LegendItem
    def add_LegendItem(self, value): self.LegendItem.append(value)
    def insert_LegendItem(self, index, value): self.LegendItem[index] = value
    def get_Shown(self): return self.Shown
    def set_Shown(self, Shown): self.Shown = Shown
    def get_VerticalAlignment(self): return self.VerticalAlignment
    def set_VerticalAlignment(self, VerticalAlignment): self.VerticalAlignment = VerticalAlignment
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_HorizontalAlignment(self): return self.HorizontalAlignment
    def set_HorizontalAlignment(self, HorizontalAlignment): self.HorizontalAlignment = HorizontalAlignment
    def get_Arrange(self): return self.Arrange
    def set_Arrange(self, Arrange): self.Arrange = Arrange
    def validate_LegendVerticalAlignmentEnum(self, value):
        # Validate type LegendVerticalAlignmentEnum, a restriction on xsd:string.
        pass
    def validate_LegendHorizontalAlignmentEnum(self, value):
        # Validate type LegendHorizontalAlignmentEnum, a restriction on xsd:string.
        pass
    def validate_LegendArrangementEnum(self, value):
        # Validate type LegendArrangementEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.Font is not None or
            self.LegendItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegendDefinition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegendDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegendDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegendDefinition'):
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            outfile.write(' Shown="%s"' % self.gds_format_boolean(self.Shown, input_name='Shown'))
        if self.VerticalAlignment is not None and 'VerticalAlignment' not in already_processed:
            already_processed.add('VerticalAlignment')
            outfile.write(' VerticalAlignment=%s' % (quote_attrib(self.VerticalAlignment), ))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            outfile.write(' X="%s"' % self.gds_format_integer(self.X, input_name='X'))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            outfile.write(' Y="%s"' % self.gds_format_integer(self.Y, input_name='Y'))
        if self.HorizontalAlignment is not None and 'HorizontalAlignment' not in already_processed:
            already_processed.add('HorizontalAlignment')
            outfile.write(' HorizontalAlignment=%s' % (quote_attrib(self.HorizontalAlignment), ))
        if self.Arrange is not None and 'Arrange' not in already_processed:
            already_processed.add('Arrange')
            outfile.write(' Arrange=%s' % (quote_attrib(self.Arrange), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegendDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            self.Font.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
        for LegendItem_ in self.LegendItem:
            LegendItem_.export(outfile, level, namespace_, name_='LegendItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LegendDefinition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            showIndent(outfile, level)
            outfile.write('Shown=%s,\n' % (self.Shown,))
        if self.VerticalAlignment is not None and 'VerticalAlignment' not in already_processed:
            already_processed.add('VerticalAlignment')
            showIndent(outfile, level)
            outfile.write('VerticalAlignment="%s",\n' % (self.VerticalAlignment,))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            showIndent(outfile, level)
            outfile.write('X=%d,\n' % (self.X,))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            showIndent(outfile, level)
            outfile.write('Y=%d,\n' % (self.Y,))
        if self.HorizontalAlignment is not None and 'HorizontalAlignment' not in already_processed:
            already_processed.add('HorizontalAlignment')
            showIndent(outfile, level)
            outfile.write('HorizontalAlignment="%s",\n' % (self.HorizontalAlignment,))
        if self.Arrange is not None and 'Arrange' not in already_processed:
            already_processed.add('Arrange')
            showIndent(outfile, level)
            outfile.write('Arrange="%s",\n' % (self.Arrange,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Font is not None:
            showIndent(outfile, level)
            outfile.write('Font=model_.Font(\n')
            self.Font.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('LegendItem=[\n')
        level += 1
        for LegendItem_ in self.LegendItem:
            showIndent(outfile, level)
            outfile.write('model_.LegendItem(\n')
            LegendItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Shown', node)
        if value is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            if value in ('true', '1'):
                self.Shown = True
            elif value in ('false', '0'):
                self.Shown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('VerticalAlignment', node)
        if value is not None and 'VerticalAlignment' not in already_processed:
            already_processed.add('VerticalAlignment')
            self.VerticalAlignment = value
            self.validate_LegendVerticalAlignmentEnum(self.VerticalAlignment)    # validate type LegendVerticalAlignmentEnum
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('HorizontalAlignment', node)
        if value is not None and 'HorizontalAlignment' not in already_processed:
            already_processed.add('HorizontalAlignment')
            self.HorizontalAlignment = value
            self.validate_LegendHorizontalAlignmentEnum(self.HorizontalAlignment)    # validate type LegendHorizontalAlignmentEnum
        value = find_attr_value_('Arrange', node)
        if value is not None and 'Arrange' not in already_processed:
            already_processed.add('Arrange')
            self.Arrange = value
            self.validate_LegendArrangementEnum(self.Arrange)    # validate type LegendArrangementEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
        elif nodeName_ == 'LegendItem':
            obj_ = LegendItem.factory()
            obj_.build(child_)
            self.LegendItem.append(obj_)
            obj_.original_tagname_ = 'LegendItem'
# end class LegendDefinition


class LegendItem(GeneratedsSuper):
    """An item displayed in the legend.Shading colour for Icon legend
    entries.Whether a link in the legend has arrowheads on neither,
    either, or both ends.Color associated with an entity or link
    type in the legend.Line style used to represent a strength in
    the legend.Filename for the bitmap associated with an entity
    type, attribute class in the legend or the short name of a time
    zone entry.Text used as the label for an item in the
    legend.Width of the line used to draw the item in the
    legend.Type of the item in the legend."""
    subclass = None
    superclass = None
    def __init__(self, DashStyle='DotStyleSolid', Colour=0, Arrows='ArrowNone', Label=None, ImageName=None, IconShadingColour=None, LineWidth=1, Type=None, Font=None):
        self.original_tagname_ = None
        self.DashStyle = _cast(None, DashStyle)
        self.Colour = _cast(int, Colour)
        self.Arrows = _cast(None, Arrows)
        self.Label = _cast(None, Label)
        self.ImageName = _cast(None, ImageName)
        self.IconShadingColour = _cast(int, IconShadingColour)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
        self.Font = Font
    def factory(*args_, **kwargs_):
        if LegendItem.subclass:
            return LegendItem.subclass(*args_, **kwargs_)
        else:
            return LegendItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_DashStyle(self): return self.DashStyle
    def set_DashStyle(self, DashStyle): self.DashStyle = DashStyle
    def get_Colour(self): return self.Colour
    def set_Colour(self, Colour): self.Colour = Colour
    def get_Arrows(self): return self.Arrows
    def set_Arrows(self, Arrows): self.Arrows = Arrows
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_ImageName(self): return self.ImageName
    def set_ImageName(self, ImageName): self.ImageName = ImageName
    def get_IconShadingColour(self): return self.IconShadingColour
    def set_IconShadingColour(self, IconShadingColour): self.IconShadingColour = IconShadingColour
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_DotStyleEnum(self, value):
        # Validate type DotStyleEnum, a restriction on xsd:string.
        pass
    def validate_ArrowStyleEnum(self, value):
        # Validate type ArrowStyleEnum, a restriction on xsd:string.
        pass
    def validate_LegendItemTypeEnum(self, value):
        # Validate type LegendItemTypeEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.Font is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegendItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegendItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegendItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegendItem'):
        if self.DashStyle is not None and 'DashStyle' not in already_processed:
            already_processed.add('DashStyle')
            outfile.write(' DashStyle=%s' % (quote_attrib(self.DashStyle), ))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            outfile.write(' Colour="%s"' % self.gds_format_integer(self.Colour, input_name='Colour'))
        if self.Arrows is not None and 'Arrows' not in already_processed:
            already_processed.add('Arrows')
            outfile.write(' Arrows=%s' % (quote_attrib(self.Arrows), ))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            outfile.write(' Label=%s' % (self.gds_format_string(quote_attrib(self.Label).encode(ExternalEncoding), input_name='Label'), ))
        if self.ImageName is not None and 'ImageName' not in already_processed:
            already_processed.add('ImageName')
            outfile.write(' ImageName=%s' % (self.gds_format_string(quote_attrib(self.ImageName).encode(ExternalEncoding), input_name='ImageName'), ))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            outfile.write(' IconShadingColour="%s"' % self.gds_format_integer(self.IconShadingColour, input_name='IconShadingColour'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegendItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            self.Font.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LegendItem'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DashStyle is not None and 'DashStyle' not in already_processed:
            already_processed.add('DashStyle')
            showIndent(outfile, level)
            outfile.write('DashStyle="%s",\n' % (self.DashStyle,))
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            showIndent(outfile, level)
            outfile.write('Colour=%d,\n' % (self.Colour,))
        if self.Arrows is not None and 'Arrows' not in already_processed:
            already_processed.add('Arrows')
            showIndent(outfile, level)
            outfile.write('Arrows="%s",\n' % (self.Arrows,))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            showIndent(outfile, level)
            outfile.write('Label="%s",\n' % (self.Label,))
        if self.ImageName is not None and 'ImageName' not in already_processed:
            already_processed.add('ImageName')
            showIndent(outfile, level)
            outfile.write('ImageName="%s",\n' % (self.ImageName,))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            showIndent(outfile, level)
            outfile.write('IconShadingColour=%d,\n' % (self.IconShadingColour,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Font is not None:
            showIndent(outfile, level)
            outfile.write('Font=model_.Font(\n')
            self.Font.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DashStyle', node)
        if value is not None and 'DashStyle' not in already_processed:
            already_processed.add('DashStyle')
            self.DashStyle = value
            self.validate_DotStyleEnum(self.DashStyle)    # validate type DotStyleEnum
        value = find_attr_value_('Colour', node)
        if value is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            try:
                self.Colour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Arrows', node)
        if value is not None and 'Arrows' not in already_processed:
            already_processed.add('Arrows')
            self.Arrows = value
            self.validate_ArrowStyleEnum(self.Arrows)    # validate type ArrowStyleEnum
        value = find_attr_value_('Label', node)
        if value is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            self.Label = value
        value = find_attr_value_('ImageName', node)
        if value is not None and 'ImageName' not in already_processed:
            already_processed.add('ImageName')
            self.ImageName = value
        value = find_attr_value_('IconShadingColour', node)
        if value is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            try:
                self.IconShadingColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_LegendItemTypeEnum(self.Type)    # validate type LegendItemTypeEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
# end class LegendItem


class Link(GeneratedsSuper):
    """A link between two end items. Part of the chart item inheritance
    hierarchy.Connection IDREF that the link is part of.End1 ID that
    can be used when IdReferenceLinking is False (see EntityId and
    LabelId).One end IDREF of the connection.End2 ID that can be
    used when IdReferenceLinking is False (see EntityId and
    LabelId).Other end IDREF of the connection.Proportional position
    of the label along the link, expressed in terms of points. The
    possible range of points is from 0 to 100.Segment of the link on
    which the label is positioned. The segment value range is from 0
    to CornerCount. An invalid segment value raises a run-time
    error.Offset of this link from the center line, expressed in
    world coordinates.The link semantic type assigned to this link."""
    subclass = None
    superclass = None
    def __init__(self, End2Reference=None, End1Reference=None, SemanticTypeGuid=None, End1Id=None, LabelSegment=0, LabelPos=50, End2Id=None, Offset=None, ConnectionReference=None, DatabaseKeyCollection=None, CardCollection=None, CornerCollection=None, LinkStyle=None):
        self.original_tagname_ = None
        self.End2Reference = _cast(None, End2Reference)
        self.End1Reference = _cast(None, End1Reference)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.End1Id = _cast(None, End1Id)
        self.LabelSegment = _cast(int, LabelSegment)
        self.LabelPos = _cast(int, LabelPos)
        self.End2Id = _cast(None, End2Id)
        self.Offset = _cast(int, Offset)
        self.ConnectionReference = _cast(None, ConnectionReference)
        self.DatabaseKeyCollection = DatabaseKeyCollection
        self.CardCollection = CardCollection
        self.CornerCollection = CornerCollection
        self.LinkStyle = LinkStyle
    def factory(*args_, **kwargs_):
        if Link.subclass:
            return Link.subclass(*args_, **kwargs_)
        else:
            return Link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseKeyCollection(self): return self.DatabaseKeyCollection
    def set_DatabaseKeyCollection(self, DatabaseKeyCollection): self.DatabaseKeyCollection = DatabaseKeyCollection
    def get_CardCollection(self): return self.CardCollection
    def set_CardCollection(self, CardCollection): self.CardCollection = CardCollection
    def get_CornerCollection(self): return self.CornerCollection
    def set_CornerCollection(self, CornerCollection): self.CornerCollection = CornerCollection
    def get_LinkStyle(self): return self.LinkStyle
    def set_LinkStyle(self, LinkStyle): self.LinkStyle = LinkStyle
    def get_End2Reference(self): return self.End2Reference
    def set_End2Reference(self, End2Reference): self.End2Reference = End2Reference
    def get_End1Reference(self): return self.End1Reference
    def set_End1Reference(self, End1Reference): self.End1Reference = End1Reference
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_End1Id(self): return self.End1Id
    def set_End1Id(self, End1Id): self.End1Id = End1Id
    def get_LabelSegment(self): return self.LabelSegment
    def set_LabelSegment(self, LabelSegment): self.LabelSegment = LabelSegment
    def get_LabelPos(self): return self.LabelPos
    def set_LabelPos(self, LabelPos): self.LabelPos = LabelPos
    def get_End2Id(self): return self.End2Id
    def set_End2Id(self, End2Id): self.End2Id = End2Id
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_ConnectionReference(self): return self.ConnectionReference
    def set_ConnectionReference(self, ConnectionReference): self.ConnectionReference = ConnectionReference
    def hasContent_(self):
        if (
            self.DatabaseKeyCollection is not None or
            self.CardCollection is not None or
            self.CornerCollection is not None or
            self.LinkStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Link', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Link'):
        if self.End2Reference is not None and 'End2Reference' not in already_processed:
            already_processed.add('End2Reference')
            outfile.write(' End2Reference=%s' % (self.gds_format_string(quote_attrib(self.End2Reference).encode(ExternalEncoding), input_name='End2Reference'), ))
        if self.End1Reference is not None and 'End1Reference' not in already_processed:
            already_processed.add('End1Reference')
            outfile.write(' End1Reference=%s' % (self.gds_format_string(quote_attrib(self.End1Reference).encode(ExternalEncoding), input_name='End1Reference'), ))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.End1Id is not None and 'End1Id' not in already_processed:
            already_processed.add('End1Id')
            outfile.write(' End1Id=%s' % (self.gds_format_string(quote_attrib(self.End1Id).encode(ExternalEncoding), input_name='End1Id'), ))
        if self.LabelSegment is not None and 'LabelSegment' not in already_processed:
            already_processed.add('LabelSegment')
            outfile.write(' LabelSegment="%s"' % self.gds_format_integer(self.LabelSegment, input_name='LabelSegment'))
        if self.LabelPos is not None and 'LabelPos' not in already_processed:
            already_processed.add('LabelPos')
            outfile.write(' LabelPos="%s"' % self.gds_format_integer(self.LabelPos, input_name='LabelPos'))
        if self.End2Id is not None and 'End2Id' not in already_processed:
            already_processed.add('End2Id')
            outfile.write(' End2Id=%s' % (self.gds_format_string(quote_attrib(self.End2Id).encode(ExternalEncoding), input_name='End2Id'), ))
        if self.Offset is not None and 'Offset' not in already_processed:
            already_processed.add('Offset')
            outfile.write(' Offset="%s"' % self.gds_format_integer(self.Offset, input_name='Offset'))
        if self.ConnectionReference is not None and 'ConnectionReference' not in already_processed:
            already_processed.add('ConnectionReference')
            outfile.write(' ConnectionReference=%s' % (self.gds_format_string(quote_attrib(self.ConnectionReference).encode(ExternalEncoding), input_name='ConnectionReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DatabaseKeyCollection is not None:
            self.DatabaseKeyCollection.export(outfile, level, namespace_, name_='DatabaseKeyCollection', pretty_print=pretty_print)
        if self.CardCollection is not None:
            self.CardCollection.export(outfile, level, namespace_, name_='CardCollection', pretty_print=pretty_print)
        if self.CornerCollection is not None:
            self.CornerCollection.export(outfile, level, namespace_, name_='CornerCollection', pretty_print=pretty_print)
        if self.LinkStyle is not None:
            self.LinkStyle.export(outfile, level, namespace_, name_='LinkStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Link'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.End2Reference is not None and 'End2Reference' not in already_processed:
            already_processed.add('End2Reference')
            showIndent(outfile, level)
            outfile.write('End2Reference="%s",\n' % (self.End2Reference,))
        if self.End1Reference is not None and 'End1Reference' not in already_processed:
            already_processed.add('End1Reference')
            showIndent(outfile, level)
            outfile.write('End1Reference="%s",\n' % (self.End1Reference,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.End1Id is not None and 'End1Id' not in already_processed:
            already_processed.add('End1Id')
            showIndent(outfile, level)
            outfile.write('End1Id="%s",\n' % (self.End1Id,))
        if self.LabelSegment is not None and 'LabelSegment' not in already_processed:
            already_processed.add('LabelSegment')
            showIndent(outfile, level)
            outfile.write('LabelSegment=%d,\n' % (self.LabelSegment,))
        if self.LabelPos is not None and 'LabelPos' not in already_processed:
            already_processed.add('LabelPos')
            showIndent(outfile, level)
            outfile.write('LabelPos=%d,\n' % (self.LabelPos,))
        if self.End2Id is not None and 'End2Id' not in already_processed:
            already_processed.add('End2Id')
            showIndent(outfile, level)
            outfile.write('End2Id="%s",\n' % (self.End2Id,))
        if self.Offset is not None and 'Offset' not in already_processed:
            already_processed.add('Offset')
            showIndent(outfile, level)
            outfile.write('Offset=%d,\n' % (self.Offset,))
        if self.ConnectionReference is not None and 'ConnectionReference' not in already_processed:
            already_processed.add('ConnectionReference')
            showIndent(outfile, level)
            outfile.write('ConnectionReference="%s",\n' % (self.ConnectionReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DatabaseKeyCollection is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseKeyCollection=model_.DatabaseKeyCollection(\n')
            self.DatabaseKeyCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CardCollection is not None:
            showIndent(outfile, level)
            outfile.write('CardCollection=model_.CardCollection(\n')
            self.CardCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CornerCollection is not None:
            showIndent(outfile, level)
            outfile.write('CornerCollection=model_.CornerCollection(\n')
            self.CornerCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinkStyle is not None:
            showIndent(outfile, level)
            outfile.write('LinkStyle=model_.LinkStyle(\n')
            self.LinkStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('End2Reference', node)
        if value is not None and 'End2Reference' not in already_processed:
            already_processed.add('End2Reference')
            self.End2Reference = value
        value = find_attr_value_('End1Reference', node)
        if value is not None and 'End1Reference' not in already_processed:
            already_processed.add('End1Reference')
            self.End1Reference = value
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('End1Id', node)
        if value is not None and 'End1Id' not in already_processed:
            already_processed.add('End1Id')
            self.End1Id = value
        value = find_attr_value_('LabelSegment', node)
        if value is not None and 'LabelSegment' not in already_processed:
            already_processed.add('LabelSegment')
            try:
                self.LabelSegment = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LabelPos', node)
        if value is not None and 'LabelPos' not in already_processed:
            already_processed.add('LabelPos')
            try:
                self.LabelPos = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('End2Id', node)
        if value is not None and 'End2Id' not in already_processed:
            already_processed.add('End2Id')
            self.End2Id = value
        value = find_attr_value_('Offset', node)
        if value is not None and 'Offset' not in already_processed:
            already_processed.add('Offset')
            try:
                self.Offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ConnectionReference', node)
        if value is not None and 'ConnectionReference' not in already_processed:
            already_processed.add('ConnectionReference')
            self.ConnectionReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseKeyCollection':
            obj_ = DatabaseKeyCollection.factory()
            obj_.build(child_)
            self.DatabaseKeyCollection = obj_
            obj_.original_tagname_ = 'DatabaseKeyCollection'
        elif nodeName_ == 'CardCollection':
            obj_ = CardCollection.factory()
            obj_.build(child_)
            self.CardCollection = obj_
            obj_.original_tagname_ = 'CardCollection'
        elif nodeName_ == 'CornerCollection':
            obj_ = CornerCollection.factory()
            obj_.build(child_)
            self.CornerCollection = obj_
            obj_.original_tagname_ = 'CornerCollection'
        elif nodeName_ == 'LinkStyle':
            obj_ = LinkStyle.factory()
            obj_.build(child_)
            self.LinkStyle = obj_
            obj_.original_tagname_ = 'LinkStyle'
# end class Link


class LinkObjects(GeneratedsSuper):
    """Collection of link object proxies supported by this database proxy."""
    subclass = None
    superclass = None
    def __init__(self, DatabaseObjectProxy=None):
        self.original_tagname_ = None
        if DatabaseObjectProxy is None:
            self.DatabaseObjectProxy = []
        else:
            self.DatabaseObjectProxy = DatabaseObjectProxy
    def factory(*args_, **kwargs_):
        if LinkObjects.subclass:
            return LinkObjects.subclass(*args_, **kwargs_)
        else:
            return LinkObjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseObjectProxy(self): return self.DatabaseObjectProxy
    def set_DatabaseObjectProxy(self, DatabaseObjectProxy): self.DatabaseObjectProxy = DatabaseObjectProxy
    def add_DatabaseObjectProxy(self, value): self.DatabaseObjectProxy.append(value)
    def insert_DatabaseObjectProxy(self, index, value): self.DatabaseObjectProxy[index] = value
    def hasContent_(self):
        if (
            self.DatabaseObjectProxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkObjects', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkObjects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkObjects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkObjects'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkObjects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DatabaseObjectProxy_ in self.DatabaseObjectProxy:
            DatabaseObjectProxy_.export(outfile, level, namespace_, name_='DatabaseObjectProxy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkObjects'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DatabaseObjectProxy=[\n')
        level += 1
        for DatabaseObjectProxy_ in self.DatabaseObjectProxy:
            showIndent(outfile, level)
            outfile.write('model_.DatabaseObjectProxy(\n')
            DatabaseObjectProxy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseObjectProxy':
            obj_ = DatabaseObjectProxy.factory()
            obj_.build(child_)
            self.DatabaseObjectProxy.append(obj_)
            obj_.original_tagname_ = 'DatabaseObjectProxy'
# end class LinkObjects


class LinkStyle(GeneratedsSuper):
    """Style of the link. Part of the LNCIStyle inheritance
    hierarchy.Whether links of this link style have arrowheads on
    neither, either, or both ends.Deprecated. Use
    LNConnectionStyle.FanOut instead.Width of the line representing
    the link.Color of the line used to draw the chart item.Type
    IDREF of link used by this link style. A link type is a category
    of link.Deprecated. Use LNConnectionStyle.Multiplicity
    instead.Strength associated with the link, which controls the
    link line appearance.Strength IDREF associated with the link,
    which controls the link line appearance.Type of link used by
    this link style. A link type is a category of link."""
    subclass = None
    superclass = None
    def __init__(self, Strength=None, ArrowStyle=None, LinkTypeReference=None, StrengthReference=None, LineColour=None, MlStyle=None, FanOut=None, LineWidth=None, Type=None):
        self.original_tagname_ = None
        self.Strength = _cast(None, Strength)
        self.ArrowStyle = _cast(None, ArrowStyle)
        self.LinkTypeReference = _cast(None, LinkTypeReference)
        self.StrengthReference = _cast(None, StrengthReference)
        self.LineColour = _cast(int, LineColour)
        self.MlStyle = _cast(None, MlStyle)
        self.FanOut = _cast(int, FanOut)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if LinkStyle.subclass:
            return LinkStyle.subclass(*args_, **kwargs_)
        else:
            return LinkStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_ArrowStyle(self): return self.ArrowStyle
    def set_ArrowStyle(self, ArrowStyle): self.ArrowStyle = ArrowStyle
    def get_LinkTypeReference(self): return self.LinkTypeReference
    def set_LinkTypeReference(self, LinkTypeReference): self.LinkTypeReference = LinkTypeReference
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_MlStyle(self): return self.MlStyle
    def set_MlStyle(self, MlStyle): self.MlStyle = MlStyle
    def get_FanOut(self): return self.FanOut
    def set_FanOut(self, FanOut): self.FanOut = FanOut
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ArrowStyleEnum(self, value):
        # Validate type ArrowStyleEnum, a restriction on xsd:string.
        pass
    def validate_MultipleLinkStyleEnum(self, value):
        # Validate type MultipleLinkStyleEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkStyle'):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.ArrowStyle is not None and 'ArrowStyle' not in already_processed:
            already_processed.add('ArrowStyle')
            outfile.write(' ArrowStyle=%s' % (quote_attrib(self.ArrowStyle), ))
        if self.LinkTypeReference is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            outfile.write(' LinkTypeReference=%s' % (self.gds_format_string(quote_attrib(self.LinkTypeReference).encode(ExternalEncoding), input_name='LinkTypeReference'), ))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.MlStyle is not None and 'MlStyle' not in already_processed:
            already_processed.add('MlStyle')
            outfile.write(' MlStyle=%s' % (quote_attrib(self.MlStyle), ))
        if self.FanOut is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            outfile.write(' FanOut="%s"' % self.gds_format_integer(self.FanOut, input_name='FanOut'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LinkStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.ArrowStyle is not None and 'ArrowStyle' not in already_processed:
            already_processed.add('ArrowStyle')
            showIndent(outfile, level)
            outfile.write('ArrowStyle="%s",\n' % (self.ArrowStyle,))
        if self.LinkTypeReference is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            showIndent(outfile, level)
            outfile.write('LinkTypeReference="%s",\n' % (self.LinkTypeReference,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.MlStyle is not None and 'MlStyle' not in already_processed:
            already_processed.add('MlStyle')
            showIndent(outfile, level)
            outfile.write('MlStyle="%s",\n' % (self.MlStyle,))
        if self.FanOut is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            showIndent(outfile, level)
            outfile.write('FanOut=%d,\n' % (self.FanOut,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('ArrowStyle', node)
        if value is not None and 'ArrowStyle' not in already_processed:
            already_processed.add('ArrowStyle')
            self.ArrowStyle = value
            self.validate_ArrowStyleEnum(self.ArrowStyle)    # validate type ArrowStyleEnum
        value = find_attr_value_('LinkTypeReference', node)
        if value is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            self.LinkTypeReference = value
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MlStyle', node)
        if value is not None and 'MlStyle' not in already_processed:
            already_processed.add('MlStyle')
            self.MlStyle = value
            self.validate_MultipleLinkStyleEnum(self.MlStyle)    # validate type MultipleLinkStyleEnum
        value = find_attr_value_('FanOut', node)
        if value is not None and 'FanOut' not in already_processed:
            already_processed.add('FanOut')
            try:
                self.FanOut = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkStyle


class LinkType(GeneratedsSuper):
    """Link type, which is a category applied to links. A link type is part
    of a link style.Color associated with the link type.Link type ID
    (see IdReferenceLinking).Name of the link type. When the value
    is set, a run-time error is raised if the name already exists
    within the link type collection.The link semantic type assigned
    to this link type."""
    subclass = None
    superclass = None
    def __init__(self, Colour=0, SemanticTypeGuid=None, Id=None, Name=None):
        self.original_tagname_ = None
        self.Colour = _cast(int, Colour)
        self.SemanticTypeGuid = _cast(None, SemanticTypeGuid)
        self.Id = _cast(None, Id)
        self.Name = _cast(None, Name)
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Colour(self): return self.Colour
    def set_Colour(self, Colour): self.Colour = Colour
    def get_SemanticTypeGuid(self): return self.SemanticTypeGuid
    def set_SemanticTypeGuid(self, SemanticTypeGuid): self.SemanticTypeGuid = SemanticTypeGuid
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            outfile.write(' Colour="%s"' % self.gds_format_integer(self.Colour, input_name='Colour'))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            outfile.write(' SemanticTypeGuid=%s' % (quote_attrib(self.SemanticTypeGuid), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Colour is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            showIndent(outfile, level)
            outfile.write('Colour=%d,\n' % (self.Colour,))
        if self.SemanticTypeGuid is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            showIndent(outfile, level)
            outfile.write('SemanticTypeGuid="%s",\n' % (self.SemanticTypeGuid,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Colour', node)
        if value is not None and 'Colour' not in already_processed:
            already_processed.add('Colour')
            try:
                self.Colour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('SemanticTypeGuid', node)
        if value is not None and 'SemanticTypeGuid' not in already_processed:
            already_processed.add('SemanticTypeGuid')
            self.SemanticTypeGuid = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkType


class LinkTypeCollection(GeneratedsSuper):
    """Collection of all the link types associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, LinkType=None):
        self.original_tagname_ = None
        if LinkType is None:
            self.LinkType = []
        else:
            self.LinkType = LinkType
    def factory(*args_, **kwargs_):
        if LinkTypeCollection.subclass:
            return LinkTypeCollection.subclass(*args_, **kwargs_)
        else:
            return LinkTypeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinkType(self): return self.LinkType
    def set_LinkType(self, LinkType): self.LinkType = LinkType
    def add_LinkType(self, value): self.LinkType.append(value)
    def insert_LinkType(self, index, value): self.LinkType[index] = value
    def hasContent_(self):
        if (
            self.LinkType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkTypeCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkTypeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkTypeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkTypeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkTypeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkType_ in self.LinkType:
            LinkType_.export(outfile, level, namespace_, name_='LinkType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkTypeCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinkType=[\n')
        level += 1
        for LinkType_ in self.LinkType:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            LinkType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkType':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.LinkType.append(obj_)
            obj_.original_tagname_ = 'LinkType'
# end class LinkTypeCollection


class LinkTypeEntry(GeneratedsSuper):
    """Link type entry on a palette.Type of link used by this entry. A link
    type is a category of link.Type IDREF of link used by this
    entry. A link type is a category of link."""
    subclass = None
    superclass = None
    def __init__(self, LinkType=None, LinkTypeReference=None):
        self.original_tagname_ = None
        self.LinkType = _cast(None, LinkType)
        self.LinkTypeReference = _cast(None, LinkTypeReference)
    def factory(*args_, **kwargs_):
        if LinkTypeEntry.subclass:
            return LinkTypeEntry.subclass(*args_, **kwargs_)
        else:
            return LinkTypeEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinkType(self): return self.LinkType
    def set_LinkType(self, LinkType): self.LinkType = LinkType
    def get_LinkTypeReference(self): return self.LinkTypeReference
    def set_LinkTypeReference(self, LinkTypeReference): self.LinkTypeReference = LinkTypeReference
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkTypeEntry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkTypeEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkTypeEntry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkTypeEntry'):
        if self.LinkType is not None and 'LinkType' not in already_processed:
            already_processed.add('LinkType')
            outfile.write(' LinkType=%s' % (self.gds_format_string(quote_attrib(self.LinkType).encode(ExternalEncoding), input_name='LinkType'), ))
        if self.LinkTypeReference is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            outfile.write(' LinkTypeReference=%s' % (self.gds_format_string(quote_attrib(self.LinkTypeReference).encode(ExternalEncoding), input_name='LinkTypeReference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkTypeEntry', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LinkTypeEntry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LinkType is not None and 'LinkType' not in already_processed:
            already_processed.add('LinkType')
            showIndent(outfile, level)
            outfile.write('LinkType="%s",\n' % (self.LinkType,))
        if self.LinkTypeReference is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            showIndent(outfile, level)
            outfile.write('LinkTypeReference="%s",\n' % (self.LinkTypeReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LinkType', node)
        if value is not None and 'LinkType' not in already_processed:
            already_processed.add('LinkType')
            self.LinkType = value
        value = find_attr_value_('LinkTypeReference', node)
        if value is not None and 'LinkTypeReference' not in already_processed:
            already_processed.add('LinkTypeReference')
            self.LinkTypeReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkTypeEntry


class LinkTypeEntryCollection(GeneratedsSuper):
    """Collection of link type entries on this palette."""
    subclass = None
    superclass = None
    def __init__(self, LinkTypeEntry=None):
        self.original_tagname_ = None
        if LinkTypeEntry is None:
            self.LinkTypeEntry = []
        else:
            self.LinkTypeEntry = LinkTypeEntry
    def factory(*args_, **kwargs_):
        if LinkTypeEntryCollection.subclass:
            return LinkTypeEntryCollection.subclass(*args_, **kwargs_)
        else:
            return LinkTypeEntryCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinkTypeEntry(self): return self.LinkTypeEntry
    def set_LinkTypeEntry(self, LinkTypeEntry): self.LinkTypeEntry = LinkTypeEntry
    def add_LinkTypeEntry(self, value): self.LinkTypeEntry.append(value)
    def insert_LinkTypeEntry(self, index, value): self.LinkTypeEntry[index] = value
    def hasContent_(self):
        if (
            self.LinkTypeEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkTypeEntryCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkTypeEntryCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkTypeEntryCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkTypeEntryCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkTypeEntryCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkTypeEntry_ in self.LinkTypeEntry:
            LinkTypeEntry_.export(outfile, level, namespace_, name_='LinkTypeEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkTypeEntryCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinkTypeEntry=[\n')
        level += 1
        for LinkTypeEntry_ in self.LinkTypeEntry:
            showIndent(outfile, level)
            outfile.write('model_.LinkTypeEntry(\n')
            LinkTypeEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkTypeEntry':
            obj_ = LinkTypeEntry.factory()
            obj_.build(child_)
            self.LinkTypeEntry.append(obj_)
            obj_.original_tagname_ = 'LinkTypeEntry'
# end class LinkTypeEntryCollection


class OleItem(GeneratedsSuper):
    """An OLE object. Part of the chart item inheritance hierarchy.GUID
    identifying the base64 data in this element.The OLE object as
    stored in the item.Size, in bytes, of the OLE object.Height of
    the item in world coordinates.If True, the OLE object is
    compressed using ZLIB.If True, the OLE object on the chart is
    linked to the original file.The path specified when the OLE
    object was added to the chart as a linked item. If empty, the
    OLE object is embedded.The ProgID of the OLE object.X position
    of the label, relative to item position, in world coordinates.Y
    position of the label, relative to item position, in world
    coordinates.Width of the item in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, IsLinked=False, IsCompressed=False, Height=100, Width=100, ProgID=None, DataLength=0, Path=None, TextX=0, DataGuid=None, Data=None, TextY=3, OleItemStyle=None):
        self.original_tagname_ = None
        self.IsLinked = _cast(bool, IsLinked)
        self.IsCompressed = _cast(bool, IsCompressed)
        self.Height = _cast(int, Height)
        self.Width = _cast(int, Width)
        self.ProgID = _cast(None, ProgID)
        self.DataLength = _cast(int, DataLength)
        self.Path = _cast(None, Path)
        self.TextX = _cast(int, TextX)
        self.DataGuid = _cast(None, DataGuid)
        self.Data = _cast(None, Data)
        self.TextY = _cast(int, TextY)
        self.OleItemStyle = OleItemStyle
    def factory(*args_, **kwargs_):
        if OleItem.subclass:
            return OleItem.subclass(*args_, **kwargs_)
        else:
            return OleItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OleItemStyle(self): return self.OleItemStyle
    def set_OleItemStyle(self, OleItemStyle): self.OleItemStyle = OleItemStyle
    def get_IsLinked(self): return self.IsLinked
    def set_IsLinked(self, IsLinked): self.IsLinked = IsLinked
    def get_IsCompressed(self): return self.IsCompressed
    def set_IsCompressed(self, IsCompressed): self.IsCompressed = IsCompressed
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_ProgID(self): return self.ProgID
    def set_ProgID(self, ProgID): self.ProgID = ProgID
    def get_DataLength(self): return self.DataLength
    def set_DataLength(self, DataLength): self.DataLength = DataLength
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_TextX(self): return self.TextX
    def set_TextX(self, TextX): self.TextX = TextX
    def get_DataGuid(self): return self.DataGuid
    def set_DataGuid(self, DataGuid): self.DataGuid = DataGuid
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_TextY(self): return self.TextY
    def set_TextY(self, TextY): self.TextY = TextY
    def hasContent_(self):
        if (
            self.OleItemStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OleItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OleItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OleItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OleItem'):
        if self.IsLinked is not None and 'IsLinked' not in already_processed:
            already_processed.add('IsLinked')
            outfile.write(' IsLinked="%s"' % self.gds_format_boolean(self.IsLinked, input_name='IsLinked'))
        if self.IsCompressed is not None and 'IsCompressed' not in already_processed:
            already_processed.add('IsCompressed')
            outfile.write(' IsCompressed="%s"' % self.gds_format_boolean(self.IsCompressed, input_name='IsCompressed'))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            outfile.write(' Height="%s"' % self.gds_format_integer(self.Height, input_name='Height'))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            outfile.write(' Width="%s"' % self.gds_format_integer(self.Width, input_name='Width'))
        if self.ProgID is not None and 'ProgID' not in already_processed:
            already_processed.add('ProgID')
            outfile.write(' ProgID=%s' % (self.gds_format_string(quote_attrib(self.ProgID).encode(ExternalEncoding), input_name='ProgID'), ))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            outfile.write(' DataLength="%s"' % self.gds_format_integer(self.DataLength, input_name='DataLength'))
        if self.Path is not None and 'Path' not in already_processed:
            already_processed.add('Path')
            outfile.write(' Path=%s' % (self.gds_format_string(quote_attrib(self.Path).encode(ExternalEncoding), input_name='Path'), ))
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            outfile.write(' TextX="%s"' % self.gds_format_integer(self.TextX, input_name='TextX'))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            outfile.write(' DataGuid=%s' % (self.gds_format_string(quote_attrib(self.DataGuid).encode(ExternalEncoding), input_name='DataGuid'), ))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            outfile.write(' Data=%s' % (quote_attrib(self.Data), ))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            outfile.write(' TextY="%s"' % self.gds_format_integer(self.TextY, input_name='TextY'))
    def exportChildren(self, outfile, level, namespace_='', name_='OleItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OleItemStyle is not None:
            self.OleItemStyle.export(outfile, level, namespace_, name_='OleItemStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OleItem'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IsLinked is not None and 'IsLinked' not in already_processed:
            already_processed.add('IsLinked')
            showIndent(outfile, level)
            outfile.write('IsLinked=%s,\n' % (self.IsLinked,))
        if self.IsCompressed is not None and 'IsCompressed' not in already_processed:
            already_processed.add('IsCompressed')
            showIndent(outfile, level)
            outfile.write('IsCompressed=%s,\n' % (self.IsCompressed,))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            showIndent(outfile, level)
            outfile.write('Height=%d,\n' % (self.Height,))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            showIndent(outfile, level)
            outfile.write('Width=%d,\n' % (self.Width,))
        if self.ProgID is not None and 'ProgID' not in already_processed:
            already_processed.add('ProgID')
            showIndent(outfile, level)
            outfile.write('ProgID="%s",\n' % (self.ProgID,))
        if self.DataLength is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            showIndent(outfile, level)
            outfile.write('DataLength=%d,\n' % (self.DataLength,))
        if self.Path is not None and 'Path' not in already_processed:
            already_processed.add('Path')
            showIndent(outfile, level)
            outfile.write('Path="%s",\n' % (self.Path,))
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            showIndent(outfile, level)
            outfile.write('TextX=%d,\n' % (self.TextX,))
        if self.DataGuid is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            showIndent(outfile, level)
            outfile.write('DataGuid="%s",\n' % (self.DataGuid,))
        if self.Data is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % (self.Data,))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            showIndent(outfile, level)
            outfile.write('TextY=%d,\n' % (self.TextY,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OleItemStyle is not None:
            showIndent(outfile, level)
            outfile.write('OleItemStyle=model_.OleItemStyle(\n')
            self.OleItemStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IsLinked', node)
        if value is not None and 'IsLinked' not in already_processed:
            already_processed.add('IsLinked')
            if value in ('true', '1'):
                self.IsLinked = True
            elif value in ('false', '0'):
                self.IsLinked = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('IsCompressed', node)
        if value is not None and 'IsCompressed' not in already_processed:
            already_processed.add('IsCompressed')
            if value in ('true', '1'):
                self.IsCompressed = True
            elif value in ('false', '0'):
                self.IsCompressed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ProgID', node)
        if value is not None and 'ProgID' not in already_processed:
            already_processed.add('ProgID')
            self.ProgID = value
        value = find_attr_value_('DataLength', node)
        if value is not None and 'DataLength' not in already_processed:
            already_processed.add('DataLength')
            try:
                self.DataLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DataLength < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Path', node)
        if value is not None and 'Path' not in already_processed:
            already_processed.add('Path')
            self.Path = value
        value = find_attr_value_('TextX', node)
        if value is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            try:
                self.TextX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('DataGuid', node)
        if value is not None and 'DataGuid' not in already_processed:
            already_processed.add('DataGuid')
            self.DataGuid = value
        value = find_attr_value_('Data', node)
        if value is not None and 'Data' not in already_processed:
            already_processed.add('Data')
            self.Data = value
        value = find_attr_value_('TextY', node)
        if value is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            try:
                self.TextY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OleItemStyle':
            obj_ = OleItemStyle.factory()
            obj_.build(child_)
            self.OleItemStyle = obj_
            obj_.original_tagname_ = 'OleItemStyle'
# end class OleItem


class OleItemStyle(GeneratedsSuper):
    """Style of the OLE object. Part of the LNCIStyle inheritance
    hierarchy.Type IDREF of entity used by this style. An entity
    type is a category of entity.Width of the line drawn around the
    item.Color of the line used to draw the chart item.If True, the
    OLE object is shown as an icon. If False, display the OLE object
    itself.If True, a frame is shown around the OLE object.Strength
    associated with the OLE object, which controls the OLE object
    border appearance.Strength IDREF associated with the OLE object,
    which controls the OLE object border appearance.Type of entity
    used by this style. An entity type is a category of entity."""
    subclass = None
    superclass = None
    def __init__(self, Strength=None, ShowFrame=None, StrengthReference=None, EntityTypeReference=None, LineColour=None, LineWidth=None, Type=None, ShowAsIcon=None):
        self.original_tagname_ = None
        self.Strength = _cast(None, Strength)
        self.ShowFrame = _cast(bool, ShowFrame)
        self.StrengthReference = _cast(None, StrengthReference)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.LineColour = _cast(int, LineColour)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
        self.ShowAsIcon = _cast(bool, ShowAsIcon)
    def factory(*args_, **kwargs_):
        if OleItemStyle.subclass:
            return OleItemStyle.subclass(*args_, **kwargs_)
        else:
            return OleItemStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_ShowFrame(self): return self.ShowFrame
    def set_ShowFrame(self, ShowFrame): self.ShowFrame = ShowFrame
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ShowAsIcon(self): return self.ShowAsIcon
    def set_ShowAsIcon(self, ShowAsIcon): self.ShowAsIcon = ShowAsIcon
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OleItemStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OleItemStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OleItemStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OleItemStyle'):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.ShowFrame is not None and 'ShowFrame' not in already_processed:
            already_processed.add('ShowFrame')
            outfile.write(' ShowFrame="%s"' % self.gds_format_boolean(self.ShowFrame, input_name='ShowFrame'))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ShowAsIcon is not None and 'ShowAsIcon' not in already_processed:
            already_processed.add('ShowAsIcon')
            outfile.write(' ShowAsIcon="%s"' % self.gds_format_boolean(self.ShowAsIcon, input_name='ShowAsIcon'))
    def exportChildren(self, outfile, level, namespace_='', name_='OleItemStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='OleItemStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.ShowFrame is not None and 'ShowFrame' not in already_processed:
            already_processed.add('ShowFrame')
            showIndent(outfile, level)
            outfile.write('ShowFrame=%s,\n' % (self.ShowFrame,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ShowAsIcon is not None and 'ShowAsIcon' not in already_processed:
            already_processed.add('ShowAsIcon')
            showIndent(outfile, level)
            outfile.write('ShowAsIcon=%s,\n' % (self.ShowAsIcon,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('ShowFrame', node)
        if value is not None and 'ShowFrame' not in already_processed:
            already_processed.add('ShowFrame')
            if value in ('true', '1'):
                self.ShowFrame = True
            elif value in ('false', '0'):
                self.ShowFrame = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ShowAsIcon', node)
        if value is not None and 'ShowAsIcon' not in already_processed:
            already_processed.add('ShowAsIcon')
            if value in ('true', '1'):
                self.ShowAsIcon = True
            elif value in ('false', '0'):
                self.ShowAsIcon = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OleItemStyle


class Origin(GeneratedsSuper):
    """Date and time when the document was created.Total editing time in
    minutes since the chart was created.Date and time when the
    document was last printed.Date and time when the document was
    last saved.Number of times the document has been saved. A chart
    that has not been saved as well as a chart that has been saved
    once both return 1. Number increments with subsequent saves."""
    subclass = None
    superclass = None
    def __init__(self, EditTime=None, LastPrintDate=None, LastSaveDate=None, RevisionNumber=None, CreatedDate=None):
        self.original_tagname_ = None
        self.EditTime = _cast(int, EditTime)
        if isinstance(LastPrintDate, str):
            initvalue_ = datetime_.datetime.strptime(LastPrintDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LastPrintDate
        self.LastPrintDate = initvalue_
        if isinstance(LastSaveDate, str):
            initvalue_ = datetime_.datetime.strptime(LastSaveDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LastSaveDate
        self.LastSaveDate = initvalue_
        self.RevisionNumber = _cast(int, RevisionNumber)
        if isinstance(CreatedDate, str):
            initvalue_ = datetime_.datetime.strptime(CreatedDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CreatedDate
        self.CreatedDate = initvalue_
    def factory(*args_, **kwargs_):
        if Origin.subclass:
            return Origin.subclass(*args_, **kwargs_)
        else:
            return Origin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EditTime(self): return self.EditTime
    def set_EditTime(self, EditTime): self.EditTime = EditTime
    def get_LastPrintDate(self): return self.LastPrintDate
    def set_LastPrintDate(self, LastPrintDate): self.LastPrintDate = LastPrintDate
    def get_LastSaveDate(self): return self.LastSaveDate
    def set_LastSaveDate(self, LastSaveDate): self.LastSaveDate = LastSaveDate
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def get_CreatedDate(self): return self.CreatedDate
    def set_CreatedDate(self, CreatedDate): self.CreatedDate = CreatedDate
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Origin', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Origin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Origin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Origin'):
        if self.EditTime is not None and 'EditTime' not in already_processed:
            already_processed.add('EditTime')
            outfile.write(' EditTime="%s"' % self.gds_format_integer(self.EditTime, input_name='EditTime'))
        if self.LastPrintDate is not None and 'LastPrintDate' not in already_processed:
            already_processed.add('LastPrintDate')
            outfile.write(' LastPrintDate="%s"' % self.gds_format_datetime(self.LastPrintDate, input_name='LastPrintDate'))
        if self.LastSaveDate is not None and 'LastSaveDate' not in already_processed:
            already_processed.add('LastSaveDate')
            outfile.write(' LastSaveDate="%s"' % self.gds_format_datetime(self.LastSaveDate, input_name='LastSaveDate'))
        if self.RevisionNumber is not None and 'RevisionNumber' not in already_processed:
            already_processed.add('RevisionNumber')
            outfile.write(' RevisionNumber="%s"' % self.gds_format_integer(self.RevisionNumber, input_name='RevisionNumber'))
        if self.CreatedDate is not None and 'CreatedDate' not in already_processed:
            already_processed.add('CreatedDate')
            outfile.write(' CreatedDate="%s"' % self.gds_format_datetime(self.CreatedDate, input_name='CreatedDate'))
    def exportChildren(self, outfile, level, namespace_='', name_='Origin', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Origin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EditTime is not None and 'EditTime' not in already_processed:
            already_processed.add('EditTime')
            showIndent(outfile, level)
            outfile.write('EditTime=%d,\n' % (self.EditTime,))
        if self.LastPrintDate is not None and 'LastPrintDate' not in already_processed:
            already_processed.add('LastPrintDate')
            showIndent(outfile, level)
            outfile.write('LastPrintDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.LastPrintDate, input_name='LastPrintDate'))
        if self.LastSaveDate is not None and 'LastSaveDate' not in already_processed:
            already_processed.add('LastSaveDate')
            showIndent(outfile, level)
            outfile.write('LastSaveDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.LastSaveDate, input_name='LastSaveDate'))
        if self.RevisionNumber is not None and 'RevisionNumber' not in already_processed:
            already_processed.add('RevisionNumber')
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%d,\n' % (self.RevisionNumber,))
        if self.CreatedDate is not None and 'CreatedDate' not in already_processed:
            already_processed.add('CreatedDate')
            showIndent(outfile, level)
            outfile.write('CreatedDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.CreatedDate, input_name='CreatedDate'))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EditTime', node)
        if value is not None and 'EditTime' not in already_processed:
            already_processed.add('EditTime')
            try:
                self.EditTime = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LastPrintDate', node)
        if value is not None and 'LastPrintDate' not in already_processed:
            already_processed.add('LastPrintDate')
            try:
                self.LastPrintDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (LastPrintDate): %s' % exp)
        value = find_attr_value_('LastSaveDate', node)
        if value is not None and 'LastSaveDate' not in already_processed:
            already_processed.add('LastSaveDate')
            try:
                self.LastSaveDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (LastSaveDate): %s' % exp)
        value = find_attr_value_('RevisionNumber', node)
        if value is not None and 'RevisionNumber' not in already_processed:
            already_processed.add('RevisionNumber')
            try:
                self.RevisionNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CreatedDate', node)
        if value is not None and 'CreatedDate' not in already_processed:
            already_processed.add('CreatedDate')
            try:
                self.CreatedDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CreatedDate): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Origin


class PageSettings(GeneratedsSuper):
    """Page settings for the chart.Gap between bottom of the chart and
    bottom of page, expressed in 1/10 mm.Gap between left side of
    the chart and left side of page, expressed in 1/10
    mm.Orientation of the chart on the page.Number that indicates
    the paper size.String that is a description of paper size. For
    example, A4.Scale to apply to the page. Specify 100 for no
    reduction.Gap between right side of the chart and right side of
    page, expressed in 1/10 mm.Gap between top of the chart and top
    of page, expressed in 1/10 mm.Width of theme line, expressed in
    1/10mm."""
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, TopMargin=None, RightMargin=None, PaperSize=None, Reduction=None, PaperSizeString=None, ThemeNameWidth=None, BottomMargin=None, LeftMargin=None):
        self.original_tagname_ = None
        self.Orientation = _cast(None, Orientation)
        self.TopMargin = _cast(int, TopMargin)
        self.RightMargin = _cast(int, RightMargin)
        self.PaperSize = _cast(int, PaperSize)
        self.Reduction = _cast(int, Reduction)
        self.PaperSizeString = _cast(None, PaperSizeString)
        self.ThemeNameWidth = _cast(int, ThemeNameWidth)
        self.BottomMargin = _cast(int, BottomMargin)
        self.LeftMargin = _cast(int, LeftMargin)
    def factory(*args_, **kwargs_):
        if PageSettings.subclass:
            return PageSettings.subclass(*args_, **kwargs_)
        else:
            return PageSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_TopMargin(self): return self.TopMargin
    def set_TopMargin(self, TopMargin): self.TopMargin = TopMargin
    def get_RightMargin(self): return self.RightMargin
    def set_RightMargin(self, RightMargin): self.RightMargin = RightMargin
    def get_PaperSize(self): return self.PaperSize
    def set_PaperSize(self, PaperSize): self.PaperSize = PaperSize
    def get_Reduction(self): return self.Reduction
    def set_Reduction(self, Reduction): self.Reduction = Reduction
    def get_PaperSizeString(self): return self.PaperSizeString
    def set_PaperSizeString(self, PaperSizeString): self.PaperSizeString = PaperSizeString
    def get_ThemeNameWidth(self): return self.ThemeNameWidth
    def set_ThemeNameWidth(self, ThemeNameWidth): self.ThemeNameWidth = ThemeNameWidth
    def get_BottomMargin(self): return self.BottomMargin
    def set_BottomMargin(self, BottomMargin): self.BottomMargin = BottomMargin
    def get_LeftMargin(self): return self.LeftMargin
    def set_LeftMargin(self, LeftMargin): self.LeftMargin = LeftMargin
    def validate_PrintOrientationEnum(self, value):
        # Validate type PrintOrientationEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PageSettings', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PageSettings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageSettings'):
        if self.Orientation is not None and 'Orientation' not in already_processed:
            already_processed.add('Orientation')
            outfile.write(' Orientation=%s' % (quote_attrib(self.Orientation), ))
        if self.TopMargin is not None and 'TopMargin' not in already_processed:
            already_processed.add('TopMargin')
            outfile.write(' TopMargin="%s"' % self.gds_format_integer(self.TopMargin, input_name='TopMargin'))
        if self.RightMargin is not None and 'RightMargin' not in already_processed:
            already_processed.add('RightMargin')
            outfile.write(' RightMargin="%s"' % self.gds_format_integer(self.RightMargin, input_name='RightMargin'))
        if self.PaperSize is not None and 'PaperSize' not in already_processed:
            already_processed.add('PaperSize')
            outfile.write(' PaperSize="%s"' % self.gds_format_integer(self.PaperSize, input_name='PaperSize'))
        if self.Reduction is not None and 'Reduction' not in already_processed:
            already_processed.add('Reduction')
            outfile.write(' Reduction="%s"' % self.gds_format_integer(self.Reduction, input_name='Reduction'))
        if self.PaperSizeString is not None and 'PaperSizeString' not in already_processed:
            already_processed.add('PaperSizeString')
            outfile.write(' PaperSizeString=%s' % (self.gds_format_string(quote_attrib(self.PaperSizeString).encode(ExternalEncoding), input_name='PaperSizeString'), ))
        if self.ThemeNameWidth is not None and 'ThemeNameWidth' not in already_processed:
            already_processed.add('ThemeNameWidth')
            outfile.write(' ThemeNameWidth="%s"' % self.gds_format_integer(self.ThemeNameWidth, input_name='ThemeNameWidth'))
        if self.BottomMargin is not None and 'BottomMargin' not in already_processed:
            already_processed.add('BottomMargin')
            outfile.write(' BottomMargin="%s"' % self.gds_format_integer(self.BottomMargin, input_name='BottomMargin'))
        if self.LeftMargin is not None and 'LeftMargin' not in already_processed:
            already_processed.add('LeftMargin')
            outfile.write(' LeftMargin="%s"' % self.gds_format_integer(self.LeftMargin, input_name='LeftMargin'))
    def exportChildren(self, outfile, level, namespace_='', name_='PageSettings', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PageSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Orientation is not None and 'Orientation' not in already_processed:
            already_processed.add('Orientation')
            showIndent(outfile, level)
            outfile.write('Orientation="%s",\n' % (self.Orientation,))
        if self.TopMargin is not None and 'TopMargin' not in already_processed:
            already_processed.add('TopMargin')
            showIndent(outfile, level)
            outfile.write('TopMargin=%d,\n' % (self.TopMargin,))
        if self.RightMargin is not None and 'RightMargin' not in already_processed:
            already_processed.add('RightMargin')
            showIndent(outfile, level)
            outfile.write('RightMargin=%d,\n' % (self.RightMargin,))
        if self.PaperSize is not None and 'PaperSize' not in already_processed:
            already_processed.add('PaperSize')
            showIndent(outfile, level)
            outfile.write('PaperSize=%d,\n' % (self.PaperSize,))
        if self.Reduction is not None and 'Reduction' not in already_processed:
            already_processed.add('Reduction')
            showIndent(outfile, level)
            outfile.write('Reduction=%d,\n' % (self.Reduction,))
        if self.PaperSizeString is not None and 'PaperSizeString' not in already_processed:
            already_processed.add('PaperSizeString')
            showIndent(outfile, level)
            outfile.write('PaperSizeString="%s",\n' % (self.PaperSizeString,))
        if self.ThemeNameWidth is not None and 'ThemeNameWidth' not in already_processed:
            already_processed.add('ThemeNameWidth')
            showIndent(outfile, level)
            outfile.write('ThemeNameWidth=%d,\n' % (self.ThemeNameWidth,))
        if self.BottomMargin is not None and 'BottomMargin' not in already_processed:
            already_processed.add('BottomMargin')
            showIndent(outfile, level)
            outfile.write('BottomMargin=%d,\n' % (self.BottomMargin,))
        if self.LeftMargin is not None and 'LeftMargin' not in already_processed:
            already_processed.add('LeftMargin')
            showIndent(outfile, level)
            outfile.write('LeftMargin=%d,\n' % (self.LeftMargin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Orientation', node)
        if value is not None and 'Orientation' not in already_processed:
            already_processed.add('Orientation')
            self.Orientation = value
            self.validate_PrintOrientationEnum(self.Orientation)    # validate type PrintOrientationEnum
        value = find_attr_value_('TopMargin', node)
        if value is not None and 'TopMargin' not in already_processed:
            already_processed.add('TopMargin')
            try:
                self.TopMargin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('RightMargin', node)
        if value is not None and 'RightMargin' not in already_processed:
            already_processed.add('RightMargin')
            try:
                self.RightMargin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('PaperSize', node)
        if value is not None and 'PaperSize' not in already_processed:
            already_processed.add('PaperSize')
            try:
                self.PaperSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Reduction', node)
        if value is not None and 'Reduction' not in already_processed:
            already_processed.add('Reduction')
            try:
                self.Reduction = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('PaperSizeString', node)
        if value is not None and 'PaperSizeString' not in already_processed:
            already_processed.add('PaperSizeString')
            self.PaperSizeString = value
        value = find_attr_value_('ThemeNameWidth', node)
        if value is not None and 'ThemeNameWidth' not in already_processed:
            already_processed.add('ThemeNameWidth')
            try:
                self.ThemeNameWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('BottomMargin', node)
        if value is not None and 'BottomMargin' not in already_processed:
            already_processed.add('BottomMargin')
            try:
                self.BottomMargin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LeftMargin', node)
        if value is not None and 'LeftMargin' not in already_processed:
            already_processed.add('LeftMargin')
            try:
                self.LeftMargin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PageSettings


class Palette(GeneratedsSuper):
    """Palette object, which stores entity, link and attribute entries that
    can be added to a chart. Each chart can have one or more palette
    objects.Name of the palette object, which will appear in the
    application.Locks the order of the entity types within the
    palette."""
    subclass = None
    superclass = None
    def __init__(self, Locked=None, Name=None, AttributeClassEntryCollection=None, AttributeEntryCollection=None, EntityTypeEntryCollection=None, LinkTypeEntryCollection=None):
        self.original_tagname_ = None
        self.Locked = _cast(bool, Locked)
        self.Name = _cast(None, Name)
        self.AttributeClassEntryCollection = AttributeClassEntryCollection
        self.AttributeEntryCollection = AttributeEntryCollection
        self.EntityTypeEntryCollection = EntityTypeEntryCollection
        self.LinkTypeEntryCollection = LinkTypeEntryCollection
    def factory(*args_, **kwargs_):
        if Palette.subclass:
            return Palette.subclass(*args_, **kwargs_)
        else:
            return Palette(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeClassEntryCollection(self): return self.AttributeClassEntryCollection
    def set_AttributeClassEntryCollection(self, AttributeClassEntryCollection): self.AttributeClassEntryCollection = AttributeClassEntryCollection
    def get_AttributeEntryCollection(self): return self.AttributeEntryCollection
    def set_AttributeEntryCollection(self, AttributeEntryCollection): self.AttributeEntryCollection = AttributeEntryCollection
    def get_EntityTypeEntryCollection(self): return self.EntityTypeEntryCollection
    def set_EntityTypeEntryCollection(self, EntityTypeEntryCollection): self.EntityTypeEntryCollection = EntityTypeEntryCollection
    def get_LinkTypeEntryCollection(self): return self.LinkTypeEntryCollection
    def set_LinkTypeEntryCollection(self, LinkTypeEntryCollection): self.LinkTypeEntryCollection = LinkTypeEntryCollection
    def get_Locked(self): return self.Locked
    def set_Locked(self, Locked): self.Locked = Locked
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.AttributeClassEntryCollection is not None or
            self.AttributeEntryCollection is not None or
            self.EntityTypeEntryCollection is not None or
            self.LinkTypeEntryCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Palette', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Palette')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Palette', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Palette'):
        if self.Locked is not None and 'Locked' not in already_processed:
            already_processed.add('Locked')
            outfile.write(' Locked="%s"' % self.gds_format_boolean(self.Locked, input_name='Locked'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Palette', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttributeClassEntryCollection is not None:
            self.AttributeClassEntryCollection.export(outfile, level, namespace_, name_='AttributeClassEntryCollection', pretty_print=pretty_print)
        if self.AttributeEntryCollection is not None:
            self.AttributeEntryCollection.export(outfile, level, namespace_, name_='AttributeEntryCollection', pretty_print=pretty_print)
        if self.EntityTypeEntryCollection is not None:
            self.EntityTypeEntryCollection.export(outfile, level, namespace_, name_='EntityTypeEntryCollection', pretty_print=pretty_print)
        if self.LinkTypeEntryCollection is not None:
            self.LinkTypeEntryCollection.export(outfile, level, namespace_, name_='LinkTypeEntryCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Palette'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Locked is not None and 'Locked' not in already_processed:
            already_processed.add('Locked')
            showIndent(outfile, level)
            outfile.write('Locked=%s,\n' % (self.Locked,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AttributeClassEntryCollection is not None:
            showIndent(outfile, level)
            outfile.write('AttributeClassEntryCollection=model_.AttributeClassEntryCollection(\n')
            self.AttributeClassEntryCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AttributeEntryCollection is not None:
            showIndent(outfile, level)
            outfile.write('AttributeEntryCollection=model_.AttributeEntryCollection(\n')
            self.AttributeEntryCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EntityTypeEntryCollection is not None:
            showIndent(outfile, level)
            outfile.write('EntityTypeEntryCollection=model_.EntityTypeEntryCollection(\n')
            self.EntityTypeEntryCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinkTypeEntryCollection is not None:
            showIndent(outfile, level)
            outfile.write('LinkTypeEntryCollection=model_.LinkTypeEntryCollection(\n')
            self.LinkTypeEntryCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Locked', node)
        if value is not None and 'Locked' not in already_processed:
            already_processed.add('Locked')
            if value in ('true', '1'):
                self.Locked = True
            elif value in ('false', '0'):
                self.Locked = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttributeClassEntryCollection':
            obj_ = AttributeClassEntryCollection.factory()
            obj_.build(child_)
            self.AttributeClassEntryCollection = obj_
            obj_.original_tagname_ = 'AttributeClassEntryCollection'
        elif nodeName_ == 'AttributeEntryCollection':
            obj_ = AttributeEntryCollection.factory()
            obj_.build(child_)
            self.AttributeEntryCollection = obj_
            obj_.original_tagname_ = 'AttributeEntryCollection'
        elif nodeName_ == 'EntityTypeEntryCollection':
            obj_ = EntityTypeEntryCollection.factory()
            obj_.build(child_)
            self.EntityTypeEntryCollection = obj_
            obj_.original_tagname_ = 'EntityTypeEntryCollection'
        elif nodeName_ == 'LinkTypeEntryCollection':
            obj_ = LinkTypeEntryCollection.factory()
            obj_.build(child_)
            self.LinkTypeEntryCollection = obj_
            obj_.original_tagname_ = 'LinkTypeEntryCollection'
# end class Palette


class PaletteBar(GeneratedsSuper):
    """Palette bar object.Name of the palette associated with this palette
    bar.Distance of the splitter from the edge of the palette bar
    display area. Expressed in pixels.Is the palette bar visible."""
    subclass = None
    superclass = None
    def __init__(self, SplitterPosition=None, Visible=None, CurrentPaletteName=None):
        self.original_tagname_ = None
        self.SplitterPosition = _cast(int, SplitterPosition)
        self.Visible = _cast(bool, Visible)
        self.CurrentPaletteName = _cast(None, CurrentPaletteName)
    def factory(*args_, **kwargs_):
        if PaletteBar.subclass:
            return PaletteBar.subclass(*args_, **kwargs_)
        else:
            return PaletteBar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SplitterPosition(self): return self.SplitterPosition
    def set_SplitterPosition(self, SplitterPosition): self.SplitterPosition = SplitterPosition
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_CurrentPaletteName(self): return self.CurrentPaletteName
    def set_CurrentPaletteName(self, CurrentPaletteName): self.CurrentPaletteName = CurrentPaletteName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaletteBar', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaletteBar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaletteBar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaletteBar'):
        if self.SplitterPosition is not None and 'SplitterPosition' not in already_processed:
            already_processed.add('SplitterPosition')
            outfile.write(' SplitterPosition="%s"' % self.gds_format_integer(self.SplitterPosition, input_name='SplitterPosition'))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.CurrentPaletteName is not None and 'CurrentPaletteName' not in already_processed:
            already_processed.add('CurrentPaletteName')
            outfile.write(' CurrentPaletteName=%s' % (self.gds_format_string(quote_attrib(self.CurrentPaletteName).encode(ExternalEncoding), input_name='CurrentPaletteName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaletteBar', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PaletteBar'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SplitterPosition is not None and 'SplitterPosition' not in already_processed:
            already_processed.add('SplitterPosition')
            showIndent(outfile, level)
            outfile.write('SplitterPosition=%d,\n' % (self.SplitterPosition,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.CurrentPaletteName is not None and 'CurrentPaletteName' not in already_processed:
            already_processed.add('CurrentPaletteName')
            showIndent(outfile, level)
            outfile.write('CurrentPaletteName="%s",\n' % (self.CurrentPaletteName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SplitterPosition', node)
        if value is not None and 'SplitterPosition' not in already_processed:
            already_processed.add('SplitterPosition')
            try:
                self.SplitterPosition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CurrentPaletteName', node)
        if value is not None and 'CurrentPaletteName' not in already_processed:
            already_processed.add('CurrentPaletteName')
            self.CurrentPaletteName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaletteBar


class PaletteBarCollection(GeneratedsSuper):
    """Collection of palette bar objects associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, PaletteBar=None):
        self.original_tagname_ = None
        if PaletteBar is None:
            self.PaletteBar = []
        else:
            self.PaletteBar = PaletteBar
    def factory(*args_, **kwargs_):
        if PaletteBarCollection.subclass:
            return PaletteBarCollection.subclass(*args_, **kwargs_)
        else:
            return PaletteBarCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PaletteBar(self): return self.PaletteBar
    def set_PaletteBar(self, PaletteBar): self.PaletteBar = PaletteBar
    def add_PaletteBar(self, value): self.PaletteBar.append(value)
    def insert_PaletteBar(self, index, value): self.PaletteBar[index] = value
    def hasContent_(self):
        if (
            self.PaletteBar
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaletteBarCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaletteBarCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaletteBarCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaletteBarCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaletteBarCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PaletteBar_ in self.PaletteBar:
            PaletteBar_.export(outfile, level, namespace_, name_='PaletteBar', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PaletteBarCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PaletteBar=[\n')
        level += 1
        for PaletteBar_ in self.PaletteBar:
            showIndent(outfile, level)
            outfile.write('model_.PaletteBar(\n')
            PaletteBar_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PaletteBar':
            obj_ = PaletteBar.factory()
            obj_.build(child_)
            self.PaletteBar.append(obj_)
            obj_.original_tagname_ = 'PaletteBar'
# end class PaletteBarCollection


class PaletteCollection(GeneratedsSuper):
    """Collection of palette objects associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, Palette=None):
        self.original_tagname_ = None
        if Palette is None:
            self.Palette = []
        else:
            self.Palette = Palette
    def factory(*args_, **kwargs_):
        if PaletteCollection.subclass:
            return PaletteCollection.subclass(*args_, **kwargs_)
        else:
            return PaletteCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Palette(self): return self.Palette
    def set_Palette(self, Palette): self.Palette = Palette
    def add_Palette(self, value): self.Palette.append(value)
    def insert_Palette(self, index, value): self.Palette[index] = value
    def hasContent_(self):
        if (
            self.Palette
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaletteCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaletteCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaletteCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaletteCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaletteCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Palette_ in self.Palette:
            Palette_.export(outfile, level, namespace_, name_='Palette', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PaletteCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Palette=[\n')
        level += 1
        for Palette_ in self.Palette:
            showIndent(outfile, level)
            outfile.write('model_.Palette(\n')
            Palette_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Palette':
            obj_ = Palette.factory()
            obj_.build(child_)
            self.Palette.append(obj_)
            obj_.original_tagname_ = 'Palette'
# end class PaletteCollection


class PrintSettings(GeneratedsSuper):
    """Defines the print settings for a chart.If True, configures the page
    setting information when printing a chart that spans over
    multiple pages.Border type for these print settings.If True,
    center the chart image on the page when printed.If True, print
    the background color of the time bar. The PrintTimeBar property
    must also be set to True.Horizontal number of pages required to
    print a chart.If True, page numbers are printed.Maximum X
    Coordinate of the Page ExtentsMaximum Y Coordinate of the Page
    ExtentsMinimum X Coordinate of the Page ExtentsMinimum Y
    Coordinate of the Page ExtentsIf True, pages are printed with an
    overlap.If True, the chart background color is printed.Indicates
    when the theme line pane bar is printed.Controls whether the
    time bar is shown when the chart is printed.Vertical number of
    pages required to print a chart."""
    subclass = None
    superclass = None
    def __init__(self, VertPages=None, AssemblePages=None, MinExtentX=None, MinExtentY=None, ColourTimeBarBackground=None, OverlapPages=None, MaxExtentX=None, MaxExtentY=None, CentreChart=None, PrintTimeBar=None, HorzPages=None, NumberPages=None, Border=None, PrintThemePane=None, PrintChartBackground=None, HeaderCollection=None, FooterCollection=None, PageSettings=None):
        self.original_tagname_ = None
        self.VertPages = _cast(int, VertPages)
        self.AssemblePages = _cast(bool, AssemblePages)
        self.MinExtentX = _cast(int, MinExtentX)
        self.MinExtentY = _cast(int, MinExtentY)
        self.ColourTimeBarBackground = _cast(bool, ColourTimeBarBackground)
        self.OverlapPages = _cast(bool, OverlapPages)
        self.MaxExtentX = _cast(int, MaxExtentX)
        self.MaxExtentY = _cast(int, MaxExtentY)
        self.CentreChart = _cast(bool, CentreChart)
        self.PrintTimeBar = _cast(None, PrintTimeBar)
        self.HorzPages = _cast(int, HorzPages)
        self.NumberPages = _cast(bool, NumberPages)
        self.Border = _cast(None, Border)
        self.PrintThemePane = _cast(None, PrintThemePane)
        self.PrintChartBackground = _cast(bool, PrintChartBackground)
        self.HeaderCollection = HeaderCollection
        self.FooterCollection = FooterCollection
        self.PageSettings = PageSettings
    def factory(*args_, **kwargs_):
        if PrintSettings.subclass:
            return PrintSettings.subclass(*args_, **kwargs_)
        else:
            return PrintSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HeaderCollection(self): return self.HeaderCollection
    def set_HeaderCollection(self, HeaderCollection): self.HeaderCollection = HeaderCollection
    def get_FooterCollection(self): return self.FooterCollection
    def set_FooterCollection(self, FooterCollection): self.FooterCollection = FooterCollection
    def get_PageSettings(self): return self.PageSettings
    def set_PageSettings(self, PageSettings): self.PageSettings = PageSettings
    def get_VertPages(self): return self.VertPages
    def set_VertPages(self, VertPages): self.VertPages = VertPages
    def get_AssemblePages(self): return self.AssemblePages
    def set_AssemblePages(self, AssemblePages): self.AssemblePages = AssemblePages
    def get_MinExtentX(self): return self.MinExtentX
    def set_MinExtentX(self, MinExtentX): self.MinExtentX = MinExtentX
    def get_MinExtentY(self): return self.MinExtentY
    def set_MinExtentY(self, MinExtentY): self.MinExtentY = MinExtentY
    def get_ColourTimeBarBackground(self): return self.ColourTimeBarBackground
    def set_ColourTimeBarBackground(self, ColourTimeBarBackground): self.ColourTimeBarBackground = ColourTimeBarBackground
    def get_OverlapPages(self): return self.OverlapPages
    def set_OverlapPages(self, OverlapPages): self.OverlapPages = OverlapPages
    def get_MaxExtentX(self): return self.MaxExtentX
    def set_MaxExtentX(self, MaxExtentX): self.MaxExtentX = MaxExtentX
    def get_MaxExtentY(self): return self.MaxExtentY
    def set_MaxExtentY(self, MaxExtentY): self.MaxExtentY = MaxExtentY
    def get_CentreChart(self): return self.CentreChart
    def set_CentreChart(self, CentreChart): self.CentreChart = CentreChart
    def get_PrintTimeBar(self): return self.PrintTimeBar
    def set_PrintTimeBar(self, PrintTimeBar): self.PrintTimeBar = PrintTimeBar
    def get_HorzPages(self): return self.HorzPages
    def set_HorzPages(self, HorzPages): self.HorzPages = HorzPages
    def get_NumberPages(self): return self.NumberPages
    def set_NumberPages(self, NumberPages): self.NumberPages = NumberPages
    def get_Border(self): return self.Border
    def set_Border(self, Border): self.Border = Border
    def get_PrintThemePane(self): return self.PrintThemePane
    def set_PrintThemePane(self, PrintThemePane): self.PrintThemePane = PrintThemePane
    def get_PrintChartBackground(self): return self.PrintChartBackground
    def set_PrintChartBackground(self, PrintChartBackground): self.PrintChartBackground = PrintChartBackground
    def validate_PrintOptionsEnum(self, value):
        # Validate type PrintOptionsEnum, a restriction on xsd:string.
        pass
    def validate_PrintBorderEnum(self, value):
        # Validate type PrintBorderEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.HeaderCollection is not None or
            self.FooterCollection is not None or
            self.PageSettings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrintSettings', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrintSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrintSettings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrintSettings'):
        if self.VertPages is not None and 'VertPages' not in already_processed:
            already_processed.add('VertPages')
            outfile.write(' VertPages="%s"' % self.gds_format_integer(self.VertPages, input_name='VertPages'))
        if self.AssemblePages is not None and 'AssemblePages' not in already_processed:
            already_processed.add('AssemblePages')
            outfile.write(' AssemblePages="%s"' % self.gds_format_boolean(self.AssemblePages, input_name='AssemblePages'))
        if self.MinExtentX is not None and 'MinExtentX' not in already_processed:
            already_processed.add('MinExtentX')
            outfile.write(' MinExtentX="%s"' % self.gds_format_integer(self.MinExtentX, input_name='MinExtentX'))
        if self.MinExtentY is not None and 'MinExtentY' not in already_processed:
            already_processed.add('MinExtentY')
            outfile.write(' MinExtentY="%s"' % self.gds_format_integer(self.MinExtentY, input_name='MinExtentY'))
        if self.ColourTimeBarBackground is not None and 'ColourTimeBarBackground' not in already_processed:
            already_processed.add('ColourTimeBarBackground')
            outfile.write(' ColourTimeBarBackground="%s"' % self.gds_format_boolean(self.ColourTimeBarBackground, input_name='ColourTimeBarBackground'))
        if self.OverlapPages is not None and 'OverlapPages' not in already_processed:
            already_processed.add('OverlapPages')
            outfile.write(' OverlapPages="%s"' % self.gds_format_boolean(self.OverlapPages, input_name='OverlapPages'))
        if self.MaxExtentX is not None and 'MaxExtentX' not in already_processed:
            already_processed.add('MaxExtentX')
            outfile.write(' MaxExtentX="%s"' % self.gds_format_integer(self.MaxExtentX, input_name='MaxExtentX'))
        if self.MaxExtentY is not None and 'MaxExtentY' not in already_processed:
            already_processed.add('MaxExtentY')
            outfile.write(' MaxExtentY="%s"' % self.gds_format_integer(self.MaxExtentY, input_name='MaxExtentY'))
        if self.CentreChart is not None and 'CentreChart' not in already_processed:
            already_processed.add('CentreChart')
            outfile.write(' CentreChart="%s"' % self.gds_format_boolean(self.CentreChart, input_name='CentreChart'))
        if self.PrintTimeBar is not None and 'PrintTimeBar' not in already_processed:
            already_processed.add('PrintTimeBar')
            outfile.write(' PrintTimeBar=%s' % (quote_attrib(self.PrintTimeBar), ))
        if self.HorzPages is not None and 'HorzPages' not in already_processed:
            already_processed.add('HorzPages')
            outfile.write(' HorzPages="%s"' % self.gds_format_integer(self.HorzPages, input_name='HorzPages'))
        if self.NumberPages is not None and 'NumberPages' not in already_processed:
            already_processed.add('NumberPages')
            outfile.write(' NumberPages="%s"' % self.gds_format_boolean(self.NumberPages, input_name='NumberPages'))
        if self.Border is not None and 'Border' not in already_processed:
            already_processed.add('Border')
            outfile.write(' Border=%s' % (quote_attrib(self.Border), ))
        if self.PrintThemePane is not None and 'PrintThemePane' not in already_processed:
            already_processed.add('PrintThemePane')
            outfile.write(' PrintThemePane=%s' % (quote_attrib(self.PrintThemePane), ))
        if self.PrintChartBackground is not None and 'PrintChartBackground' not in already_processed:
            already_processed.add('PrintChartBackground')
            outfile.write(' PrintChartBackground="%s"' % self.gds_format_boolean(self.PrintChartBackground, input_name='PrintChartBackground'))
    def exportChildren(self, outfile, level, namespace_='', name_='PrintSettings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeaderCollection is not None:
            self.HeaderCollection.export(outfile, level, namespace_, name_='HeaderCollection', pretty_print=pretty_print)
        if self.FooterCollection is not None:
            self.FooterCollection.export(outfile, level, namespace_, name_='FooterCollection', pretty_print=pretty_print)
        if self.PageSettings is not None:
            self.PageSettings.export(outfile, level, namespace_, name_='PageSettings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PrintSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VertPages is not None and 'VertPages' not in already_processed:
            already_processed.add('VertPages')
            showIndent(outfile, level)
            outfile.write('VertPages=%d,\n' % (self.VertPages,))
        if self.AssemblePages is not None and 'AssemblePages' not in already_processed:
            already_processed.add('AssemblePages')
            showIndent(outfile, level)
            outfile.write('AssemblePages=%s,\n' % (self.AssemblePages,))
        if self.MinExtentX is not None and 'MinExtentX' not in already_processed:
            already_processed.add('MinExtentX')
            showIndent(outfile, level)
            outfile.write('MinExtentX=%d,\n' % (self.MinExtentX,))
        if self.MinExtentY is not None and 'MinExtentY' not in already_processed:
            already_processed.add('MinExtentY')
            showIndent(outfile, level)
            outfile.write('MinExtentY=%d,\n' % (self.MinExtentY,))
        if self.ColourTimeBarBackground is not None and 'ColourTimeBarBackground' not in already_processed:
            already_processed.add('ColourTimeBarBackground')
            showIndent(outfile, level)
            outfile.write('ColourTimeBarBackground=%s,\n' % (self.ColourTimeBarBackground,))
        if self.OverlapPages is not None and 'OverlapPages' not in already_processed:
            already_processed.add('OverlapPages')
            showIndent(outfile, level)
            outfile.write('OverlapPages=%s,\n' % (self.OverlapPages,))
        if self.MaxExtentX is not None and 'MaxExtentX' not in already_processed:
            already_processed.add('MaxExtentX')
            showIndent(outfile, level)
            outfile.write('MaxExtentX=%d,\n' % (self.MaxExtentX,))
        if self.MaxExtentY is not None and 'MaxExtentY' not in already_processed:
            already_processed.add('MaxExtentY')
            showIndent(outfile, level)
            outfile.write('MaxExtentY=%d,\n' % (self.MaxExtentY,))
        if self.CentreChart is not None and 'CentreChart' not in already_processed:
            already_processed.add('CentreChart')
            showIndent(outfile, level)
            outfile.write('CentreChart=%s,\n' % (self.CentreChart,))
        if self.PrintTimeBar is not None and 'PrintTimeBar' not in already_processed:
            already_processed.add('PrintTimeBar')
            showIndent(outfile, level)
            outfile.write('PrintTimeBar="%s",\n' % (self.PrintTimeBar,))
        if self.HorzPages is not None and 'HorzPages' not in already_processed:
            already_processed.add('HorzPages')
            showIndent(outfile, level)
            outfile.write('HorzPages=%d,\n' % (self.HorzPages,))
        if self.NumberPages is not None and 'NumberPages' not in already_processed:
            already_processed.add('NumberPages')
            showIndent(outfile, level)
            outfile.write('NumberPages=%s,\n' % (self.NumberPages,))
        if self.Border is not None and 'Border' not in already_processed:
            already_processed.add('Border')
            showIndent(outfile, level)
            outfile.write('Border="%s",\n' % (self.Border,))
        if self.PrintThemePane is not None and 'PrintThemePane' not in already_processed:
            already_processed.add('PrintThemePane')
            showIndent(outfile, level)
            outfile.write('PrintThemePane="%s",\n' % (self.PrintThemePane,))
        if self.PrintChartBackground is not None and 'PrintChartBackground' not in already_processed:
            already_processed.add('PrintChartBackground')
            showIndent(outfile, level)
            outfile.write('PrintChartBackground=%s,\n' % (self.PrintChartBackground,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HeaderCollection is not None:
            showIndent(outfile, level)
            outfile.write('HeaderCollection=model_.HeaderCollection(\n')
            self.HeaderCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FooterCollection is not None:
            showIndent(outfile, level)
            outfile.write('FooterCollection=model_.FooterCollection(\n')
            self.FooterCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PageSettings is not None:
            showIndent(outfile, level)
            outfile.write('PageSettings=model_.PageSettings(\n')
            self.PageSettings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VertPages', node)
        if value is not None and 'VertPages' not in already_processed:
            already_processed.add('VertPages')
            try:
                self.VertPages = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('AssemblePages', node)
        if value is not None and 'AssemblePages' not in already_processed:
            already_processed.add('AssemblePages')
            if value in ('true', '1'):
                self.AssemblePages = True
            elif value in ('false', '0'):
                self.AssemblePages = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MinExtentX', node)
        if value is not None and 'MinExtentX' not in already_processed:
            already_processed.add('MinExtentX')
            try:
                self.MinExtentX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MinExtentY', node)
        if value is not None and 'MinExtentY' not in already_processed:
            already_processed.add('MinExtentY')
            try:
                self.MinExtentY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ColourTimeBarBackground', node)
        if value is not None and 'ColourTimeBarBackground' not in already_processed:
            already_processed.add('ColourTimeBarBackground')
            if value in ('true', '1'):
                self.ColourTimeBarBackground = True
            elif value in ('false', '0'):
                self.ColourTimeBarBackground = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OverlapPages', node)
        if value is not None and 'OverlapPages' not in already_processed:
            already_processed.add('OverlapPages')
            if value in ('true', '1'):
                self.OverlapPages = True
            elif value in ('false', '0'):
                self.OverlapPages = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MaxExtentX', node)
        if value is not None and 'MaxExtentX' not in already_processed:
            already_processed.add('MaxExtentX')
            try:
                self.MaxExtentX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MaxExtentY', node)
        if value is not None and 'MaxExtentY' not in already_processed:
            already_processed.add('MaxExtentY')
            try:
                self.MaxExtentY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CentreChart', node)
        if value is not None and 'CentreChart' not in already_processed:
            already_processed.add('CentreChart')
            if value in ('true', '1'):
                self.CentreChart = True
            elif value in ('false', '0'):
                self.CentreChart = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PrintTimeBar', node)
        if value is not None and 'PrintTimeBar' not in already_processed:
            already_processed.add('PrintTimeBar')
            self.PrintTimeBar = value
            self.validate_PrintOptionsEnum(self.PrintTimeBar)    # validate type PrintOptionsEnum
        value = find_attr_value_('HorzPages', node)
        if value is not None and 'HorzPages' not in already_processed:
            already_processed.add('HorzPages')
            try:
                self.HorzPages = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NumberPages', node)
        if value is not None and 'NumberPages' not in already_processed:
            already_processed.add('NumberPages')
            if value in ('true', '1'):
                self.NumberPages = True
            elif value in ('false', '0'):
                self.NumberPages = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Border', node)
        if value is not None and 'Border' not in already_processed:
            already_processed.add('Border')
            self.Border = value
            self.validate_PrintBorderEnum(self.Border)    # validate type PrintBorderEnum
        value = find_attr_value_('PrintThemePane', node)
        if value is not None and 'PrintThemePane' not in already_processed:
            already_processed.add('PrintThemePane')
            self.PrintThemePane = value
            self.validate_PrintOptionsEnum(self.PrintThemePane)    # validate type PrintOptionsEnum
        value = find_attr_value_('PrintChartBackground', node)
        if value is not None and 'PrintChartBackground' not in already_processed:
            already_processed.add('PrintChartBackground')
            if value in ('true', '1'):
                self.PrintChartBackground = True
            elif value in ('false', '0'):
                self.PrintChartBackground = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeaderCollection':
            obj_ = HeaderCollection.factory()
            obj_.build(child_)
            self.HeaderCollection = obj_
            obj_.original_tagname_ = 'HeaderCollection'
        elif nodeName_ == 'FooterCollection':
            obj_ = FooterCollection.factory()
            obj_.build(child_)
            self.FooterCollection = obj_
            obj_.original_tagname_ = 'FooterCollection'
        elif nodeName_ == 'PageSettings':
            obj_ = PageSettings.factory()
            obj_.build(child_)
            self.PageSettings = obj_
            obj_.original_tagname_ = 'PageSettings'
# end class PrintSettings


class Snapshot(GeneratedsSuper):
    """Object representing a snapshot of the chart.A string description of
    the Snapshot.The view class id of the snapshot's
    viewport.DateTime value associated with the snapshot, typically
    the date and time the snapshot was created.The X cooordinate of
    the snapshot's viewport.The Y cooordinate of the snapshot's
    viewport.The scale in force for the snapshot's viewport.The Show
    All value for the snapshot's viewport."""
    subclass = None
    superclass = None
    def __init__(self, Scale=1.0, Name=None, ShowAll=True, DateTime=None, X=0, Y=0, ViewClassId=None, SnapshotItemCollection=None):
        self.original_tagname_ = None
        self.Scale = _cast(float, Scale)
        self.Name = _cast(None, Name)
        self.ShowAll = _cast(bool, ShowAll)
        if isinstance(DateTime, str):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
        self.X = _cast(int, X)
        self.Y = _cast(int, Y)
        self.ViewClassId = _cast(None, ViewClassId)
        self.SnapshotItemCollection = SnapshotItemCollection
    def factory(*args_, **kwargs_):
        if Snapshot.subclass:
            return Snapshot.subclass(*args_, **kwargs_)
        else:
            return Snapshot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SnapshotItemCollection(self): return self.SnapshotItemCollection
    def set_SnapshotItemCollection(self, SnapshotItemCollection): self.SnapshotItemCollection = SnapshotItemCollection
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ShowAll(self): return self.ShowAll
    def set_ShowAll(self, ShowAll): self.ShowAll = ShowAll
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_ViewClassId(self): return self.ViewClassId
    def set_ViewClassId(self, ViewClassId): self.ViewClassId = ViewClassId
    def hasContent_(self):
        if (
            self.SnapshotItemCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Snapshot', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Snapshot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Snapshot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Snapshot'):
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.add('Scale')
            outfile.write(' Scale="%s"' % self.gds_format_double(self.Scale, input_name='Scale'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.ShowAll is not None and 'ShowAll' not in already_processed:
            already_processed.add('ShowAll')
            outfile.write(' ShowAll="%s"' % self.gds_format_boolean(self.ShowAll, input_name='ShowAll'))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            outfile.write(' DateTime="%s"' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            outfile.write(' X="%s"' % self.gds_format_integer(self.X, input_name='X'))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            outfile.write(' Y="%s"' % self.gds_format_integer(self.Y, input_name='Y'))
        if self.ViewClassId is not None and 'ViewClassId' not in already_processed:
            already_processed.add('ViewClassId')
            outfile.write(' ViewClassId=%s' % (self.gds_format_string(quote_attrib(self.ViewClassId).encode(ExternalEncoding), input_name='ViewClassId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Snapshot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SnapshotItemCollection is not None:
            self.SnapshotItemCollection.export(outfile, level, namespace_, name_='SnapshotItemCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Snapshot'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.add('Scale')
            showIndent(outfile, level)
            outfile.write('Scale=%e,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.ShowAll is not None and 'ShowAll' not in already_processed:
            already_processed.add('ShowAll')
            showIndent(outfile, level)
            outfile.write('ShowAll=%s,\n' % (self.ShowAll,))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            showIndent(outfile, level)
            outfile.write('DateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            showIndent(outfile, level)
            outfile.write('X=%d,\n' % (self.X,))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            showIndent(outfile, level)
            outfile.write('Y=%d,\n' % (self.Y,))
        if self.ViewClassId is not None and 'ViewClassId' not in already_processed:
            already_processed.add('ViewClassId')
            showIndent(outfile, level)
            outfile.write('ViewClassId="%s",\n' % (self.ViewClassId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SnapshotItemCollection is not None:
            showIndent(outfile, level)
            outfile.write('SnapshotItemCollection=model_.SnapshotItemCollection(\n')
            self.SnapshotItemCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Scale', node)
        if value is not None and 'Scale' not in already_processed:
            already_processed.add('Scale')
            try:
                self.Scale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Scale): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('ShowAll', node)
        if value is not None and 'ShowAll' not in already_processed:
            already_processed.add('ShowAll')
            if value in ('true', '1'):
                self.ShowAll = True
            elif value in ('false', '0'):
                self.ShowAll = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateTime', node)
        if value is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            try:
                self.DateTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DateTime): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ViewClassId', node)
        if value is not None and 'ViewClassId' not in already_processed:
            already_processed.add('ViewClassId')
            self.ViewClassId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SnapshotItemCollection':
            obj_ = SnapshotItemCollection.factory()
            obj_.build(child_)
            self.SnapshotItemCollection = obj_
            obj_.original_tagname_ = 'SnapshotItemCollection'
# end class Snapshot


class SnapshotCollection(GeneratedsSuper):
    """Collection of snapshot objects associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, Snapshot=None):
        self.original_tagname_ = None
        if Snapshot is None:
            self.Snapshot = []
        else:
            self.Snapshot = Snapshot
    def factory(*args_, **kwargs_):
        if SnapshotCollection.subclass:
            return SnapshotCollection.subclass(*args_, **kwargs_)
        else:
            return SnapshotCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Snapshot(self): return self.Snapshot
    def set_Snapshot(self, Snapshot): self.Snapshot = Snapshot
    def add_Snapshot(self, value): self.Snapshot.append(value)
    def insert_Snapshot(self, index, value): self.Snapshot[index] = value
    def hasContent_(self):
        if (
            self.Snapshot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Snapshot_ in self.Snapshot:
            Snapshot_.export(outfile, level, namespace_, name_='Snapshot', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Snapshot=[\n')
        level += 1
        for Snapshot_ in self.Snapshot:
            showIndent(outfile, level)
            outfile.write('model_.Snapshot(\n')
            Snapshot_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Snapshot':
            obj_ = Snapshot.factory()
            obj_.build(child_)
            self.Snapshot.append(obj_)
            obj_.original_tagname_ = 'Snapshot'
# end class SnapshotCollection


class SnapshotItem(GeneratedsSuper):
    """Object representing a snapshot of an item on the chart.The IDREF of
    the chart item.X position of the chart item.Y position of the
    chart item.DateTime value of the chart item.The DateSet value of
    the chart item.The TimeSet value of the chart item.The Oredered
    value of the chart item.The Shown value of the chart item.The
    height of the chart item if sized (e.g. OLE item or Box).The
    width of the chart item if sized (e.g. OLE item or Box).The
    corner id, if a corner."""
    subclass = None
    superclass = None
    def __init__(self, ChartItemIdReference=None, TimeSet=None, DateSet=None, Ordered=None, Shown=None, DateTime=None, CornerId=None, Width=100, Y=0, X=0, Height=100):
        self.original_tagname_ = None
        self.ChartItemIdReference = _cast(None, ChartItemIdReference)
        self.TimeSet = _cast(bool, TimeSet)
        self.DateSet = _cast(bool, DateSet)
        self.Ordered = _cast(bool, Ordered)
        self.Shown = _cast(bool, Shown)
        if isinstance(DateTime, str):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
        self.CornerId = _cast(int, CornerId)
        self.Width = _cast(int, Width)
        self.Y = _cast(int, Y)
        self.X = _cast(int, X)
        self.Height = _cast(int, Height)
    def factory(*args_, **kwargs_):
        if SnapshotItem.subclass:
            return SnapshotItem.subclass(*args_, **kwargs_)
        else:
            return SnapshotItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartItemIdReference(self): return self.ChartItemIdReference
    def set_ChartItemIdReference(self, ChartItemIdReference): self.ChartItemIdReference = ChartItemIdReference
    def get_TimeSet(self): return self.TimeSet
    def set_TimeSet(self, TimeSet): self.TimeSet = TimeSet
    def get_DateSet(self): return self.DateSet
    def set_DateSet(self, DateSet): self.DateSet = DateSet
    def get_Ordered(self): return self.Ordered
    def set_Ordered(self, Ordered): self.Ordered = Ordered
    def get_Shown(self): return self.Shown
    def set_Shown(self, Shown): self.Shown = Shown
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_CornerId(self): return self.CornerId
    def set_CornerId(self, CornerId): self.CornerId = CornerId
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotItem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotItem'):
        if self.ChartItemIdReference is not None and 'ChartItemIdReference' not in already_processed:
            already_processed.add('ChartItemIdReference')
            outfile.write(' ChartItemIdReference=%s' % (self.gds_format_string(quote_attrib(self.ChartItemIdReference).encode(ExternalEncoding), input_name='ChartItemIdReference'), ))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            outfile.write(' TimeSet="%s"' % self.gds_format_boolean(self.TimeSet, input_name='TimeSet'))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            outfile.write(' DateSet="%s"' % self.gds_format_boolean(self.DateSet, input_name='DateSet'))
        if self.Ordered is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            outfile.write(' Ordered="%s"' % self.gds_format_boolean(self.Ordered, input_name='Ordered'))
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            outfile.write(' Shown="%s"' % self.gds_format_boolean(self.Shown, input_name='Shown'))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            outfile.write(' DateTime="%s"' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.CornerId is not None and 'CornerId' not in already_processed:
            already_processed.add('CornerId')
            outfile.write(' CornerId="%s"' % self.gds_format_integer(self.CornerId, input_name='CornerId'))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            outfile.write(' Width="%s"' % self.gds_format_integer(self.Width, input_name='Width'))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            outfile.write(' Y="%s"' % self.gds_format_integer(self.Y, input_name='Y'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            outfile.write(' X="%s"' % self.gds_format_integer(self.X, input_name='X'))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            outfile.write(' Height="%s"' % self.gds_format_integer(self.Height, input_name='Height'))
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotItem', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SnapshotItem'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ChartItemIdReference is not None and 'ChartItemIdReference' not in already_processed:
            already_processed.add('ChartItemIdReference')
            showIndent(outfile, level)
            outfile.write('ChartItemIdReference="%s",\n' % (self.ChartItemIdReference,))
        if self.TimeSet is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            showIndent(outfile, level)
            outfile.write('TimeSet=%s,\n' % (self.TimeSet,))
        if self.DateSet is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            showIndent(outfile, level)
            outfile.write('DateSet=%s,\n' % (self.DateSet,))
        if self.Ordered is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            showIndent(outfile, level)
            outfile.write('Ordered=%s,\n' % (self.Ordered,))
        if self.Shown is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            showIndent(outfile, level)
            outfile.write('Shown=%s,\n' % (self.Shown,))
        if self.DateTime is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            showIndent(outfile, level)
            outfile.write('DateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateTime, input_name='DateTime'))
        if self.CornerId is not None and 'CornerId' not in already_processed:
            already_processed.add('CornerId')
            showIndent(outfile, level)
            outfile.write('CornerId=%d,\n' % (self.CornerId,))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            showIndent(outfile, level)
            outfile.write('Width=%d,\n' % (self.Width,))
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            showIndent(outfile, level)
            outfile.write('Y=%d,\n' % (self.Y,))
        if self.X is not None and 'X' not in already_processed:
            already_processed.add('X')
            showIndent(outfile, level)
            outfile.write('X=%d,\n' % (self.X,))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            showIndent(outfile, level)
            outfile.write('Height=%d,\n' % (self.Height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ChartItemIdReference', node)
        if value is not None and 'ChartItemIdReference' not in already_processed:
            already_processed.add('ChartItemIdReference')
            self.ChartItemIdReference = value
        value = find_attr_value_('TimeSet', node)
        if value is not None and 'TimeSet' not in already_processed:
            already_processed.add('TimeSet')
            if value in ('true', '1'):
                self.TimeSet = True
            elif value in ('false', '0'):
                self.TimeSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateSet', node)
        if value is not None and 'DateSet' not in already_processed:
            already_processed.add('DateSet')
            if value in ('true', '1'):
                self.DateSet = True
            elif value in ('false', '0'):
                self.DateSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Ordered', node)
        if value is not None and 'Ordered' not in already_processed:
            already_processed.add('Ordered')
            if value in ('true', '1'):
                self.Ordered = True
            elif value in ('false', '0'):
                self.Ordered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Shown', node)
        if value is not None and 'Shown' not in already_processed:
            already_processed.add('Shown')
            if value in ('true', '1'):
                self.Shown = True
            elif value in ('false', '0'):
                self.Shown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DateTime', node)
        if value is not None and 'DateTime' not in already_processed:
            already_processed.add('DateTime')
            try:
                self.DateTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DateTime): %s' % exp)
        value = find_attr_value_('CornerId', node)
        if value is not None and 'CornerId' not in already_processed:
            already_processed.add('CornerId')
            try:
                self.CornerId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SnapshotItem


class SnapshotItemCollection(GeneratedsSuper):
    """Collection of snapshot item objects associated with the items on the
    chart."""
    subclass = None
    superclass = None
    def __init__(self, SnapshotItem=None):
        self.original_tagname_ = None
        if SnapshotItem is None:
            self.SnapshotItem = []
        else:
            self.SnapshotItem = SnapshotItem
    def factory(*args_, **kwargs_):
        if SnapshotItemCollection.subclass:
            return SnapshotItemCollection.subclass(*args_, **kwargs_)
        else:
            return SnapshotItemCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SnapshotItem(self): return self.SnapshotItem
    def set_SnapshotItem(self, SnapshotItem): self.SnapshotItem = SnapshotItem
    def add_SnapshotItem(self, value): self.SnapshotItem.append(value)
    def insert_SnapshotItem(self, index, value): self.SnapshotItem[index] = value
    def hasContent_(self):
        if (
            self.SnapshotItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotItemCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotItemCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotItemCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotItemCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotItemCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SnapshotItem_ in self.SnapshotItem:
            SnapshotItem_.export(outfile, level, namespace_, name_='SnapshotItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotItemCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SnapshotItem=[\n')
        level += 1
        for SnapshotItem_ in self.SnapshotItem:
            showIndent(outfile, level)
            outfile.write('model_.SnapshotItem(\n')
            SnapshotItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SnapshotItem':
            obj_ = SnapshotItem.factory()
            obj_.build(child_)
            self.SnapshotItem.append(obj_)
            obj_.original_tagname_ = 'SnapshotItem'
# end class SnapshotItemCollection


class SourceHints(GeneratedsSuper):
    """Collection of source types associated with this chart."""
    subclass = None
    superclass = None
    def __init__(self, StringCollection=None):
        self.original_tagname_ = None
        self.StringCollection = StringCollection
    def factory(*args_, **kwargs_):
        if SourceHints.subclass:
            return SourceHints.subclass(*args_, **kwargs_)
        else:
            return SourceHints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StringCollection(self): return self.StringCollection
    def set_StringCollection(self, StringCollection): self.StringCollection = StringCollection
    def hasContent_(self):
        if (
            self.StringCollection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourceHints', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceHints')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SourceHints', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourceHints'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SourceHints', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringCollection is not None:
            self.StringCollection.export(outfile, level, namespace_, name_='StringCollection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourceHints'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StringCollection is not None:
            showIndent(outfile, level)
            outfile.write('StringCollection=model_.StringCollection(\n')
            self.StringCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StringCollection':
            obj_ = StringCollection.factory()
            obj_.build(child_)
            self.StringCollection = obj_
            obj_.original_tagname_ = 'StringCollection'
# end class SourceHints


class Strength(GeneratedsSuper):
    """Defines the strength definition for chart items. Use this to set the
    line dash properties (that is, dotted, dashed, and so on), which
    visually indicate different strengths.Line style used to
    represent this strength.Strength ID (see
    IdReferenceLinking).Name used to identify this strength."""
    subclass = None
    superclass = None
    def __init__(self, DotStyle=None, Id=None, Name=None):
        self.original_tagname_ = None
        self.DotStyle = _cast(None, DotStyle)
        self.Id = _cast(None, Id)
        self.Name = _cast(None, Name)
    def factory(*args_, **kwargs_):
        if Strength.subclass:
            return Strength.subclass(*args_, **kwargs_)
        else:
            return Strength(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DotStyle(self): return self.DotStyle
    def set_DotStyle(self, DotStyle): self.DotStyle = DotStyle
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DotStyleEnum(self, value):
        # Validate type DotStyleEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strength', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strength')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strength', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strength'):
        if self.DotStyle is not None and 'DotStyle' not in already_processed:
            already_processed.add('DotStyle')
            outfile.write(' DotStyle=%s' % (quote_attrib(self.DotStyle), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strength', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Strength'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DotStyle is not None and 'DotStyle' not in already_processed:
            already_processed.add('DotStyle')
            showIndent(outfile, level)
            outfile.write('DotStyle="%s",\n' % (self.DotStyle,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DotStyle', node)
        if value is not None and 'DotStyle' not in already_processed:
            already_processed.add('DotStyle')
            self.DotStyle = value
            self.validate_DotStyleEnum(self.DotStyle)    # validate type DotStyleEnum
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Strength


class StrengthCollection(GeneratedsSuper):
    """Collection of strength definition objects associated with the chart."""
    subclass = None
    superclass = None
    def __init__(self, Strength=None):
        self.original_tagname_ = None
        if Strength is None:
            self.Strength = []
        else:
            self.Strength = Strength
    def factory(*args_, **kwargs_):
        if StrengthCollection.subclass:
            return StrengthCollection.subclass(*args_, **kwargs_)
        else:
            return StrengthCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def add_Strength(self, value): self.Strength.append(value)
    def insert_Strength(self, index, value): self.Strength[index] = value
    def hasContent_(self):
        if (
            self.Strength
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrengthCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrengthCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrengthCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrengthCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrengthCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Strength_ in self.Strength:
            Strength_.export(outfile, level, namespace_, name_='Strength', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StrengthCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Strength=[\n')
        level += 1
        for Strength_ in self.Strength:
            showIndent(outfile, level)
            outfile.write('model_.Strength(\n')
            Strength_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Strength':
            obj_ = Strength.factory()
            obj_.build(child_)
            self.Strength.append(obj_)
            obj_.original_tagname_ = 'Strength'
# end class StrengthCollection


class String(GeneratedsSuper):
    """String item contained within a string collection.String ID (see
    IdReferenceLinking). String collections are used for grades and
    source hints.Text contained by String element."""
    subclass = None
    superclass = None
    def __init__(self, Text=None, Id=None):
        self.original_tagname_ = None
        self.Text = _cast(None, Text)
        self.Id = _cast(None, Id)
    def factory(*args_, **kwargs_):
        if String.subclass:
            return String.subclass(*args_, **kwargs_)
        else:
            return String(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='String', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='String')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='String', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='String'):
        if self.Text is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            outfile.write(' Text=%s' % (self.gds_format_string(quote_attrib(self.Text).encode(ExternalEncoding), input_name='Text'), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='String', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='String'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Text is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            showIndent(outfile, level)
            outfile.write('Text="%s",\n' % (self.Text,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Text', node)
        if value is not None and 'Text' not in already_processed:
            already_processed.add('Text')
            self.Text = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class String


class StringCollection(GeneratedsSuper):
    """Collection of strings."""
    subclass = None
    superclass = None
    def __init__(self, String=None):
        self.original_tagname_ = None
        if String is None:
            self.String = []
        else:
            self.String = String
    def factory(*args_, **kwargs_):
        if StringCollection.subclass:
            return StringCollection.subclass(*args_, **kwargs_)
        else:
            return StringCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_String(self): return self.String
    def set_String(self, String): self.String = String
    def add_String(self, value): self.String.append(value)
    def insert_String(self, index, value): self.String[index] = value
    def hasContent_(self):
        if (
            self.String
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StringCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StringCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StringCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StringCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for String_ in self.String:
            String_.export(outfile, level, namespace_, name_='String', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StringCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('String=[\n')
        level += 1
        for String_ in self.String:
            showIndent(outfile, level)
            outfile.write('model_.String(\n')
            String_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'String':
            obj_ = String.factory()
            obj_.build(child_)
            self.String.append(obj_)
            obj_.original_tagname_ = 'String'
# end class StringCollection


class SubItem(GeneratedsSuper):
    """A sub item of a chart item.Type of sub item to display on a chart
    item.If True, the specified sub item is displayed on the chart
    item."""
    subclass = None
    superclass = None
    def __init__(self, Visible=False, Type='SubItemLabel'):
        self.original_tagname_ = None
        self.Visible = _cast(bool, Visible)
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if SubItem.subclass:
            return SubItem.subclass(*args_, **kwargs_)
        else:
            return SubItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SubItemEnum(self, value):
        # Validate type SubItemEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubItem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubItem'):
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubItem', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SubItem'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_SubItemEnum(self.Type)    # validate type SubItemEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubItem


class SubItemCollection(GeneratedsSuper):
    """Collection of sub items that can be displayed on a chart item."""
    subclass = None
    superclass = None
    def __init__(self, SubItem=None):
        self.original_tagname_ = None
        if SubItem is None:
            self.SubItem = []
        else:
            self.SubItem = SubItem
    def factory(*args_, **kwargs_):
        if SubItemCollection.subclass:
            return SubItemCollection.subclass(*args_, **kwargs_)
        else:
            return SubItemCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubItem(self): return self.SubItem
    def set_SubItem(self, SubItem): self.SubItem = SubItem
    def add_SubItem(self, value): self.SubItem.append(value)
    def insert_SubItem(self, index, value): self.SubItem[index] = value
    def hasContent_(self):
        if (
            self.SubItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubItemCollection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubItemCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubItemCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubItemCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubItemCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubItem_ in self.SubItem:
            SubItem_.export(outfile, level, namespace_, name_='SubItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubItemCollection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SubItem=[\n')
        level += 1
        for SubItem_ in self.SubItem:
            showIndent(outfile, level)
            outfile.write('model_.SubItem(\n')
            SubItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubItem':
            obj_ = SubItem.factory()
            obj_.build(child_)
            self.SubItem.append(obj_)
            obj_.original_tagname_ = 'SubItem'
# end class SubItemCollection


class Summary(GeneratedsSuper):
    """Object representing the chart's summary information."""
    subclass = None
    superclass = None
    def __init__(self, FieldCollection=None, CustomPropertyCollection=None, Origin=None):
        self.original_tagname_ = None
        self.FieldCollection = FieldCollection
        self.CustomPropertyCollection = CustomPropertyCollection
        self.Origin = Origin
    def factory(*args_, **kwargs_):
        if Summary.subclass:
            return Summary.subclass(*args_, **kwargs_)
        else:
            return Summary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FieldCollection(self): return self.FieldCollection
    def set_FieldCollection(self, FieldCollection): self.FieldCollection = FieldCollection
    def get_CustomPropertyCollection(self): return self.CustomPropertyCollection
    def set_CustomPropertyCollection(self, CustomPropertyCollection): self.CustomPropertyCollection = CustomPropertyCollection
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    def hasContent_(self):
        if (
            self.FieldCollection is not None or
            self.CustomPropertyCollection is not None or
            self.Origin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Summary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Summary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Summary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Summary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Summary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FieldCollection is not None:
            self.FieldCollection.export(outfile, level, namespace_, name_='FieldCollection', pretty_print=pretty_print)
        if self.CustomPropertyCollection is not None:
            self.CustomPropertyCollection.export(outfile, level, namespace_, name_='CustomPropertyCollection', pretty_print=pretty_print)
        if self.Origin is not None:
            self.Origin.export(outfile, level, namespace_, name_='Origin', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Summary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FieldCollection is not None:
            showIndent(outfile, level)
            outfile.write('FieldCollection=model_.FieldCollection(\n')
            self.FieldCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CustomPropertyCollection is not None:
            showIndent(outfile, level)
            outfile.write('CustomPropertyCollection=model_.CustomPropertyCollection(\n')
            self.CustomPropertyCollection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Origin is not None:
            showIndent(outfile, level)
            outfile.write('Origin=model_.Origin(\n')
            self.Origin.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FieldCollection':
            obj_ = FieldCollection.factory()
            obj_.build(child_)
            self.FieldCollection = obj_
            obj_.original_tagname_ = 'FieldCollection'
        elif nodeName_ == 'CustomPropertyCollection':
            obj_ = CustomPropertyCollection.factory()
            obj_.build(child_)
            self.CustomPropertyCollection = obj_
            obj_.original_tagname_ = 'CustomPropertyCollection'
        elif nodeName_ == 'Origin':
            obj_ = Origin.factory()
            obj_.build(child_)
            self.Origin = obj_
            obj_.original_tagname_ = 'Origin'
# end class Summary


class TextBlock(GeneratedsSuper):
    """A text block chart item object. Part of the chart item inheritance
    hierarchy."""
    subclass = None
    superclass = None
    def __init__(self, TextBlockStyle=None):
        self.original_tagname_ = None
        self.TextBlockStyle = TextBlockStyle
    def factory(*args_, **kwargs_):
        if TextBlock.subclass:
            return TextBlock.subclass(*args_, **kwargs_)
        else:
            return TextBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextBlockStyle(self): return self.TextBlockStyle
    def set_TextBlockStyle(self, TextBlockStyle): self.TextBlockStyle = TextBlockStyle
    def hasContent_(self):
        if (
            self.TextBlockStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextBlock', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TextBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextBlockStyle is not None:
            self.TextBlockStyle.export(outfile, level, namespace_, name_='TextBlockStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TextBlock'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextBlockStyle is not None:
            showIndent(outfile, level)
            outfile.write('TextBlockStyle=model_.TextBlockStyle(\n')
            self.TextBlockStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextBlockStyle':
            obj_ = TextBlockStyle.factory()
            obj_.build(child_)
            self.TextBlockStyle = obj_
            obj_.original_tagname_ = 'TextBlockStyle'
# end class TextBlock


class TextBlockStyle(GeneratedsSuper):
    """Style of the text block chart item. Part of the LNCIStyle
    inheritance hierarchy.Text alignment setting for the label
    text.Mask that controls the auto sizing options for the item. If
    auto sizing is enabled for the width and/or height, a run-time
    error is raised if you set the Width and/or Height
    properties.Color used to fill the chart item when Filled is
    True.Type IDREF of entity used by this style. An entity type is
    a category of entity.If True, the text block is filled. Control
    the fill color using the BackColour property.Signifies whether
    the item is a solid colour, transparent or contains a gradient-
    fill.Height of the item, expressed in Inches. When the value is
    set, a run-time error is raised if the AutosizeOption property
    is not set to AutosizeManualHeight.Width of the line drawn
    around the text block.Color of the line used to draw the chart
    item.Strength associated with the text block, which controls the
    text block border appearance.Strength IDREF associated with the
    text block, which controls the text block border appearance.Type
    of entity used by this style. An entity type is a category of
    entity.Width of the item, expressed in Inches. When the value is
    set, a run-time error is raised if the AutosizeOption property
    is not set to AutosizeManualWidth."""
    subclass = None
    superclass = None
    def __init__(self, LineWidth=None, StrengthReference=None, EntityTypeReference=None, FillStyle=None, LineColour=None, Width=None, BackColour=None, Alignment=None, Strength=None, Height=None, Type=None, Filled=None, AutoSizeOption=None):
        self.original_tagname_ = None
        self.LineWidth = _cast(int, LineWidth)
        self.StrengthReference = _cast(None, StrengthReference)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.FillStyle = _cast(None, FillStyle)
        self.LineColour = _cast(int, LineColour)
        self.Width = _cast(float, Width)
        self.BackColour = _cast(int, BackColour)
        self.Alignment = _cast(None, Alignment)
        self.Strength = _cast(None, Strength)
        self.Height = _cast(float, Height)
        self.Type = _cast(None, Type)
        self.Filled = _cast(bool, Filled)
        self.AutoSizeOption = _cast(None, AutoSizeOption)
    def factory(*args_, **kwargs_):
        if TextBlockStyle.subclass:
            return TextBlockStyle.subclass(*args_, **kwargs_)
        else:
            return TextBlockStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_FillStyle(self): return self.FillStyle
    def set_FillStyle(self, FillStyle): self.FillStyle = FillStyle
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_Alignment(self): return self.Alignment
    def set_Alignment(self, Alignment): self.Alignment = Alignment
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Filled(self): return self.Filled
    def set_Filled(self, Filled): self.Filled = Filled
    def get_AutoSizeOption(self): return self.AutoSizeOption
    def set_AutoSizeOption(self, AutoSizeOption): self.AutoSizeOption = AutoSizeOption
    def validate_FillStyleEnum(self, value):
        # Validate type FillStyleEnum, a restriction on xsd:string.
        pass
    def validate_TextAlignmentEnum(self, value):
        # Validate type TextAlignmentEnum, a restriction on xsd:string.
        pass
    def validate_AutoSizeOptionEnum(self, value):
        # Validate type AutoSizeOptionEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextBlockStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextBlockStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextBlockStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextBlockStyle'):
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            outfile.write(' FillStyle=%s' % (quote_attrib(self.FillStyle), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            outfile.write(' Width="%s"' % self.gds_format_double(self.Width, input_name='Width'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            outfile.write(' Alignment=%s' % (quote_attrib(self.Alignment), ))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            outfile.write(' Height="%s"' % self.gds_format_double(self.Height, input_name='Height'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            outfile.write(' Filled="%s"' % self.gds_format_boolean(self.Filled, input_name='Filled'))
        if self.AutoSizeOption is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            outfile.write(' AutoSizeOption=%s' % (quote_attrib(self.AutoSizeOption), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextBlockStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TextBlockStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.FillStyle is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            showIndent(outfile, level)
            outfile.write('FillStyle="%s",\n' % (self.FillStyle,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.Width is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            showIndent(outfile, level)
            outfile.write('Width=%e,\n' % (self.Width,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            showIndent(outfile, level)
            outfile.write('Alignment="%s",\n' % (self.Alignment,))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.Height is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            showIndent(outfile, level)
            outfile.write('Height=%e,\n' % (self.Height,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Filled is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            showIndent(outfile, level)
            outfile.write('Filled=%s,\n' % (self.Filled,))
        if self.AutoSizeOption is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            showIndent(outfile, level)
            outfile.write('AutoSizeOption="%s",\n' % (self.AutoSizeOption,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('FillStyle', node)
        if value is not None and 'FillStyle' not in already_processed:
            already_processed.add('FillStyle')
            self.FillStyle = value
            self.validate_FillStyleEnum(self.FillStyle)    # validate type FillStyleEnum
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Width): %s' % exp)
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Alignment', node)
        if value is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            self.Alignment = value
            self.validate_TextAlignmentEnum(self.Alignment)    # validate type TextAlignmentEnum
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Height): %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Filled', node)
        if value is not None and 'Filled' not in already_processed:
            already_processed.add('Filled')
            if value in ('true', '1'):
                self.Filled = True
            elif value in ('false', '0'):
                self.Filled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('AutoSizeOption', node)
        if value is not None and 'AutoSizeOption' not in already_processed:
            already_processed.add('AutoSizeOption')
            self.AutoSizeOption = value
            self.validate_AutoSizeOptionEnum(self.AutoSizeOption)    # validate type AutoSizeOptionEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextBlockStyle


class Theme(GeneratedsSuper):
    """A theme line chart item object. Part of the chart item inheritance
    hierarchy.X position of the label, relative to theme line icon
    position, in world coordinates.Y position of the label, relative
    to theme line icon position, in world coordinates."""
    subclass = None
    superclass = None
    def __init__(self, TextX=0, TextY=16, ThemeStyle=None):
        self.original_tagname_ = None
        self.TextX = _cast(int, TextX)
        self.TextY = _cast(int, TextY)
        self.ThemeStyle = ThemeStyle
    def factory(*args_, **kwargs_):
        if Theme.subclass:
            return Theme.subclass(*args_, **kwargs_)
        else:
            return Theme(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThemeStyle(self): return self.ThemeStyle
    def set_ThemeStyle(self, ThemeStyle): self.ThemeStyle = ThemeStyle
    def get_TextX(self): return self.TextX
    def set_TextX(self, TextX): self.TextX = TextX
    def get_TextY(self): return self.TextY
    def set_TextY(self, TextY): self.TextY = TextY
    def hasContent_(self):
        if (
            self.ThemeStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Theme', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Theme')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Theme', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Theme'):
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            outfile.write(' TextX="%s"' % self.gds_format_integer(self.TextX, input_name='TextX'))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            outfile.write(' TextY="%s"' % self.gds_format_integer(self.TextY, input_name='TextY'))
    def exportChildren(self, outfile, level, namespace_='', name_='Theme', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ThemeStyle is not None:
            self.ThemeStyle.export(outfile, level, namespace_, name_='ThemeStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Theme'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TextX is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            showIndent(outfile, level)
            outfile.write('TextX=%d,\n' % (self.TextX,))
        if self.TextY is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            showIndent(outfile, level)
            outfile.write('TextY=%d,\n' % (self.TextY,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ThemeStyle is not None:
            showIndent(outfile, level)
            outfile.write('ThemeStyle=model_.ThemeStyle(\n')
            self.ThemeStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TextX', node)
        if value is not None and 'TextX' not in already_processed:
            already_processed.add('TextX')
            try:
                self.TextX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TextY', node)
        if value is not None and 'TextY' not in already_processed:
            already_processed.add('TextY')
            try:
                self.TextY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThemeStyle':
            obj_ = ThemeStyle.factory()
            obj_.build(child_)
            self.ThemeStyle = obj_
            obj_.original_tagname_ = 'ThemeStyle'
# end class Theme


class ThemeJunctions(GeneratedsSuper):
    """Collection of theme line junctions.Theme ID that can be used when
    IdReferenceLinking is False.Theme IDREF."""
    subclass = None
    superclass = None
    def __init__(self, ThemeReference=None, ThemeId=None, Junction=None):
        self.original_tagname_ = None
        self.ThemeReference = _cast(None, ThemeReference)
        self.ThemeId = _cast(None, ThemeId)
        if Junction is None:
            self.Junction = []
        else:
            self.Junction = Junction
    def factory(*args_, **kwargs_):
        if ThemeJunctions.subclass:
            return ThemeJunctions.subclass(*args_, **kwargs_)
        else:
            return ThemeJunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Junction(self): return self.Junction
    def set_Junction(self, Junction): self.Junction = Junction
    def add_Junction(self, value): self.Junction.append(value)
    def insert_Junction(self, index, value): self.Junction[index] = value
    def get_ThemeReference(self): return self.ThemeReference
    def set_ThemeReference(self, ThemeReference): self.ThemeReference = ThemeReference
    def get_ThemeId(self): return self.ThemeId
    def set_ThemeId(self, ThemeId): self.ThemeId = ThemeId
    def hasContent_(self):
        if (
            self.Junction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ThemeJunctions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThemeJunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ThemeJunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThemeJunctions'):
        if self.ThemeReference is not None and 'ThemeReference' not in already_processed:
            already_processed.add('ThemeReference')
            outfile.write(' ThemeReference=%s' % (self.gds_format_string(quote_attrib(self.ThemeReference).encode(ExternalEncoding), input_name='ThemeReference'), ))
        if self.ThemeId is not None and 'ThemeId' not in already_processed:
            already_processed.add('ThemeId')
            outfile.write(' ThemeId=%s' % (self.gds_format_string(quote_attrib(self.ThemeId).encode(ExternalEncoding), input_name='ThemeId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ThemeJunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Junction_ in self.Junction:
            Junction_.export(outfile, level, namespace_, name_='Junction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ThemeJunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ThemeReference is not None and 'ThemeReference' not in already_processed:
            already_processed.add('ThemeReference')
            showIndent(outfile, level)
            outfile.write('ThemeReference="%s",\n' % (self.ThemeReference,))
        if self.ThemeId is not None and 'ThemeId' not in already_processed:
            already_processed.add('ThemeId')
            showIndent(outfile, level)
            outfile.write('ThemeId="%s",\n' % (self.ThemeId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Junction=[\n')
        level += 1
        for Junction_ in self.Junction:
            showIndent(outfile, level)
            outfile.write('model_.Junction(\n')
            Junction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ThemeReference', node)
        if value is not None and 'ThemeReference' not in already_processed:
            already_processed.add('ThemeReference')
            self.ThemeReference = value
        value = find_attr_value_('ThemeId', node)
        if value is not None and 'ThemeId' not in already_processed:
            already_processed.add('ThemeId')
            self.ThemeId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Junction':
            obj_ = Junction.factory()
            obj_.build(child_)
            self.Junction.append(obj_)
            obj_.original_tagname_ = 'Junction'
# end class ThemeJunctions


class ThemeStyle(GeneratedsSuper):
    """Style of the theme line chart item. Part of the LNCIStyle
    inheritance hierarchy.Theme line wiring style used after the
    theme line icon junction. This style is retained until to the
    next junction to the right that alters the theme line
    wiring.Scales the theme line icon.Type IDREF of entity used by
    this style. An entity type is a category of entity.If True, the
    theme line extends to the rightmost side of the chart. If False,
    the position of the righthand terminator is automatically
    controlled by the placement of other features on the theme
    line.If True, the theme line extends to the leftmost side of the
    chart. If False, the position of the lefthand terminator is
    automatically controlled by the placement of other features on
    the theme line.Terminator style to use at the lefthand end of
    the theme line.Theme line wiring style used after the leftmost
    terminator junction. This style is retained until to the next
    junction to the right that alters the theme line wiring.Width of
    the line representing the span of a theme line.Color of the line
    used to draw the chart item.Terminator style to use at the
    righthand end of the theme line.Strength associated with the
    theme line, which controls the theme line appearance.Strength
    IDREF associated with the theme line, which controls the theme
    line appearance.Type of entity used by this style. An entity
    type is a category of entity.Colour used to override type's
    shaded icon colour."""
    subclass = None
    superclass = None
    def __init__(self, LeftHandTerminator=None, Strength=None, AfterThemeIconWiring=None, GoesToChartStart=None, StrengthReference=None, EntityTypeReference=None, LineColour=None, GoesToChartEnd=None, Enlargement=None, LeftMostWiring=None, RightHandTerminator=None, IconShadingColour=None, LineWidth=None, Type=None, FrameStyle=None, IconPicture=None):
        self.original_tagname_ = None
        self.LeftHandTerminator = _cast(None, LeftHandTerminator)
        self.Strength = _cast(None, Strength)
        self.AfterThemeIconWiring = _cast(None, AfterThemeIconWiring)
        self.GoesToChartStart = _cast(bool, GoesToChartStart)
        self.StrengthReference = _cast(None, StrengthReference)
        self.EntityTypeReference = _cast(None, EntityTypeReference)
        self.LineColour = _cast(int, LineColour)
        self.GoesToChartEnd = _cast(bool, GoesToChartEnd)
        self.Enlargement = _cast(None, Enlargement)
        self.LeftMostWiring = _cast(None, LeftMostWiring)
        self.RightHandTerminator = _cast(None, RightHandTerminator)
        self.IconShadingColour = _cast(int, IconShadingColour)
        self.LineWidth = _cast(int, LineWidth)
        self.Type = _cast(None, Type)
        self.FrameStyle = FrameStyle
        self.IconPicture = IconPicture
    def factory(*args_, **kwargs_):
        if ThemeStyle.subclass:
            return ThemeStyle.subclass(*args_, **kwargs_)
        else:
            return ThemeStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FrameStyle(self): return self.FrameStyle
    def set_FrameStyle(self, FrameStyle): self.FrameStyle = FrameStyle
    def get_IconPicture(self): return self.IconPicture
    def set_IconPicture(self, IconPicture): self.IconPicture = IconPicture
    def get_LeftHandTerminator(self): return self.LeftHandTerminator
    def set_LeftHandTerminator(self, LeftHandTerminator): self.LeftHandTerminator = LeftHandTerminator
    def get_Strength(self): return self.Strength
    def set_Strength(self, Strength): self.Strength = Strength
    def get_AfterThemeIconWiring(self): return self.AfterThemeIconWiring
    def set_AfterThemeIconWiring(self, AfterThemeIconWiring): self.AfterThemeIconWiring = AfterThemeIconWiring
    def get_GoesToChartStart(self): return self.GoesToChartStart
    def set_GoesToChartStart(self, GoesToChartStart): self.GoesToChartStart = GoesToChartStart
    def get_StrengthReference(self): return self.StrengthReference
    def set_StrengthReference(self, StrengthReference): self.StrengthReference = StrengthReference
    def get_EntityTypeReference(self): return self.EntityTypeReference
    def set_EntityTypeReference(self, EntityTypeReference): self.EntityTypeReference = EntityTypeReference
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_GoesToChartEnd(self): return self.GoesToChartEnd
    def set_GoesToChartEnd(self, GoesToChartEnd): self.GoesToChartEnd = GoesToChartEnd
    def get_Enlargement(self): return self.Enlargement
    def set_Enlargement(self, Enlargement): self.Enlargement = Enlargement
    def get_LeftMostWiring(self): return self.LeftMostWiring
    def set_LeftMostWiring(self, LeftMostWiring): self.LeftMostWiring = LeftMostWiring
    def get_RightHandTerminator(self): return self.RightHandTerminator
    def set_RightHandTerminator(self, RightHandTerminator): self.RightHandTerminator = RightHandTerminator
    def get_IconShadingColour(self): return self.IconShadingColour
    def set_IconShadingColour(self, IconShadingColour): self.IconShadingColour = IconShadingColour
    def get_LineWidth(self): return self.LineWidth
    def set_LineWidth(self, LineWidth): self.LineWidth = LineWidth
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ThemeTerminatorEnum(self, value):
        # Validate type ThemeTerminatorEnum, a restriction on xsd:string.
        pass
    def validate_ThemeWiringOptionEnum(self, value):
        # Validate type ThemeWiringOptionEnum, a restriction on xsd:string.
        pass
    def validate_IconEnlargementEnum(self, value):
        # Validate type IconEnlargementEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.FrameStyle is not None or
            self.IconPicture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ThemeStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThemeStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ThemeStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThemeStyle'):
        if self.LeftHandTerminator is not None and 'LeftHandTerminator' not in already_processed:
            already_processed.add('LeftHandTerminator')
            outfile.write(' LeftHandTerminator=%s' % (quote_attrib(self.LeftHandTerminator), ))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            outfile.write(' Strength=%s' % (self.gds_format_string(quote_attrib(self.Strength).encode(ExternalEncoding), input_name='Strength'), ))
        if self.AfterThemeIconWiring is not None and 'AfterThemeIconWiring' not in already_processed:
            already_processed.add('AfterThemeIconWiring')
            outfile.write(' AfterThemeIconWiring=%s' % (quote_attrib(self.AfterThemeIconWiring), ))
        if self.GoesToChartStart is not None and 'GoesToChartStart' not in already_processed:
            already_processed.add('GoesToChartStart')
            outfile.write(' GoesToChartStart="%s"' % self.gds_format_boolean(self.GoesToChartStart, input_name='GoesToChartStart'))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            outfile.write(' StrengthReference=%s' % (self.gds_format_string(quote_attrib(self.StrengthReference).encode(ExternalEncoding), input_name='StrengthReference'), ))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            outfile.write(' EntityTypeReference=%s' % (self.gds_format_string(quote_attrib(self.EntityTypeReference).encode(ExternalEncoding), input_name='EntityTypeReference'), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.GoesToChartEnd is not None and 'GoesToChartEnd' not in already_processed:
            already_processed.add('GoesToChartEnd')
            outfile.write(' GoesToChartEnd="%s"' % self.gds_format_boolean(self.GoesToChartEnd, input_name='GoesToChartEnd'))
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            outfile.write(' Enlargement=%s' % (quote_attrib(self.Enlargement), ))
        if self.LeftMostWiring is not None and 'LeftMostWiring' not in already_processed:
            already_processed.add('LeftMostWiring')
            outfile.write(' LeftMostWiring=%s' % (quote_attrib(self.LeftMostWiring), ))
        if self.RightHandTerminator is not None and 'RightHandTerminator' not in already_processed:
            already_processed.add('RightHandTerminator')
            outfile.write(' RightHandTerminator=%s' % (quote_attrib(self.RightHandTerminator), ))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            outfile.write(' IconShadingColour="%s"' % self.gds_format_integer(self.IconShadingColour, input_name='IconShadingColour'))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            outfile.write(' LineWidth="%s"' % self.gds_format_integer(self.LineWidth, input_name='LineWidth'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ThemeStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FrameStyle is not None:
            self.FrameStyle.export(outfile, level, namespace_, name_='FrameStyle', pretty_print=pretty_print)
        if self.IconPicture is not None:
            self.IconPicture.export(outfile, level, namespace_, name_='IconPicture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ThemeStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LeftHandTerminator is not None and 'LeftHandTerminator' not in already_processed:
            already_processed.add('LeftHandTerminator')
            showIndent(outfile, level)
            outfile.write('LeftHandTerminator="%s",\n' % (self.LeftHandTerminator,))
        if self.Strength is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            showIndent(outfile, level)
            outfile.write('Strength="%s",\n' % (self.Strength,))
        if self.AfterThemeIconWiring is not None and 'AfterThemeIconWiring' not in already_processed:
            already_processed.add('AfterThemeIconWiring')
            showIndent(outfile, level)
            outfile.write('AfterThemeIconWiring="%s",\n' % (self.AfterThemeIconWiring,))
        if self.GoesToChartStart is not None and 'GoesToChartStart' not in already_processed:
            already_processed.add('GoesToChartStart')
            showIndent(outfile, level)
            outfile.write('GoesToChartStart=%s,\n' % (self.GoesToChartStart,))
        if self.StrengthReference is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            showIndent(outfile, level)
            outfile.write('StrengthReference="%s",\n' % (self.StrengthReference,))
        if self.EntityTypeReference is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            showIndent(outfile, level)
            outfile.write('EntityTypeReference="%s",\n' % (self.EntityTypeReference,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.GoesToChartEnd is not None and 'GoesToChartEnd' not in already_processed:
            already_processed.add('GoesToChartEnd')
            showIndent(outfile, level)
            outfile.write('GoesToChartEnd=%s,\n' % (self.GoesToChartEnd,))
        if self.Enlargement is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            showIndent(outfile, level)
            outfile.write('Enlargement="%s",\n' % (self.Enlargement,))
        if self.LeftMostWiring is not None and 'LeftMostWiring' not in already_processed:
            already_processed.add('LeftMostWiring')
            showIndent(outfile, level)
            outfile.write('LeftMostWiring="%s",\n' % (self.LeftMostWiring,))
        if self.RightHandTerminator is not None and 'RightHandTerminator' not in already_processed:
            already_processed.add('RightHandTerminator')
            showIndent(outfile, level)
            outfile.write('RightHandTerminator="%s",\n' % (self.RightHandTerminator,))
        if self.IconShadingColour is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            showIndent(outfile, level)
            outfile.write('IconShadingColour=%d,\n' % (self.IconShadingColour,))
        if self.LineWidth is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            showIndent(outfile, level)
            outfile.write('LineWidth=%d,\n' % (self.LineWidth,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FrameStyle is not None:
            showIndent(outfile, level)
            outfile.write('FrameStyle=model_.FrameStyle(\n')
            self.FrameStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IconPicture is not None:
            showIndent(outfile, level)
            outfile.write('IconPicture=model_.IconPicture(\n')
            self.IconPicture.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LeftHandTerminator', node)
        if value is not None and 'LeftHandTerminator' not in already_processed:
            already_processed.add('LeftHandTerminator')
            self.LeftHandTerminator = value
            self.validate_ThemeTerminatorEnum(self.LeftHandTerminator)    # validate type ThemeTerminatorEnum
        value = find_attr_value_('Strength', node)
        if value is not None and 'Strength' not in already_processed:
            already_processed.add('Strength')
            self.Strength = value
        value = find_attr_value_('AfterThemeIconWiring', node)
        if value is not None and 'AfterThemeIconWiring' not in already_processed:
            already_processed.add('AfterThemeIconWiring')
            self.AfterThemeIconWiring = value
            self.validate_ThemeWiringOptionEnum(self.AfterThemeIconWiring)    # validate type ThemeWiringOptionEnum
        value = find_attr_value_('GoesToChartStart', node)
        if value is not None and 'GoesToChartStart' not in already_processed:
            already_processed.add('GoesToChartStart')
            if value in ('true', '1'):
                self.GoesToChartStart = True
            elif value in ('false', '0'):
                self.GoesToChartStart = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StrengthReference', node)
        if value is not None and 'StrengthReference' not in already_processed:
            already_processed.add('StrengthReference')
            self.StrengthReference = value
        value = find_attr_value_('EntityTypeReference', node)
        if value is not None and 'EntityTypeReference' not in already_processed:
            already_processed.add('EntityTypeReference')
            self.EntityTypeReference = value
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GoesToChartEnd', node)
        if value is not None and 'GoesToChartEnd' not in already_processed:
            already_processed.add('GoesToChartEnd')
            if value in ('true', '1'):
                self.GoesToChartEnd = True
            elif value in ('false', '0'):
                self.GoesToChartEnd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Enlargement', node)
        if value is not None and 'Enlargement' not in already_processed:
            already_processed.add('Enlargement')
            self.Enlargement = value
            self.validate_IconEnlargementEnum(self.Enlargement)    # validate type IconEnlargementEnum
        value = find_attr_value_('LeftMostWiring', node)
        if value is not None and 'LeftMostWiring' not in already_processed:
            already_processed.add('LeftMostWiring')
            self.LeftMostWiring = value
            self.validate_ThemeWiringOptionEnum(self.LeftMostWiring)    # validate type ThemeWiringOptionEnum
        value = find_attr_value_('RightHandTerminator', node)
        if value is not None and 'RightHandTerminator' not in already_processed:
            already_processed.add('RightHandTerminator')
            self.RightHandTerminator = value
            self.validate_ThemeTerminatorEnum(self.RightHandTerminator)    # validate type ThemeTerminatorEnum
        value = find_attr_value_('IconShadingColour', node)
        if value is not None and 'IconShadingColour' not in already_processed:
            already_processed.add('IconShadingColour')
            try:
                self.IconShadingColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LineWidth', node)
        if value is not None and 'LineWidth' not in already_processed:
            already_processed.add('LineWidth')
            try:
                self.LineWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FrameStyle':
            obj_ = FrameStyle.factory()
            obj_.build(child_)
            self.FrameStyle = obj_
            obj_.original_tagname_ = 'FrameStyle'
        elif nodeName_ == 'IconPicture':
            obj_ = IconPicture.factory()
            obj_.build(child_)
            self.IconPicture = obj_
            obj_.original_tagname_ = 'IconPicture'
# end class ThemeStyle


class TimeBar(GeneratedsSuper):
    """The time bar object.Color used for the background of the time
    bar.Color of the time bar border line.If True, the time bar will
    be visible the next time the chart is opened."""
    subclass = None
    superclass = None
    def __init__(self, BorderLineColour=None, BackColour=None, NewViewTimeBarVisible=None, TimeBarIntervalBandStyle=None, TimeBarMarkerBandStyle=None, TimeBarTickBandStyle=None):
        self.original_tagname_ = None
        self.BorderLineColour = _cast(int, BorderLineColour)
        self.BackColour = _cast(int, BackColour)
        self.NewViewTimeBarVisible = _cast(bool, NewViewTimeBarVisible)
        self.TimeBarIntervalBandStyle = TimeBarIntervalBandStyle
        self.TimeBarMarkerBandStyle = TimeBarMarkerBandStyle
        self.TimeBarTickBandStyle = TimeBarTickBandStyle
    def factory(*args_, **kwargs_):
        if TimeBar.subclass:
            return TimeBar.subclass(*args_, **kwargs_)
        else:
            return TimeBar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeBarIntervalBandStyle(self): return self.TimeBarIntervalBandStyle
    def set_TimeBarIntervalBandStyle(self, TimeBarIntervalBandStyle): self.TimeBarIntervalBandStyle = TimeBarIntervalBandStyle
    def get_TimeBarMarkerBandStyle(self): return self.TimeBarMarkerBandStyle
    def set_TimeBarMarkerBandStyle(self, TimeBarMarkerBandStyle): self.TimeBarMarkerBandStyle = TimeBarMarkerBandStyle
    def get_TimeBarTickBandStyle(self): return self.TimeBarTickBandStyle
    def set_TimeBarTickBandStyle(self, TimeBarTickBandStyle): self.TimeBarTickBandStyle = TimeBarTickBandStyle
    def get_BorderLineColour(self): return self.BorderLineColour
    def set_BorderLineColour(self, BorderLineColour): self.BorderLineColour = BorderLineColour
    def get_BackColour(self): return self.BackColour
    def set_BackColour(self, BackColour): self.BackColour = BackColour
    def get_NewViewTimeBarVisible(self): return self.NewViewTimeBarVisible
    def set_NewViewTimeBarVisible(self, NewViewTimeBarVisible): self.NewViewTimeBarVisible = NewViewTimeBarVisible
    def hasContent_(self):
        if (
            self.TimeBarIntervalBandStyle is not None or
            self.TimeBarMarkerBandStyle is not None or
            self.TimeBarTickBandStyle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeBar', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeBar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeBar', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeBar'):
        if self.BorderLineColour is not None and 'BorderLineColour' not in already_processed:
            already_processed.add('BorderLineColour')
            outfile.write(' BorderLineColour="%s"' % self.gds_format_integer(self.BorderLineColour, input_name='BorderLineColour'))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            outfile.write(' BackColour="%s"' % self.gds_format_integer(self.BackColour, input_name='BackColour'))
        if self.NewViewTimeBarVisible is not None and 'NewViewTimeBarVisible' not in already_processed:
            already_processed.add('NewViewTimeBarVisible')
            outfile.write(' NewViewTimeBarVisible="%s"' % self.gds_format_boolean(self.NewViewTimeBarVisible, input_name='NewViewTimeBarVisible'))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeBar', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeBarIntervalBandStyle is not None:
            self.TimeBarIntervalBandStyle.export(outfile, level, namespace_, name_='TimeBarIntervalBandStyle', pretty_print=pretty_print)
        if self.TimeBarMarkerBandStyle is not None:
            self.TimeBarMarkerBandStyle.export(outfile, level, namespace_, name_='TimeBarMarkerBandStyle', pretty_print=pretty_print)
        if self.TimeBarTickBandStyle is not None:
            self.TimeBarTickBandStyle.export(outfile, level, namespace_, name_='TimeBarTickBandStyle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeBar'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BorderLineColour is not None and 'BorderLineColour' not in already_processed:
            already_processed.add('BorderLineColour')
            showIndent(outfile, level)
            outfile.write('BorderLineColour=%d,\n' % (self.BorderLineColour,))
        if self.BackColour is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            showIndent(outfile, level)
            outfile.write('BackColour=%d,\n' % (self.BackColour,))
        if self.NewViewTimeBarVisible is not None and 'NewViewTimeBarVisible' not in already_processed:
            already_processed.add('NewViewTimeBarVisible')
            showIndent(outfile, level)
            outfile.write('NewViewTimeBarVisible=%s,\n' % (self.NewViewTimeBarVisible,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeBarIntervalBandStyle is not None:
            showIndent(outfile, level)
            outfile.write('TimeBarIntervalBandStyle=model_.TimeBarIntervalBandStyle(\n')
            self.TimeBarIntervalBandStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeBarMarkerBandStyle is not None:
            showIndent(outfile, level)
            outfile.write('TimeBarMarkerBandStyle=model_.TimeBarMarkerBandStyle(\n')
            self.TimeBarMarkerBandStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeBarTickBandStyle is not None:
            showIndent(outfile, level)
            outfile.write('TimeBarTickBandStyle=model_.TimeBarTickBandStyle(\n')
            self.TimeBarTickBandStyle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BorderLineColour', node)
        if value is not None and 'BorderLineColour' not in already_processed:
            already_processed.add('BorderLineColour')
            try:
                self.BorderLineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('BackColour', node)
        if value is not None and 'BackColour' not in already_processed:
            already_processed.add('BackColour')
            try:
                self.BackColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NewViewTimeBarVisible', node)
        if value is not None and 'NewViewTimeBarVisible' not in already_processed:
            already_processed.add('NewViewTimeBarVisible')
            if value in ('true', '1'):
                self.NewViewTimeBarVisible = True
            elif value in ('false', '0'):
                self.NewViewTimeBarVisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeBarIntervalBandStyle':
            obj_ = TimeBarIntervalBandStyle.factory()
            obj_.build(child_)
            self.TimeBarIntervalBandStyle = obj_
            obj_.original_tagname_ = 'TimeBarIntervalBandStyle'
        elif nodeName_ == 'TimeBarMarkerBandStyle':
            obj_ = TimeBarMarkerBandStyle.factory()
            obj_.build(child_)
            self.TimeBarMarkerBandStyle = obj_
            obj_.original_tagname_ = 'TimeBarMarkerBandStyle'
        elif nodeName_ == 'TimeBarTickBandStyle':
            obj_ = TimeBarTickBandStyle.factory()
            obj_.build(child_)
            self.TimeBarTickBandStyle = obj_
            obj_.original_tagname_ = 'TimeBarTickBandStyle'
# end class TimeBar


class TimeBarIntervalBandStyle(GeneratedsSuper):
    """Style of the time bar interval band.Alignment of the labels within
    the interval band of the time bar.Color of the lines within this
    time bar band.If True, this time bar band is displayed."""
    subclass = None
    superclass = None
    def __init__(self, IntervalLabelAlignment=None, LineColour=None, Visible=None, Font=None):
        self.original_tagname_ = None
        self.IntervalLabelAlignment = _cast(None, IntervalLabelAlignment)
        self.LineColour = _cast(int, LineColour)
        self.Visible = _cast(bool, Visible)
        self.Font = Font
    def factory(*args_, **kwargs_):
        if TimeBarIntervalBandStyle.subclass:
            return TimeBarIntervalBandStyle.subclass(*args_, **kwargs_)
        else:
            return TimeBarIntervalBandStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_IntervalLabelAlignment(self): return self.IntervalLabelAlignment
    def set_IntervalLabelAlignment(self, IntervalLabelAlignment): self.IntervalLabelAlignment = IntervalLabelAlignment
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def validate_TimeBarLabelAlignmentEnum(self, value):
        # Validate type TimeBarLabelAlignmentEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.Font is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeBarIntervalBandStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeBarIntervalBandStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeBarIntervalBandStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeBarIntervalBandStyle'):
        if self.IntervalLabelAlignment is not None and 'IntervalLabelAlignment' not in already_processed:
            already_processed.add('IntervalLabelAlignment')
            outfile.write(' IntervalLabelAlignment=%s' % (quote_attrib(self.IntervalLabelAlignment), ))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeBarIntervalBandStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            self.Font.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeBarIntervalBandStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IntervalLabelAlignment is not None and 'IntervalLabelAlignment' not in already_processed:
            already_processed.add('IntervalLabelAlignment')
            showIndent(outfile, level)
            outfile.write('IntervalLabelAlignment="%s",\n' % (self.IntervalLabelAlignment,))
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Font is not None:
            showIndent(outfile, level)
            outfile.write('Font=model_.Font(\n')
            self.Font.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IntervalLabelAlignment', node)
        if value is not None and 'IntervalLabelAlignment' not in already_processed:
            already_processed.add('IntervalLabelAlignment')
            self.IntervalLabelAlignment = value
            self.validate_TimeBarLabelAlignmentEnum(self.IntervalLabelAlignment)    # validate type TimeBarLabelAlignmentEnum
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
# end class TimeBarIntervalBandStyle


class TimeBarMarkerBandStyle(GeneratedsSuper):
    """Style of the time bar marker band.Color of symbols within the marker
    band of the time bar.Color of overlapping symbols within the
    marker band of the time bar.If True, this time bar marker band
    is displayed."""
    subclass = None
    superclass = None
    def __init__(self, MarkerSymbolColour=None, Visible=None, OverLappingMarkerSymbolColour=None):
        self.original_tagname_ = None
        self.MarkerSymbolColour = _cast(int, MarkerSymbolColour)
        self.Visible = _cast(bool, Visible)
        self.OverLappingMarkerSymbolColour = _cast(int, OverLappingMarkerSymbolColour)
    def factory(*args_, **kwargs_):
        if TimeBarMarkerBandStyle.subclass:
            return TimeBarMarkerBandStyle.subclass(*args_, **kwargs_)
        else:
            return TimeBarMarkerBandStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MarkerSymbolColour(self): return self.MarkerSymbolColour
    def set_MarkerSymbolColour(self, MarkerSymbolColour): self.MarkerSymbolColour = MarkerSymbolColour
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_OverLappingMarkerSymbolColour(self): return self.OverLappingMarkerSymbolColour
    def set_OverLappingMarkerSymbolColour(self, OverLappingMarkerSymbolColour): self.OverLappingMarkerSymbolColour = OverLappingMarkerSymbolColour
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeBarMarkerBandStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeBarMarkerBandStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeBarMarkerBandStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeBarMarkerBandStyle'):
        if self.MarkerSymbolColour is not None and 'MarkerSymbolColour' not in already_processed:
            already_processed.add('MarkerSymbolColour')
            outfile.write(' MarkerSymbolColour="%s"' % self.gds_format_integer(self.MarkerSymbolColour, input_name='MarkerSymbolColour'))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.OverLappingMarkerSymbolColour is not None and 'OverLappingMarkerSymbolColour' not in already_processed:
            already_processed.add('OverLappingMarkerSymbolColour')
            outfile.write(' OverLappingMarkerSymbolColour="%s"' % self.gds_format_integer(self.OverLappingMarkerSymbolColour, input_name='OverLappingMarkerSymbolColour'))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeBarMarkerBandStyle', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TimeBarMarkerBandStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MarkerSymbolColour is not None and 'MarkerSymbolColour' not in already_processed:
            already_processed.add('MarkerSymbolColour')
            showIndent(outfile, level)
            outfile.write('MarkerSymbolColour=%d,\n' % (self.MarkerSymbolColour,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.OverLappingMarkerSymbolColour is not None and 'OverLappingMarkerSymbolColour' not in already_processed:
            already_processed.add('OverLappingMarkerSymbolColour')
            showIndent(outfile, level)
            outfile.write('OverLappingMarkerSymbolColour=%d,\n' % (self.OverLappingMarkerSymbolColour,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MarkerSymbolColour', node)
        if value is not None and 'MarkerSymbolColour' not in already_processed:
            already_processed.add('MarkerSymbolColour')
            try:
                self.MarkerSymbolColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OverLappingMarkerSymbolColour', node)
        if value is not None and 'OverLappingMarkerSymbolColour' not in already_processed:
            already_processed.add('OverLappingMarkerSymbolColour')
            try:
                self.OverLappingMarkerSymbolColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeBarMarkerBandStyle


class TimeBarTickBandStyle(GeneratedsSuper):
    """Style of the time bar tick band.Color of the lines within this time
    bar tick band.Alignment of the labels within the tick band of
    the time bar.If True, this time bar tick band is displayed."""
    subclass = None
    superclass = None
    def __init__(self, LineColour=None, Visible=None, MajorTickLabelAlignment=None, Font=None):
        self.original_tagname_ = None
        self.LineColour = _cast(int, LineColour)
        self.Visible = _cast(bool, Visible)
        self.MajorTickLabelAlignment = _cast(None, MajorTickLabelAlignment)
        self.Font = Font
    def factory(*args_, **kwargs_):
        if TimeBarTickBandStyle.subclass:
            return TimeBarTickBandStyle.subclass(*args_, **kwargs_)
        else:
            return TimeBarTickBandStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_LineColour(self): return self.LineColour
    def set_LineColour(self, LineColour): self.LineColour = LineColour
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def get_MajorTickLabelAlignment(self): return self.MajorTickLabelAlignment
    def set_MajorTickLabelAlignment(self, MajorTickLabelAlignment): self.MajorTickLabelAlignment = MajorTickLabelAlignment
    def validate_TimeBarLabelAlignmentEnum(self, value):
        # Validate type TimeBarLabelAlignmentEnum, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.Font is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeBarTickBandStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeBarTickBandStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeBarTickBandStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeBarTickBandStyle'):
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            outfile.write(' LineColour="%s"' % self.gds_format_integer(self.LineColour, input_name='LineColour'))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            outfile.write(' Visible="%s"' % self.gds_format_boolean(self.Visible, input_name='Visible'))
        if self.MajorTickLabelAlignment is not None and 'MajorTickLabelAlignment' not in already_processed:
            already_processed.add('MajorTickLabelAlignment')
            outfile.write(' MajorTickLabelAlignment=%s' % (quote_attrib(self.MajorTickLabelAlignment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeBarTickBandStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            self.Font.export(outfile, level, namespace_, name_='Font', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeBarTickBandStyle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LineColour is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            showIndent(outfile, level)
            outfile.write('LineColour=%d,\n' % (self.LineColour,))
        if self.Visible is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            showIndent(outfile, level)
            outfile.write('Visible=%s,\n' % (self.Visible,))
        if self.MajorTickLabelAlignment is not None and 'MajorTickLabelAlignment' not in already_processed:
            already_processed.add('MajorTickLabelAlignment')
            showIndent(outfile, level)
            outfile.write('MajorTickLabelAlignment="%s",\n' % (self.MajorTickLabelAlignment,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Font is not None:
            showIndent(outfile, level)
            outfile.write('Font=model_.Font(\n')
            self.Font.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LineColour', node)
        if value is not None and 'LineColour' not in already_processed:
            already_processed.add('LineColour')
            try:
                self.LineColour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Visible', node)
        if value is not None and 'Visible' not in already_processed:
            already_processed.add('Visible')
            if value in ('true', '1'):
                self.Visible = True
            elif value in ('false', '0'):
                self.Visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MajorTickLabelAlignment', node)
        if value is not None and 'MajorTickLabelAlignment' not in already_processed:
            already_processed.add('MajorTickLabelAlignment')
            self.MajorTickLabelAlignment = value
            self.validate_TimeBarLabelAlignmentEnum(self.MajorTickLabelAlignment)    # validate type TimeBarLabelAlignmentEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Font':
            obj_ = Font.factory()
            obj_.build(child_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
# end class TimeBarTickBandStyle


class TimeZone(GeneratedsSuper):
    """A time zone object from the collection of time zones.Long name to
    describe the time zone. For example, '(GMT-05:00) Eastern Time
    (N America)'.Unique identifier for the time zone, which can be
    used to retrieve the time zone object."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, UniqueID=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.UniqueID = _cast(int, UniqueID)
    def factory(*args_, **kwargs_):
        if TimeZone.subclass:
            return TimeZone.subclass(*args_, **kwargs_)
        else:
            return TimeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_UniqueID(self): return self.UniqueID
    def set_UniqueID(self, UniqueID): self.UniqueID = UniqueID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeZone', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeZone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeZone'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.UniqueID is not None and 'UniqueID' not in already_processed:
            already_processed.add('UniqueID')
            outfile.write(' UniqueID="%s"' % self.gds_format_integer(self.UniqueID, input_name='UniqueID'))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeZone', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TimeZone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
        if self.UniqueID is not None and 'UniqueID' not in already_processed:
            already_processed.add('UniqueID')
            showIndent(outfile, level)
            outfile.write('UniqueID=%d,\n' % (self.UniqueID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('UniqueID', node)
        if value is not None and 'UniqueID' not in already_processed:
            already_processed.add('UniqueID')
            try:
                self.UniqueID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeZone


class SectorDefinition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SectorID=None, Description=None):
        self.original_tagname_ = None
        self.SectorID = SectorID
        self.Description = Description
    def factory(*args_, **kwargs_):
        if SectorDefinition.subclass:
            return SectorDefinition.subclass(*args_, **kwargs_)
        else:
            return SectorDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SectorID(self): return self.SectorID
    def set_SectorID(self, SectorID): self.SectorID = SectorID
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.SectorID is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SectorDefinition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SectorDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SectorDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SectorDefinition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SectorDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SectorID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSectorID>%s</%sSectorID>%s' % (namespace_, self.gds_format_string(quote_xml(self.SectorID).encode(ExternalEncoding), input_name='SectorID'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SectorDefinition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SectorID is not None:
            showIndent(outfile, level)
            outfile.write('SectorID=%s,\n' % quote_python(self.SectorID).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SectorID':
            SectorID_ = child_.text
            SectorID_ = self.gds_validate_string(SectorID_, node, 'SectorID')
            self.SectorID = SectorID_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class SectorDefinition


class DocumentationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, Rationale=None, Synonym=None, Description=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        self.Rationale = Rationale
        if Synonym is None:
            self.Synonym = []
        else:
            self.Synonym = Synonym
        self.Description = Description
    def factory(*args_, **kwargs_):
        if DocumentationType.subclass:
            return DocumentationType.subclass(*args_, **kwargs_)
        else:
            return DocumentationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rationale(self): return self.Rationale
    def set_Rationale(self, Rationale): self.Rationale = Rationale
    def get_Synonym(self): return self.Synonym
    def set_Synonym(self, Synonym): self.Synonym = Synonym
    def add_Synonym(self, value): self.Synonym.append(value)
    def insert_Synonym(self, index, value): self.Synonym[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.Rationale is not None or
            self.Synonym or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentationType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentationType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Rationale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRationale>%s</%sRationale>%s' % (namespace_, self.gds_format_string(quote_xml(self.Rationale).encode(ExternalEncoding), input_name='Rationale'), namespace_, eol_))
        for Synonym_ in self.Synonym:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSynonym>%s</%sSynonym>%s' % (namespace_, self.gds_format_string(quote_xml(Synonym_).encode(ExternalEncoding), input_name='Synonym'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DocumentationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % (self.status,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Rationale is not None:
            showIndent(outfile, level)
            outfile.write('Rationale=%s,\n' % quote_python(self.Rationale).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Synonym=[\n')
        level += 1
        for Synonym_ in self.Synonym:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Synonym_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Rationale':
            Rationale_ = child_.text
            Rationale_ = self.gds_validate_string(Rationale_, node, 'Rationale')
            self.Rationale = Rationale_
        elif nodeName_ == 'Synonym':
            Synonym_ = child_.text
            Synonym_ = self.gds_validate_string(Synonym_, node, 'Synonym')
            self.Synonym.append(Synonym_)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class DocumentationType


class SimpleDocumentationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Rationale=None, Description=None):
        self.original_tagname_ = None
        self.Rationale = Rationale
        self.Description = Description
    def factory(*args_, **kwargs_):
        if SimpleDocumentationType.subclass:
            return SimpleDocumentationType.subclass(*args_, **kwargs_)
        else:
            return SimpleDocumentationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rationale(self): return self.Rationale
    def set_Rationale(self, Rationale): self.Rationale = Rationale
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Rationale is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleDocumentationType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleDocumentationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleDocumentationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleDocumentationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleDocumentationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Rationale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRationale>%s</%sRationale>%s' % (namespace_, self.gds_format_string(quote_xml(self.Rationale).encode(ExternalEncoding), input_name='Rationale'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SimpleDocumentationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Rationale is not None:
            showIndent(outfile, level)
            outfile.write('Rationale=%s,\n' % quote_python(self.Rationale).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Rationale':
            Rationale_ = child_.text
            Rationale_ = self.gds_validate_string(Rationale_, node, 'Rationale')
            self.Rationale = Rationale_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class SimpleDocumentationType


class LibraryCatalogueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VersionBuild=None, LocaleVersion=None, VersionMinor=None, VersionRelease=None, LocaleHex=None, VersionMajor=None, Type=None, Property=None, Form=None, Domain=None, SectorDefinition=None):
        self.original_tagname_ = None
        self.VersionBuild = _cast(None, VersionBuild)
        self.LocaleVersion = _cast(None, LocaleVersion)
        self.VersionMinor = _cast(None, VersionMinor)
        self.VersionRelease = _cast(None, VersionRelease)
        self.LocaleHex = _cast(None, LocaleHex)
        self.VersionMajor = _cast(None, VersionMajor)
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if Form is None:
            self.Form = []
        else:
            self.Form = Form
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
        if SectorDefinition is None:
            self.SectorDefinition = []
        else:
            self.SectorDefinition = SectorDefinition
    def factory(*args_, **kwargs_):
        if LibraryCatalogueType.subclass:
            return LibraryCatalogueType.subclass(*args_, **kwargs_)
        else:
            return LibraryCatalogueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def get_Form(self): return self.Form
    def set_Form(self, Form): self.Form = Form
    def add_Form(self, value): self.Form.append(value)
    def insert_Form(self, index, value): self.Form[index] = value
    def get_Domain(self): return self.Domain
    def set_Domain(self, Domain): self.Domain = Domain
    def add_Domain(self, value): self.Domain.append(value)
    def insert_Domain(self, index, value): self.Domain[index] = value
    def get_SectorDefinition(self): return self.SectorDefinition
    def set_SectorDefinition(self, SectorDefinition): self.SectorDefinition = SectorDefinition
    def add_SectorDefinition(self, value): self.SectorDefinition.append(value)
    def insert_SectorDefinition(self, index, value): self.SectorDefinition[index] = value
    def get_VersionBuild(self): return self.VersionBuild
    def set_VersionBuild(self, VersionBuild): self.VersionBuild = VersionBuild
    def get_LocaleVersion(self): return self.LocaleVersion
    def set_LocaleVersion(self, LocaleVersion): self.LocaleVersion = LocaleVersion
    def get_VersionMinor(self): return self.VersionMinor
    def set_VersionMinor(self, VersionMinor): self.VersionMinor = VersionMinor
    def get_VersionRelease(self): return self.VersionRelease
    def set_VersionRelease(self, VersionRelease): self.VersionRelease = VersionRelease
    def get_LocaleHex(self): return self.LocaleHex
    def set_LocaleHex(self, LocaleHex): self.LocaleHex = LocaleHex
    def get_VersionMajor(self): return self.VersionMajor
    def set_VersionMajor(self, VersionMajor): self.VersionMajor = VersionMajor
    def hasContent_(self):
        if (
            self.Type or
            self.Property or
            self.Form or
            self.Domain or
            self.SectorDefinition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LibraryCatalogueType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LibraryCatalogueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LibraryCatalogueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LibraryCatalogueType'):
        if self.VersionBuild is not None and 'VersionBuild' not in already_processed:
            already_processed.add('VersionBuild')
            outfile.write(' VersionBuild=%s' % (quote_attrib(self.VersionBuild), ))
        if self.LocaleVersion is not None and 'LocaleVersion' not in already_processed:
            already_processed.add('LocaleVersion')
            outfile.write(' LocaleVersion=%s' % (quote_attrib(self.LocaleVersion), ))
        if self.VersionMinor is not None and 'VersionMinor' not in already_processed:
            already_processed.add('VersionMinor')
            outfile.write(' VersionMinor=%s' % (quote_attrib(self.VersionMinor), ))
        if self.VersionRelease is not None and 'VersionRelease' not in already_processed:
            already_processed.add('VersionRelease')
            outfile.write(' VersionRelease=%s' % (quote_attrib(self.VersionRelease), ))
        if self.LocaleHex is not None and 'LocaleHex' not in already_processed:
            already_processed.add('LocaleHex')
            outfile.write(' LocaleHex=%s' % (quote_attrib(self.LocaleHex), ))
        if self.VersionMajor is not None and 'VersionMajor' not in already_processed:
            already_processed.add('VersionMajor')
            outfile.write(' VersionMajor=%s' % (quote_attrib(self.VersionMajor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LibraryCatalogueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Type_ in self.Type:
            Type_.export(outfile, level, namespace_='lcx:', name_='Type', pretty_print=pretty_print)
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_='lcx:', name_='Property', pretty_print=pretty_print)
        for Form_ in self.Form:
            Form_.export(outfile, level, namespace_='lcx:', name_='Form', pretty_print=pretty_print)
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespace_='lcx:', name_='Domain', pretty_print=pretty_print)
        for SectorDefinition_ in self.SectorDefinition:
            SectorDefinition_.export(outfile, level, namespace_='lcx:', name_='SectorDefinition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LibraryCatalogueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VersionBuild is not None and 'VersionBuild' not in already_processed:
            already_processed.add('VersionBuild')
            showIndent(outfile, level)
            outfile.write('VersionBuild=%s,\n' % (self.VersionBuild,))
        if self.LocaleVersion is not None and 'LocaleVersion' not in already_processed:
            already_processed.add('LocaleVersion')
            showIndent(outfile, level)
            outfile.write('LocaleVersion=%s,\n' % (self.LocaleVersion,))
        if self.VersionMinor is not None and 'VersionMinor' not in already_processed:
            already_processed.add('VersionMinor')
            showIndent(outfile, level)
            outfile.write('VersionMinor=%s,\n' % (self.VersionMinor,))
        if self.VersionRelease is not None and 'VersionRelease' not in already_processed:
            already_processed.add('VersionRelease')
            showIndent(outfile, level)
            outfile.write('VersionRelease=%s,\n' % (self.VersionRelease,))
        if self.LocaleHex is not None and 'LocaleHex' not in already_processed:
            already_processed.add('LocaleHex')
            showIndent(outfile, level)
            outfile.write('LocaleHex=%s,\n' % (self.LocaleHex,))
        if self.VersionMajor is not None and 'VersionMajor' not in already_processed:
            already_processed.add('VersionMajor')
            showIndent(outfile, level)
            outfile.write('VersionMajor=%s,\n' % (self.VersionMajor,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('model_.Type(\n')
            Type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            Property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Form=[\n')
        level += 1
        for Form_ in self.Form:
            showIndent(outfile, level)
            outfile.write('model_.Form(\n')
            Form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Domain=[\n')
        level += 1
        for Domain_ in self.Domain:
            showIndent(outfile, level)
            outfile.write('model_.Domain(\n')
            Domain_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SectorDefinition=[\n')
        level += 1
        for SectorDefinition_ in self.SectorDefinition:
            showIndent(outfile, level)
            outfile.write('model_.SectorDefinition(\n')
            SectorDefinition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VersionBuild', node)
        if value is not None and 'VersionBuild' not in already_processed:
            already_processed.add('VersionBuild')
            self.VersionBuild = value
        value = find_attr_value_('LocaleVersion', node)
        if value is not None and 'LocaleVersion' not in already_processed:
            already_processed.add('LocaleVersion')
            self.LocaleVersion = value
        value = find_attr_value_('VersionMinor', node)
        if value is not None and 'VersionMinor' not in already_processed:
            already_processed.add('VersionMinor')
            self.VersionMinor = value
        value = find_attr_value_('VersionRelease', node)
        if value is not None and 'VersionRelease' not in already_processed:
            already_processed.add('VersionRelease')
            self.VersionRelease = value
        value = find_attr_value_('LocaleHex', node)
        if value is not None and 'LocaleHex' not in already_processed:
            already_processed.add('LocaleHex')
            self.LocaleHex = value
        value = find_attr_value_('VersionMajor', node)
        if value is not None and 'VersionMajor' not in already_processed:
            already_processed.add('VersionMajor')
            self.VersionMajor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = TypeType.factory()
            obj_.build(child_)
            self.Type.append(obj_)
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        elif nodeName_ == 'Form':
            obj_ = FormType.factory()
            obj_.build(child_)
            self.Form.append(obj_)
            obj_.original_tagname_ = 'Form'
        elif nodeName_ == 'Domain':
            obj_ = DomainType.factory()
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
        elif nodeName_ == 'SectorDefinition':
            obj_ = SectorDefinition.factory()
            obj_.build(child_)
            self.SectorDefinition.append(obj_)
            obj_.original_tagname_ = 'SectorDefinition'
# end class LibraryCatalogueType


class TypeType(GeneratedsSuper):
    """Reference to the tGUID of the type from which this type derives.For
    links only. Defines the link as symmetrical for semantic
    matching purposes."""
    subclass = None
    superclass = None
    def __init__(self, abstract='false', isSymmetricLink=None, tGUID=None, kindOf=None, TypeName=None, ImageFile=None, LNMapping=None, Sector=None, Documentation=None):
        self.original_tagname_ = None
        self.abstract = _cast(None, abstract)
        self.isSymmetricLink = _cast(None, isSymmetricLink)
        self.tGUID = _cast(None, tGUID)
        self.kindOf = _cast(None, kindOf)
        self.TypeName = TypeName
        if ImageFile is None:
            self.ImageFile = []
        else:
            self.ImageFile = ImageFile
        if LNMapping is None:
            self.LNMapping = []
        else:
            self.LNMapping = LNMapping
        if Sector is None:
            self.Sector = []
        else:
            self.Sector = Sector
        self.Documentation = Documentation
    def factory(*args_, **kwargs_):
        if TypeType.subclass:
            return TypeType.subclass(*args_, **kwargs_)
        else:
            return TypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TypeName(self): return self.TypeName
    def set_TypeName(self, TypeName): self.TypeName = TypeName
    def get_ImageFile(self): return self.ImageFile
    def set_ImageFile(self, ImageFile): self.ImageFile = ImageFile
    def add_ImageFile(self, value): self.ImageFile.append(value)
    def insert_ImageFile(self, index, value): self.ImageFile[index] = value
    def get_LNMapping(self): return self.LNMapping
    def set_LNMapping(self, LNMapping): self.LNMapping = LNMapping
    def add_LNMapping(self, value): self.LNMapping.append(value)
    def insert_LNMapping(self, index, value): self.LNMapping[index] = value
    def get_Sector(self): return self.Sector
    def set_Sector(self, Sector): self.Sector = Sector
    def add_Sector(self, value): self.Sector.append(value)
    def insert_Sector(self, index, value): self.Sector[index] = value
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_abstract(self): return self.abstract
    def set_abstract(self, abstract): self.abstract = abstract
    def get_isSymmetricLink(self): return self.isSymmetricLink
    def set_isSymmetricLink(self, isSymmetricLink): self.isSymmetricLink = isSymmetricLink
    def get_tGUID(self): return self.tGUID
    def set_tGUID(self, tGUID): self.tGUID = tGUID
    def get_kindOf(self): return self.kindOf
    def set_kindOf(self, kindOf): self.kindOf = kindOf
    def hasContent_(self):
        if (
            self.TypeName is not None or
            self.ImageFile or
            self.LNMapping or
            self.Sector or
            self.Documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TypeType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TypeType'):
        if self.abstract is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract=%s' % (quote_attrib(self.abstract), ))
        if self.isSymmetricLink is not None and 'isSymmetricLink' not in already_processed:
            already_processed.add('isSymmetricLink')
            outfile.write(' isSymmetricLink=%s' % (quote_attrib(self.isSymmetricLink), ))
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            outfile.write(' tGUID=%s' % (quote_attrib(self.tGUID), ))
        if self.kindOf is not None and 'kindOf' not in already_processed:
            already_processed.add('kindOf')
            outfile.write(' kindOf=%s' % (quote_attrib(self.kindOf), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeName>%s</%sTypeName>%s' % (namespace_, self.gds_format_string(quote_xml(self.TypeName).encode(ExternalEncoding), input_name='TypeName'), namespace_, eol_))
        for ImageFile_ in self.ImageFile:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile>%s</%sImageFile>%s' % (namespace_, self.gds_format_string(quote_xml(ImageFile_).encode(ExternalEncoding), input_name='ImageFile'), namespace_, eol_))
        for LNMapping_ in self.LNMapping:
            LNMapping_.export(outfile, level, namespace_, name_='LNMapping', pretty_print=pretty_print)
        for Sector_ in self.Sector:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSector>%s</%sSector>%s' % (namespace_, self.gds_format_string(quote_xml(Sector_).encode(ExternalEncoding), input_name='Sector'), namespace_, eol_))
        if self.Documentation is not None:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.abstract is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            showIndent(outfile, level)
            outfile.write('abstract=%s,\n' % (self.abstract,))
        if self.isSymmetricLink is not None and 'isSymmetricLink' not in already_processed:
            already_processed.add('isSymmetricLink')
            showIndent(outfile, level)
            outfile.write('isSymmetricLink=%s,\n' % (self.isSymmetricLink,))
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            showIndent(outfile, level)
            outfile.write('tGUID=%s,\n' % (self.tGUID,))
        if self.kindOf is not None and 'kindOf' not in already_processed:
            already_processed.add('kindOf')
            showIndent(outfile, level)
            outfile.write('kindOf=%s,\n' % (self.kindOf,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TypeName is not None:
            showIndent(outfile, level)
            outfile.write('TypeName=%s,\n' % quote_python(self.TypeName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ImageFile=[\n')
        level += 1
        for ImageFile_ in self.ImageFile:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ImageFile_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LNMapping=[\n')
        level += 1
        for LNMapping_ in self.LNMapping:
            showIndent(outfile, level)
            outfile.write('model_.LNMappingType(\n')
            LNMapping_.exportLiteral(outfile, level, name_='LNMappingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sector=[\n')
        level += 1
        for Sector_ in self.Sector:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Sector_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.DocumentationType(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            self.abstract = value
        value = find_attr_value_('isSymmetricLink', node)
        if value is not None and 'isSymmetricLink' not in already_processed:
            already_processed.add('isSymmetricLink')
            self.isSymmetricLink = value
        value = find_attr_value_('tGUID', node)
        if value is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            self.tGUID = value
        value = find_attr_value_('kindOf', node)
        if value is not None and 'kindOf' not in already_processed:
            already_processed.add('kindOf')
            self.kindOf = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TypeName':
            TypeName_ = child_.text
            TypeName_ = self.gds_validate_string(TypeName_, node, 'TypeName')
            self.TypeName = TypeName_
        elif nodeName_ == 'ImageFile':
            ImageFile_ = child_.text
            ImageFile_ = self.gds_validate_string(ImageFile_, node, 'ImageFile')
            self.ImageFile.append(ImageFile_)
        elif nodeName_ == 'LNMapping':
            obj_ = LNMappingType.factory()
            obj_.build(child_)
            self.LNMapping.append(obj_)
            obj_.original_tagname_ = 'LNMapping'
        elif nodeName_ == 'Sector':
            Sector_ = child_.text
            Sector_ = self.gds_validate_string(Sector_, node, 'Sector')
            self.Sector.append(Sector_)
        elif nodeName_ == 'Documentation':
            obj_ = DocumentationType.factory()
            obj_.build(child_)
            self.Documentation = obj_
            obj_.original_tagname_ = 'Documentation'
# end class TypeType


class PropertyType(GeneratedsSuper):
    """Reference to the pGUID of the property type from which this property
    type derives.If true, indicates that the property type should
    never exist as an instance on an item type, but is only intended
    for other property types to derive from."""
    subclass = None
    superclass = None
    def __init__(self, pGUID=None, baseProperty=None, abstract='false', PropertyName=None, RelatedType=None, UnrelatedType=None, Form=None, UnrelatedForm=None, Sector=None, Documentation=None):
        self.original_tagname_ = None
        self.pGUID = _cast(None, pGUID)
        self.baseProperty = _cast(None, baseProperty)
        self.abstract = _cast(None, abstract)
        self.PropertyName = PropertyName
        if RelatedType is None:
            self.RelatedType = []
        else:
            self.RelatedType = RelatedType
        if UnrelatedType is None:
            self.UnrelatedType = []
        else:
            self.UnrelatedType = UnrelatedType
        if Form is None:
            self.Form = []
        else:
            self.Form = Form
        if UnrelatedForm is None:
            self.UnrelatedForm = []
        else:
            self.UnrelatedForm = UnrelatedForm
        if Sector is None:
            self.Sector = []
        else:
            self.Sector = Sector
        self.Documentation = Documentation
    def factory(*args_, **kwargs_):
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyName(self): return self.PropertyName
    def set_PropertyName(self, PropertyName): self.PropertyName = PropertyName
    def get_RelatedType(self): return self.RelatedType
    def set_RelatedType(self, RelatedType): self.RelatedType = RelatedType
    def add_RelatedType(self, value): self.RelatedType.append(value)
    def insert_RelatedType(self, index, value): self.RelatedType[index] = value
    def get_UnrelatedType(self): return self.UnrelatedType
    def set_UnrelatedType(self, UnrelatedType): self.UnrelatedType = UnrelatedType
    def add_UnrelatedType(self, value): self.UnrelatedType.append(value)
    def insert_UnrelatedType(self, index, value): self.UnrelatedType[index] = value
    def get_Form(self): return self.Form
    def set_Form(self, Form): self.Form = Form
    def add_Form(self, value): self.Form.append(value)
    def insert_Form(self, index, value): self.Form[index] = value
    def get_UnrelatedForm(self): return self.UnrelatedForm
    def set_UnrelatedForm(self, UnrelatedForm): self.UnrelatedForm = UnrelatedForm
    def add_UnrelatedForm(self, value): self.UnrelatedForm.append(value)
    def insert_UnrelatedForm(self, index, value): self.UnrelatedForm[index] = value
    def get_Sector(self): return self.Sector
    def set_Sector(self, Sector): self.Sector = Sector
    def add_Sector(self, value): self.Sector.append(value)
    def insert_Sector(self, index, value): self.Sector[index] = value
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_pGUID(self): return self.pGUID
    def set_pGUID(self, pGUID): self.pGUID = pGUID
    def get_baseProperty(self): return self.baseProperty
    def set_baseProperty(self, baseProperty): self.baseProperty = baseProperty
    def get_abstract(self): return self.abstract
    def set_abstract(self, abstract): self.abstract = abstract
    def hasContent_(self):
        if (
            self.PropertyName is not None or
            self.RelatedType or
            self.UnrelatedType or
            self.Form or
            self.UnrelatedForm or
            self.Sector or
            self.Documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType'):
        if self.pGUID is not None and 'pGUID' not in already_processed:
            already_processed.add('pGUID')
            outfile.write(' pGUID=%s' % (quote_attrib(self.pGUID), ))
        if self.baseProperty is not None and 'baseProperty' not in already_processed:
            already_processed.add('baseProperty')
            outfile.write(' baseProperty=%s' % (quote_attrib(self.baseProperty), ))
        if self.abstract is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract=%s' % (quote_attrib(self.abstract), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PropertyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPropertyName>%s</%sPropertyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.PropertyName).encode(ExternalEncoding), input_name='PropertyName'), namespace_, eol_))
        for RelatedType_ in self.RelatedType:
            RelatedType_.export(outfile, level, namespace_, name_='RelatedType', pretty_print=pretty_print)
        for UnrelatedType_ in self.UnrelatedType:
            UnrelatedType_.export(outfile, level, namespace_, name_='UnrelatedType', pretty_print=pretty_print)
        for Form_ in self.Form:
            Form_.export(outfile, level, namespace_, name_='Form', pretty_print=pretty_print)
        for UnrelatedForm_ in self.UnrelatedForm:
            UnrelatedForm_.export(outfile, level, namespace_, name_='UnrelatedForm', pretty_print=pretty_print)
        for Sector_ in self.Sector:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSector>%s</%sSector>%s' % (namespace_, self.gds_format_string(quote_xml(Sector_).encode(ExternalEncoding), input_name='Sector'), namespace_, eol_))
        if self.Documentation is not None:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pGUID is not None and 'pGUID' not in already_processed:
            already_processed.add('pGUID')
            showIndent(outfile, level)
            outfile.write('pGUID=%s,\n' % (self.pGUID,))
        if self.baseProperty is not None and 'baseProperty' not in already_processed:
            already_processed.add('baseProperty')
            showIndent(outfile, level)
            outfile.write('baseProperty=%s,\n' % (self.baseProperty,))
        if self.abstract is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            showIndent(outfile, level)
            outfile.write('abstract=%s,\n' % (self.abstract,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PropertyName is not None:
            showIndent(outfile, level)
            outfile.write('PropertyName=%s,\n' % quote_python(self.PropertyName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('RelatedType=[\n')
        level += 1
        for RelatedType_ in self.RelatedType:
            showIndent(outfile, level)
            outfile.write('model_.RelatedTypeType(\n')
            RelatedType_.exportLiteral(outfile, level, name_='RelatedTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UnrelatedType=[\n')
        level += 1
        for UnrelatedType_ in self.UnrelatedType:
            showIndent(outfile, level)
            outfile.write('model_.UnrelatedTypeType(\n')
            UnrelatedType_.exportLiteral(outfile, level, name_='UnrelatedTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Form=[\n')
        level += 1
        for Form_ in self.Form:
            showIndent(outfile, level)
            outfile.write('model_.FormType1(\n')
            Form_.exportLiteral(outfile, level, name_='FormType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UnrelatedForm=[\n')
        level += 1
        for UnrelatedForm_ in self.UnrelatedForm:
            showIndent(outfile, level)
            outfile.write('model_.UnrelatedFormType(\n')
            UnrelatedForm_.exportLiteral(outfile, level, name_='UnrelatedFormType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sector=[\n')
        level += 1
        for Sector_ in self.Sector:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Sector_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.DocumentationType(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pGUID', node)
        if value is not None and 'pGUID' not in already_processed:
            already_processed.add('pGUID')
            self.pGUID = value
        value = find_attr_value_('baseProperty', node)
        if value is not None and 'baseProperty' not in already_processed:
            already_processed.add('baseProperty')
            self.baseProperty = value
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            self.abstract = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyName':
            PropertyName_ = child_.text
            PropertyName_ = self.gds_validate_string(PropertyName_, node, 'PropertyName')
            self.PropertyName = PropertyName_
        elif nodeName_ == 'RelatedType':
            obj_ = RelatedTypeType.factory()
            obj_.build(child_)
            self.RelatedType.append(obj_)
            obj_.original_tagname_ = 'RelatedType'
        elif nodeName_ == 'UnrelatedType':
            obj_ = UnrelatedTypeType.factory()
            obj_.build(child_)
            self.UnrelatedType.append(obj_)
            obj_.original_tagname_ = 'UnrelatedType'
        elif nodeName_ == 'Form':
            obj_ = FormType1.factory()
            obj_.build(child_)
            self.Form.append(obj_)
            obj_.original_tagname_ = 'Form'
        elif nodeName_ == 'UnrelatedForm':
            obj_ = UnrelatedFormType.factory()
            obj_.build(child_)
            self.UnrelatedForm.append(obj_)
            obj_.original_tagname_ = 'UnrelatedForm'
        elif nodeName_ == 'Sector':
            Sector_ = child_.text
            Sector_ = self.gds_validate_string(Sector_, node, 'Sector')
            self.Sector.append(Sector_)
        elif nodeName_ == 'Documentation':
            obj_ = DocumentationType.factory()
            obj_.build(child_)
            self.Documentation = obj_
            obj_.original_tagname_ = 'Documentation'
# end class PropertyType


class FormType(GeneratedsSuper):
    """Specifies the units of the value of the property with this form.
    Must be one of the units defined by the domain element specified
    by this form's domain attribute.The multiplication factor of the
    value of the property that has this form. The amount necessary
    to multiply the properties numerical value by in order to obtain
    a value in the units specified by the units attribute."""
    subclass = None
    superclass = None
    def __init__(self, units=None, fGUID=None, factor=None, FormName=None, baseForm=None, formatters=None, Documentation=None):
        self.original_tagname_ = None
        self.units = _cast(None, units)
        self.fGUID = _cast(None, fGUID)
        self.factor = _cast(None, factor)
        self.FormName = FormName
        self.baseForm = baseForm
        self.formatters = formatters
        self.Documentation = Documentation
    def factory(*args_, **kwargs_):
        if FormType.subclass:
            return FormType.subclass(*args_, **kwargs_)
        else:
            return FormType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FormName(self): return self.FormName
    def set_FormName(self, FormName): self.FormName = FormName
    def get_baseForm(self): return self.baseForm
    def set_baseForm(self, baseForm): self.baseForm = baseForm
    def get_formatters(self): return self.formatters
    def set_formatters(self, formatters): self.formatters = formatters
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_fGUID(self): return self.fGUID
    def set_fGUID(self, fGUID): self.fGUID = fGUID
    def get_factor(self): return self.factor
    def set_factor(self, factor): self.factor = factor
    def validate_baseFormType(self, value):
        # Validate type baseFormType, a restriction on string.
        pass
    def hasContent_(self):
        if (
            self.FormName is not None or
            self.baseForm is not None or
            self.formatters is not None or
            self.Documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FormType', namespacedef_=' xmlns:lcx="http://www.i2group.com/Schemas/2001-12-07/LCXSchema" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FormType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            outfile.write(' fGUID=%s' % (quote_attrib(self.fGUID), ))
        if self.factor is not None and 'factor' not in already_processed:
            already_processed.add('factor')
            outfile.write(' factor=%s' % (quote_attrib(self.factor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FormType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FormName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormName>%s</%sFormName>%s' % (namespace_, self.gds_format_string(quote_xml(self.FormName).encode(ExternalEncoding), input_name='FormName'), namespace_, eol_))
        if self.baseForm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbaseForm>%s</%sbaseForm>%s' % (namespace_, self.gds_format_string(quote_xml(self.baseForm).encode(ExternalEncoding), input_name='baseForm'), namespace_, eol_))
        if self.formatters is not None:
            self.formatters.export(outfile, level, namespace_, name_='formatters', pretty_print=pretty_print)
        if self.Documentation is not None:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FormType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units=%s,\n' % (self.units,))
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            showIndent(outfile, level)
            outfile.write('fGUID=%s,\n' % (self.fGUID,))
        if self.factor is not None and 'factor' not in already_processed:
            already_processed.add('factor')
            showIndent(outfile, level)
            outfile.write('factor=%s,\n' % (self.factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FormName is not None:
            showIndent(outfile, level)
            outfile.write('FormName=%s,\n' % quote_python(self.FormName).encode(ExternalEncoding))
        if self.baseForm is not None:
            showIndent(outfile, level)
            outfile.write('baseForm=%s,\n' % quote_python(self.baseForm).encode(ExternalEncoding))
        if self.formatters is not None:
            showIndent(outfile, level)
            outfile.write('formatters=model_.formattersType(\n')
            self.formatters.exportLiteral(outfile, level, name_='formatters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.SimpleDocumentationType(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        value = find_attr_value_('fGUID', node)
        if value is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            self.fGUID = value
        value = find_attr_value_('factor', node)
        if value is not None and 'factor' not in already_processed:
            already_processed.add('factor')
            self.factor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FormName':
            FormName_ = child_.text
            FormName_ = self.gds_validate_string(FormName_, node, 'FormName')
            self.FormName = FormName_
        elif nodeName_ == 'baseForm':
            baseForm_ = child_.text
            baseForm_ = self.gds_validate_string(baseForm_, node, 'baseForm')
            self.baseForm = baseForm_
            self.validate_baseFormType(self.baseForm)    # validate type baseFormType
        elif nodeName_ == 'formatters':
            obj_ = formattersType.factory()
            obj_.build(child_)
            self.formatters = obj_
            obj_.original_tagname_ = 'formatters'
        elif nodeName_ == 'Documentation':
            obj_ = SimpleDocumentationType.factory()
            obj_.build(child_)
            self.Documentation = obj_
            obj_.original_tagname_ = 'Documentation'
# end class FormType


class DomainType(GeneratedsSuper):
    """The name of a domain must be unique, and is used to refer to the
    domain by forms within the library catalogue."""
    subclass = None
    superclass = None
    def __init__(self, name=None, Unit=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
    def factory(*args_, **kwargs_):
        if DomainType.subclass:
            return DomainType.subclass(*args_, **kwargs_)
        else:
            return DomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    def add_Unit(self, value): self.Unit.append(value)
    def insert_Unit(self, index, value): self.Unit[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.Unit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DomainType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DomainType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Unit_ in self.Unit:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_format_string(quote_xml(Unit_).encode(ExternalEncoding), input_name='Unit'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DomainType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Unit=[\n')
        level += 1
        for Unit_ in self.Unit:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Unit_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit.append(Unit_)
# end class DomainType


class LNMappingType(GeneratedsSuper):
    """This mapping element will only be used by Online iLink if the locale
    attribute on it matches its locale registry setting."""
    subclass = None
    superclass = None
    def __init__(self, locale=None, IconFile=None, TypeName=None):
        self.original_tagname_ = None
        self.locale = _cast(None, locale)
        self.IconFile = IconFile
        self.TypeName = TypeName
    def factory(*args_, **kwargs_):
        if LNMappingType.subclass:
            return LNMappingType.subclass(*args_, **kwargs_)
        else:
            return LNMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IconFile(self): return self.IconFile
    def set_IconFile(self, IconFile): self.IconFile = IconFile
    def get_TypeName(self): return self.TypeName
    def set_TypeName(self, TypeName): self.TypeName = TypeName
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def hasContent_(self):
        if (
            self.IconFile is not None or
            self.TypeName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LNMappingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LNMappingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LNMappingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LNMappingType'):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            outfile.write(' locale=%s' % (quote_attrib(self.locale), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LNMappingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IconFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIconFile>%s</%sIconFile>%s' % (namespace_, self.gds_format_string(quote_xml(self.IconFile).encode(ExternalEncoding), input_name='IconFile'), namespace_, eol_))
        if self.TypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeName>%s</%sTypeName>%s' % (namespace_, self.gds_format_string(quote_xml(self.TypeName).encode(ExternalEncoding), input_name='TypeName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LNMappingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            showIndent(outfile, level)
            outfile.write('locale=%s,\n' % (self.locale,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IconFile is not None:
            showIndent(outfile, level)
            outfile.write('IconFile=%s,\n' % quote_python(self.IconFile).encode(ExternalEncoding))
        if self.TypeName is not None:
            showIndent(outfile, level)
            outfile.write('TypeName=%s,\n' % quote_python(self.TypeName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            self.locale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IconFile':
            IconFile_ = child_.text
            IconFile_ = self.gds_validate_string(IconFile_, node, 'IconFile')
            self.IconFile = IconFile_
        elif nodeName_ == 'TypeName':
            TypeName_ = child_.text
            TypeName_ = self.gds_validate_string(TypeName_, node, 'TypeName')
            self.TypeName = TypeName_
# end class LNMappingType


class RelatedTypeType(GeneratedsSuper):
    """The tGUID of the type to which this property relates."""
    subclass = None
    superclass = None
    def __init__(self, tGUID=None):
        self.original_tagname_ = None
        self.tGUID = _cast(None, tGUID)
    def factory(*args_, **kwargs_):
        if RelatedTypeType.subclass:
            return RelatedTypeType.subclass(*args_, **kwargs_)
        else:
            return RelatedTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tGUID(self): return self.tGUID
    def set_tGUID(self, tGUID): self.tGUID = tGUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedTypeType'):
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            outfile.write(' tGUID=%s' % (quote_attrib(self.tGUID), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RelatedTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            showIndent(outfile, level)
            outfile.write('tGUID=%s,\n' % (self.tGUID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tGUID', node)
        if value is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            self.tGUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RelatedTypeType


class UnrelatedTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tGUID=None):
        self.original_tagname_ = None
        self.tGUID = _cast(None, tGUID)
    def factory(*args_, **kwargs_):
        if UnrelatedTypeType.subclass:
            return UnrelatedTypeType.subclass(*args_, **kwargs_)
        else:
            return UnrelatedTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tGUID(self): return self.tGUID
    def set_tGUID(self, tGUID): self.tGUID = tGUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnrelatedTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnrelatedTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnrelatedTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnrelatedTypeType'):
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            outfile.write(' tGUID=%s' % (quote_attrib(self.tGUID), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnrelatedTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='UnrelatedTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tGUID is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            showIndent(outfile, level)
            outfile.write('tGUID=%s,\n' % (self.tGUID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tGUID', node)
        if value is not None and 'tGUID' not in already_processed:
            already_processed.add('tGUID')
            self.tGUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnrelatedTypeType


class FormType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fGUID=None):
        self.original_tagname_ = None
        self.fGUID = _cast(None, fGUID)
    def factory(*args_, **kwargs_):
        if FormType1.subclass:
            return FormType1.subclass(*args_, **kwargs_)
        else:
            return FormType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fGUID(self): return self.fGUID
    def set_fGUID(self, fGUID): self.fGUID = fGUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FormType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FormType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormType1'):
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            outfile.write(' fGUID=%s' % (quote_attrib(self.fGUID), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FormType1', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FormType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            showIndent(outfile, level)
            outfile.write('fGUID=%s,\n' % (self.fGUID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fGUID', node)
        if value is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            self.fGUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FormType1


class UnrelatedFormType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fGUID=None):
        self.original_tagname_ = None
        self.fGUID = _cast(None, fGUID)
    def factory(*args_, **kwargs_):
        if UnrelatedFormType.subclass:
            return UnrelatedFormType.subclass(*args_, **kwargs_)
        else:
            return UnrelatedFormType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fGUID(self): return self.fGUID
    def set_fGUID(self, fGUID): self.fGUID = fGUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnrelatedFormType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnrelatedFormType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnrelatedFormType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnrelatedFormType'):
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            outfile.write(' fGUID=%s' % (quote_attrib(self.fGUID), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnrelatedFormType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='UnrelatedFormType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fGUID is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            showIndent(outfile, level)
            outfile.write('fGUID=%s,\n' % (self.fGUID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fGUID', node)
        if value is not None and 'fGUID' not in already_processed:
            already_processed.add('fGUID')
            self.fGUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnrelatedFormType


class formattersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, formatter=None):
        self.original_tagname_ = None
        if formatter is None:
            self.formatter = []
        else:
            self.formatter = formatter
    def factory(*args_, **kwargs_):
        if formattersType.subclass:
            return formattersType.subclass(*args_, **kwargs_)
        else:
            return formattersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formatter(self): return self.formatter
    def set_formatter(self, formatter): self.formatter = formatter
    def add_formatter(self, value): self.formatter.append(value)
    def insert_formatter(self, index, value): self.formatter[index] = value
    def hasContent_(self):
        if (
            self.formatter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='formattersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='formattersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='formattersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='formattersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='formattersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for formatter_ in self.formatter:
            formatter_.export(outfile, level, namespace_, name_='formatter', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='formattersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('formatter=[\n')
        level += 1
        for formatter_ in self.formatter:
            showIndent(outfile, level)
            outfile.write('model_.formatterType(\n')
            formatter_.exportLiteral(outfile, level, name_='formatterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formatter':
            obj_ = formatterType.factory()
            obj_.build(child_)
            self.formatter.append(obj_)
            obj_.original_tagname_ = 'formatter'
# end class formattersType


class formatterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, syntax='iLink', valueOf_=None):
        self.original_tagname_ = None
        self.syntax = _cast(None, syntax)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if formatterType.subclass:
            return formatterType.subclass(*args_, **kwargs_)
        else:
            return formatterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_syntax(self): return self.syntax
    def set_syntax(self, syntax): self.syntax = syntax
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='formatterType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='formatterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='formatterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='formatterType'):
        if self.syntax is not None and 'syntax' not in already_processed:
            already_processed.add('syntax')
            outfile.write(' syntax=%s' % (quote_attrib(self.syntax), ))
    def exportChildren(self, outfile, level, namespace_='', name_='formatterType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='formatterType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.syntax is not None and 'syntax' not in already_processed:
            already_processed.add('syntax')
            showIndent(outfile, level)
            outfile.write('syntax=%s,\n' % (self.syntax,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('syntax', node)
        if value is not None and 'syntax' not in already_processed:
            already_processed.add('syntax')
            self.syntax = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class formatterType


GDSClassesMapping = {
    'Domain': DomainType,
    'formatter': formatterType,
    'UnrelatedForm': UnrelatedFormType,
    'Form': FormType1,
    'LNMapping': LNMappingType,
    'RelatedType': RelatedTypeType,
    'Documentation': SimpleDocumentationType,
    'LibraryCatalogue': LibraryCatalogueType,
    'formatters': formattersType,
    'UnrelatedType': UnrelatedTypeType,
    'Property': PropertyType,
    'Type': TypeType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ApplicationVersion'
        rootClass = ApplicationVersion
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ApplicationVersion'
        rootClass = ApplicationVersion
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ApplicationVersion'
        rootClass = ApplicationVersion
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ApplicationVersion'
        rootClass = ApplicationVersion
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from anx import *\n\n')
        sys.stdout.write('import anx as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ApplicationVersion",
    "Attribute",
    "AttributeClass",
    "AttributeClassCollection",
    "AttributeClassEntry",
    "AttributeClassEntryCollection",
    "AttributeCollection",
    "AttributeEntryCollection",
    "Box",
    "BoxStyle",
    "CIStyle",
    "Card",
    "CardCollection",
    "Chart",
    "ChartItem",
    "ChartItemCollection",
    "Circle",
    "CircleStyle",
    "Connection",
    "ConnectionCollection",
    "ConnectionStyle",
    "Corner",
    "CornerCollection",
    "CurrentBoxStyle",
    "CurrentCircleStyle",
    "CurrentEventStyle",
    "CurrentIconStyle",
    "CurrentLabelStyle",
    "CurrentLinkStyle",
    "CurrentOleItemStyle",
    "CurrentStyleCollection",
    "CurrentTextBlockStyle",
    "CurrentThemeStyle",
    "CustomImage",
    "CustomImageCollection",
    "CustomProperty",
    "CustomPropertyCollection",
    "DatabaseKey",
    "DatabaseKeyCollection",
    "DatabaseObjectProxy",
    "DatabaseProperty",
    "DatabasePropertyCollection",
    "DatabasePropertyType",
    "DatabasePropertyTypeCollection",
    "DatabaseProxy",
    "DatabaseProxyCollection",
    "DateTimeFormat",
    "DateTimeFormatCollection",
    "DocumentationType",
    "DomainType",
    "End",
    "Entity",
    "EntityObjects",
    "EntityType",
    "EntityTypeCollection",
    "EntityTypeEntry",
    "EntityTypeEntryCollection",
    "Event",
    "EventStyle",
    "Field",
    "FieldCollection",
    "Font",
    "Footer",
    "FooterCollection",
    "FormType",
    "FormType1",
    "FrameStyle",
    "GradeOne",
    "GradeThree",
    "GradeTwo",
    "Group",
    "GroupCollection",
    "Header",
    "HeaderCollection",
    "Icon",
    "IconPicture",
    "IconStyle",
    "Junction",
    "JunctionCollection",
    "JunctionStyle",
    "Key",
    "LNMappingType",
    "Label",
    "LabelStyle",
    "LegendDefinition",
    "LegendItem",
    "LibraryCatalogueType",
    "Link",
    "LinkObjects",
    "LinkStyle",
    "LinkType",
    "LinkTypeCollection",
    "LinkTypeEntry",
    "LinkTypeEntryCollection",
    "OleItem",
    "OleItemStyle",
    "Origin",
    "PageSettings",
    "Palette",
    "PaletteBar",
    "PaletteBarCollection",
    "PaletteCollection",
    "PrintSettings",
    "PropertyBag",
    "PropertyBagCollection",
    "PropertyBagProperty",
    "PropertyType",
    "RelatedTypeType",
    "SectorDefinition",
    "SimpleDocumentationType",
    "Snapshot",
    "SnapshotCollection",
    "SnapshotItem",
    "SnapshotItemCollection",
    "SourceHints",
    "Strength",
    "StrengthCollection",
    "String",
    "StringCollection",
    "SubItem",
    "SubItemCollection",
    "Summary",
    "TextBlock",
    "TextBlockStyle",
    "Theme",
    "ThemeJunctions",
    "ThemeStyle",
    "TimeBar",
    "TimeBarIntervalBandStyle",
    "TimeBarMarkerBandStyle",
    "TimeBarTickBandStyle",
    "TimeZone",
    "TypeType",
    "UnrelatedFormType",
    "UnrelatedTypeType",
    "formatterType",
    "formattersType"
]
